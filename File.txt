import sqlite3
import re
import json
import asyncio
import requests
import os
import threading
from datetime import datetime, timedelta, timezone, time
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler

# -------------------- CONSTANTS AND SETTINGS --------------------
BOT_TOKEN = "7405848829:AAHxDv0DP_Co512vOvGw_PDsXYDjE4fgOJ0"
YEKATERINBURG_TZ = timezone(timedelta(hours=5))
DEFAULT_GROUP = "–ò–î-127"

# States for ConversationHandler
AWAITING_HOMEWORK, AWAITING_INFO, AWAITING_SPORT, AWAITING_SUGGESTION, AWAITING_HOMEWORK_DELETE, AWAITING_INFO_DELETE, AWAITING_SPORT_DELETE, AWAITING_USER_DELETE, AWAITING_SUGGESTION_DELETE, AWAITING_GROUP, AWAITING_POLL_QUESTION, AWAITING_POLL_OPTIONS, AWAITING_SUGGESTION_REPLY, AWAITING_PHOTO_OR_VIDEO_HOMEWORK = range(14)

# User Roles
ROLE_STUDENT = 'student'
ROLE_PHYSICAL_ORGANIZER = 'physical_organizer'
ROLE_IT_SPECIALIST = 'it_specialist'
ROLE_DEVELOPER = 'developer'

# Special Users (ID and username)
DEVELOPER_ID = 1775957387
SPECIAL_USERS = {
    5013216284: {'role': ROLE_IT_SPECIALIST, 'username': '@kimertuzz3', 'name': '–°—Ç–∞—Ä–æ—Å—Ç–∞'},
    DEVELOPER_ID: {'role': ROLE_DEVELOPER, 'username': '@imya_polbzovatela', 'name': '–ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã'},
    5078637058: {'role': ROLE_PHYSICAL_ORGANIZER, 'username': '@NateDiazFight', 'name': '–§–∏–∑. –æ—Ä–≥.'}
}

# Full list of groups
ALL_GROUPS = [
    "–ò–î-126", "–ò–î-127", "–ú–î-1126", "–ú–î-1127", "–ú–î-1128", "–û–î–õ–î-107", "–û–î–õ–î-108",
    "–ü–°–î-144", "–ü–°–î-145", "–¢–î-1128", "–¢–î-1129", "–¢–î-1130", "–¢–ú–î-123", "–¢–ú–î-124", "–¢–ú–î-125",
    "–≠–î-1111", "–≠–î-1112", "–≠–î-1113", "–ò–î-224", "–ò–î-225", "–ú–î-2123", "–ú–î-2124", "–ú–î-2125",
    "–û–¥–õ–î-205", "–û–¥–õ–î-206", "–ü–°–î-242", "–ü–°–î-243", "–¢–î-2125", "–¢–î-2126", "–¢–î-2127", "–¢–ú–î-220",
    "–¢–ú–î-221", "–¢–ú–î-222", "–≠–î-2108", "–≠–î-2109", "–≠–î-2110", "–ò–î-323", "–ú–î-3121", "–ú–î-3122",
    "–û–°–ê–î-302", "–û–¥–õ–î-303", "–û–¥–õ–î-304", "–ü–°–î-340", "–ü–°–î-341", "–¢–î-3121", "–¢–î-3123", "–¢–ú–î-317",
    "–¢–ú–î-318", "–≠–î-3106", "–≠–î-3107", "–ò–î-421", "–ò–î-422"
]

# Schedule cache
schedule_cache = {}
last_schedule_check = None

# User notifications cache to prevent duplicate messages
user_notification_cache = {}

# Anti-spam system
user_message_timestamps = {}
user_cooldowns = {}
user_cooldown_multipliers = {}
SPAM_THRESHOLD = 10
SPAM_INTERVAL = 5
COOLDOWN_BASE_TIME = 600 # 10 minutes

# Global dictionary to store poll data
polls_data = {}

# Global dictionary for user states during multi-photo upload
multi_photo_state = {}

# -------------------- DATABASE FUNCTIONS --------------------

def init_db():
    """Initializes the database"""
    conn = None
    try:
        conn = sqlite3.connect('bot_data.db')
        cur = conn.cursor()
        
        # Users table
        cur.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            group_name TEXT,
            role TEXT DEFAULT 'student',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        # Homeworks table
        cur.execute('''CREATE TABLE IF NOT EXISTS homeworks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            subject TEXT,
            task TEXT,
            deadline TEXT,
            group_name TEXT,
            added_by INTEGER,
            file_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Notifications table (from IT specialists)
        cur.execute('''CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            file_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Sport notifications table (from physical organizer)
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            file_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Suggestions table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            file_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )''')
        
        # Polls table
        cur.execute('''CREATE TABLE IF NOT EXISTS polls (
            id INTEGER PRIMARY KEY,
            question TEXT,
            options TEXT,
            creator_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        # Poll votes table
        cur.execute('''CREATE TABLE IF NOT EXISTS poll_votes (
            poll_id INTEGER,
            user_id INTEGER,
            vote_option TEXT,
            voted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (poll_id, user_id),
            FOREIGN KEY (poll_id) REFERENCES polls (id),
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )''')

        conn.commit()
        print("–õ–û–ì: –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
    finally:
        if conn:
            conn.close()

def get_db_connection():
    """Creates a connection to the database"""
    try:
        conn = sqlite3.connect('bot_data.db')
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏: {e}")
        return None

def get_user(user_id):
    """Gets user information"""
    conn = get_db_connection()
    if not conn: return None
    try:
        user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        return user
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        return None
    finally:
        conn.close()

def get_all_users():
    """Gets a list of all users"""
    conn = get_db_connection()
    if not conn: return []
    try:
        users = conn.execute('SELECT user_id, first_name, username, group_name FROM users').fetchall()
        return users
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return []
    finally:
        conn.close()

def add_user(user_id, username, first_name, last_name):
    """Adds a new user to the database or updates existing user"""
    conn = get_db_connection()
    if not conn: return
    try:
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        role = ROLE_STUDENT
        if user_id in SPECIAL_USERS:
            role = SPECIAL_USERS[user_id]['role']
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, group_name, role)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, DEFAULT_GROUP, role))
            print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {first_name} (ID: {user_id}) —Å –≥—Ä—É–ø–ø–æ–π {DEFAULT_GROUP} –∏ —Ä–æ–ª—å—é {role}")
        else:
            conn.execute('''UPDATE users 
                         SET username = ?, first_name = ?, last_name = ?, role = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, role, user_id))
            print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {first_name} (ID: {user_id}), —Ä–æ–ª—å: {role}")
        
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
    finally:
        conn.close()

def update_user_group(user_id, group_name):
    """Updates the user's group"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('UPDATE users SET group_name = ? WHERE user_id = ?', (group_name, user_id))
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Å–º–µ–Ω–∏–ª –≥—Ä—É–ø–ø—É –Ω–∞ {group_name}")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –≥—Ä—É–ø–ø—ã: {e}")
    finally:
        conn.close()
    
def get_total_user_count():
    """Gets the total number of users in the database"""
    conn = get_db_connection()
    if not conn: return 0
    try:
        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        return count
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return 0
    finally:
        conn.close()

def delete_homework(hw_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM homeworks WHERE id = ?', (hw_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –î–ó: {e}")
    finally:
        conn.close()

def delete_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def delete_sport_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM sport_notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def delete_user(user_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É–¥–∞–ª–µ–Ω –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
    finally:
        conn.close()

def delete_suggestion(suggestion_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM suggestions WHERE id = ?', (suggestion_id,))
        conn.commit()
        print(f"–õ–û–ì: –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {suggestion_id} —É–¥–∞–ª–µ–Ω–æ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def get_all_sport_notifications():
    """Gets all sport notifications"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     ORDER BY s.created_at DESC''').fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

# -------------------- SCHEDULE FUNCTIONS --------------------

def fetch_schedule_data():
    """Fetches schedule data from the website"""
    try:
        url = "https://pmk-online.ru/students/schedule/"
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
        resp = requests.get(url, headers=headers, timeout=10)
        resp.raise_for_status()
        html = resp.text

        match = re.search(r"const scheduleData\s*=\s*(\{.*?\});", html, re.S)
        if not match:
            print("–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ scheduleData –Ω–∞ —Å–∞–π—Ç–µ.")
            return None

        schedule_raw = match.group(1)
        schedule_json_str = schedule_raw.replace(";", "")
        return json.loads(schedule_json_str)
    
    except requests.exceptions.RequestException as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None
    except (json.JSONDecodeError, IndexError) as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None

def filter_today_lessons(lessons):
    """Filters lessons for today considering Yekaterinburg time"""
    today_yekat = datetime.now(YEKATERINBURG_TZ).date()
    return [lesson for lesson in lessons if lesson.get('date') and datetime.fromisoformat(lesson['date'].replace('Z', '+00:00')).astimezone(YEKATERINBURG_TZ).date() == today_yekat]

def filter_tomorrow_lessons(lessons):
    """Filters lessons for tomorrow considering Yekaterinburg time"""
    tomorrow_yekat = (datetime.now(YEKATERINBURG_TZ) + timedelta(days=1)).date()
    return [lesson for lesson in lessons if lesson.get('date') and datetime.fromisoformat(lesson['date'].replace('Z', '+00:00')).astimezone(YEKATERINBURG_TZ).date() == tomorrow_yekat]

def filter_week_lessons(lessons):
    """Filters lessons for the week considering Yekaterinburg time"""
    today_yekat = datetime.now(YEKATERINBURG_TZ).date()
    week_end = today_yekat + timedelta(days=7)
    return [lesson for lesson in lessons if lesson.get('date') and today_yekat <= datetime.fromisoformat(lesson['date'].replace('Z', '+00:00')).astimezone(YEKATERINBURG_TZ).date() <= week_end]

def get_lesson_time(lesson_number, day_of_week):
    """Returns the time of a lesson by its number, adjusted for Saturday"""
    # Standard schedule (Monday-Friday)
    lesson_times = {
        1: ("08:30", "10:05"), 2: ("10:15", "11:50"), 3: ("12:40", "14:15"),
        4: ("14:25", "16:00"), 5: ("16:10", "17:45"), 6: ("17:55", "19:30"),
    }
    # Saturday schedule
    saturday_times = {
        1: ("8:30", "9:45"), 2: ("9:55", "11:10"), 3: ("11:20", "12:40"), 
        4: ("13:20", "14:35"), 5: ("14:45", "16:00"), 6: ("16:10", "17:25")
    }

    if day_of_week == 5: # 5 is Saturday
        return saturday_times.get(lesson_number, ("‚ùì", "‚ùì"))
    else:
        return lesson_times.get(lesson_number, ("‚ùì", "‚ùì"))

def format_schedule(lessons, title):
    if not lessons:
        return "‚úÖ –ù–µ—Ç –∑–∞–Ω—è—Ç–∏–π"
    
    lessons.sort(key=lambda x: (x.get('date', ''), x.get('lessonNumber', 0)))
    
    result = [f"<b>{title}</b>\n"]
    current_date = None
    for lesson in lessons:
        try:
            lesson_date_utc = datetime.fromisoformat(lesson['date'].replace('Z', '+00:00'))
            lesson_date_yekat = lesson_date_utc.astimezone(YEKATERINBURG_TZ)
            date_str = lesson_date_yekat.strftime('%d.%m.%Y')
            
            if date_str != current_date:
                current_date = date_str
                day_names = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
                day_of_week_num = lesson_date_yekat.weekday()
                day_of_week = day_names[day_of_week_num]
                result.append(f"\nüìÖ <b>{date_str} ({day_of_week})</b>")
            
            lesson_number = lesson.get('lessonNumber', 0)
            start_time, end_time = get_lesson_time(lesson_number, day_of_week_num)
            
            lesson_text = (
                f"    ‚è∞ {start_time}-{end_time} | {lesson_number} –ø–∞—Ä–∞\n"
                f"    üìö {lesson.get('subjectFull', 'N/A')}\n"
                f"    üë®‚Äçüè´ {lesson.get('teacher', 'N/A')}\n"
                f"    üö™ {lesson.get('room', 'N/A')}\n"
            )
            result.append(lesson_text)
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—É: {e}")
            continue
    
    result.append(f"\nüìä <b>–í—Å–µ–≥–æ –∑–∞–Ω—è—Ç–∏–π:</b> {len(lessons)}")
    return "\n".join(result)

def get_schedule(period, group_name):
    """Gets and formats the schedule for the selected period and group"""
    try:
        global schedule_cache, last_schedule_check
        
        now = datetime.now(YEKATERINBURG_TZ)
        if last_schedule_check is None or (now - last_schedule_check).total_seconds() > 3600:
            schedule_data = fetch_schedule_data()
            if schedule_data:
                schedule_cache = schedule_data
                last_schedule_check = now
                print("–õ–û–ì: –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –∏–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞")
            else:
                print("–õ–û–ì: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à")
        else:
            schedule_data = schedule_cache
            print("–õ–û–ì: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
        
        if not schedule_data:
            return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ"

        if group_name not in schedule_data:
            return f"‚ùå –ù–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}"

        lessons = schedule_data[group_name]
        
        if period == 'üìÖ –°–µ–≥–æ–¥–Ω—è':
            filtered_lessons = filter_today_lessons(lessons)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ({group_name})"
        elif period == 'üìÖ –ó–∞–≤—Ç—Ä–∞':
            filtered_lessons = filter_tomorrow_lessons(lessons)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({group_name})"
        elif period == 'üìÖ –ù–µ–¥–µ–ª—è':
            filtered_lessons = filter_week_lessons(lessons)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é ({group_name})"
        else:
            filtered_lessons = lessons
            title = f"üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ ({group_name})"

        if not filtered_lessons:
            return f"‚úÖ –ù–µ—Ç –∑–∞–Ω—è—Ç–∏–π –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞."

        return format_schedule(filtered_lessons, title)

    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {str(e)}")
        return f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}"

async def check_schedule_changes(context: ContextTypes.DEFAULT_TYPE):
    """Checks for schedule changes and notifies users with diff"""
    global schedule_cache, last_schedule_check
    
    print("–õ–û–ì: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏...")
    new_schedule = fetch_schedule_data()
    
    if not new_schedule:
        print("–õ–û–ì: –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è")
        return

    for group_name in new_schedule.keys():
        old_lessons = schedule_cache.get(group_name, [])
        new_lessons = new_schedule.get(group_name, [])
        
        old_set = set(json.dumps(lesson, sort_keys=True) for lesson in old_lessons)
        new_set = set(json.dumps(lesson, sort_keys=True) for lesson in new_lessons)
        
        added_lessons_json = new_set - old_set
        removed_lessons_json = old_set - new_set
        
        if added_lessons_json or removed_lessons_json:
            print(f"–õ–û–ì: –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}")
            
            change_message = f"üîÑ <b>–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}</b>\n\n"
            
            if added_lessons_json:
                change_message += "üü¢ <b>–î–æ–±–∞–≤–ª–µ–Ω–æ:</b>\n"
                for lesson_json in added_lessons_json:
                    lesson = json.loads(lesson_json)
                    change_message += f"- {lesson.get('date')} | {lesson.get('subjectFull')}\n"
            
            if removed_lessons_json:
                if added_lessons_json:
                    change_message += "\n"
                change_message += "üî¥ <b>–£–¥–∞–ª–µ–Ω–æ:</b>\n"
                for lesson_json in removed_lessons_json:
                    lesson = json.loads(lesson_json)
                    change_message += f"- {lesson.get('date')} | {lesson.get('subjectFull')}\n"
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

    schedule_cache = new_schedule
    last_schedule_check = datetime.now(YEKATERINBURG_TZ)

async def send_daily_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends daily schedule at 19:00"""
    print("–õ–û–ì: –û—Ç–ø—Ä–∞–≤–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...")
    
    for group_name in schedule_cache.keys():
        lessons = schedule_cache.get(group_name)
        if not lessons:
            continue

        tomorrow_lessons = filter_tomorrow_lessons(lessons)
        
        if tomorrow_lessons:
            schedule_text = format_schedule(tomorrow_lessons, f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({group_name})")
            
            homeworks = get_homeworks(group_name)
            if homeworks:
                homework_text = "\n\nüìù <b>–î–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:</b>\n"
                for hw in homeworks[:3]:
                    homework_text += f"‚Ä¢ {hw['subject']}: {hw['task']} (–¥–æ {hw['deadline']})\n"
                schedule_text += homework_text
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_morning_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends morning schedule at 07:00"""
    print("–õ–û–ì: –û—Ç–ø—Ä–∞–≤–∫–∞ —É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...")
    
    for group_name in schedule_cache.keys():
        lessons = schedule_cache.get(group_name)
        if not lessons:
            continue

        today_lessons = filter_today_lessons(lessons)
        
        if today_lessons:
            schedule_text = format_schedule(today_lessons, f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ({group_name})")
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def check_next_lesson(context: ContextTypes.DEFAULT_TYPE):
    """Checks and sends notification about next lesson"""
    global schedule_cache, user_notification_cache
    
    # print("–õ–û–ì: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ª–µ–¥—É—é—â–µ–π –ø–∞—Ä—ã...")  # –£–±—Ä–∞–Ω–æ –ø–æ –ø—Ä–æ—Å—å–±–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    
    now = datetime.now(YEKATERINBURG_TZ)
    today_date = now.date()
    
    users_with_groups = get_db_connection().execute('SELECT user_id, group_name FROM users').fetchall()
    
    for user in users_with_groups:
        user_id = user['user_id']
        group_name = user['group_name']
        
        lessons = schedule_cache.get(group_name)
        if not lessons:
            continue

        today_lessons = filter_today_lessons(lessons)
        
        if not today_lessons:
            continue
            
        for i, lesson in enumerate(today_lessons):
            try:
                lesson_number = lesson.get('lessonNumber', 0)
                
                notification_key = f"{user_id}_{today_date}_{lesson_number}"
                
                if user_notification_cache.get(notification_key) is True:
                    continue

                day_of_week_num = now.weekday()
                start_time_str, _ = get_lesson_time(lesson_number, day_of_week_num)
                
                start_time_naive = datetime.strptime(start_time_str, '%H:%M').time()
                start_time_aware = datetime.combine(now.date(), start_time_naive).replace(tzinfo=YEKATERINBURG_TZ)
                
                if now + timedelta(minutes=5) >= start_time_aware and now < start_time_aware:
                    next_lesson_text = (
                        f"üìÖ <b>–ù–∞—á–∞–ª–æ —Å–ª–µ–¥—É—é—â–µ–π –ø–∞—Ä—ã —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç ({group_name})</b>\n\n"
                        f"    ‚è∞ {get_lesson_time(lesson_number, day_of_week_num)[0]}-{get_lesson_time(lesson_number, day_of_week_num)[1]} | {lesson_number} –ø–∞—Ä–∞\n"
                        f"    üìö {lesson.get('subjectFull', 'N/A')}\n"
                        f"    üë®‚Äçüè´ {lesson.get('teacher', 'N/A')}\n"
                        f"    üö™ {lesson.get('room', 'N/A')}\n"
                    )
                    
                    try:
                        await context.bot.send_message(user_id, next_lesson_text, parse_mode='HTML')
                        user_notification_cache[notification_key] = True
                    except Exception as e:
                        print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–ª–µ–¥—É—é—â–µ–π –ø–∞—Ä–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
                        
            except Exception as e:
                print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–∞—Ä—É: {e}")
                continue
                
    if now.hour == 0 and now.minute == 0:
        user_notification_cache.clear()

# -------------------- ANTI-SPAM FUNCTIONALITY --------------------

async def anti_spam(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    now = datetime.now()

    if user_id in user_cooldowns and now < user_cooldowns[user_id]:
        cooldown_remaining = int((user_cooldowns[user_id] - now).total_seconds())
        await update.message.reply_text(f"‚è≥ –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ {cooldown_remaining} —Å–µ–∫—É–Ω–¥ –∑–∞ —Å–ø–∞–º.")
        return False

    if user_id not in user_message_timestamps:
        user_message_timestamps[user_id] = []
    
    user_message_timestamps[user_id].append(now)
    
    # Remove old timestamps
    user_message_timestamps[user_id] = [ts for ts in user_message_timestamps[user_id] if now - ts < timedelta(seconds=SPAM_INTERVAL)]

    if len(user_message_timestamps[user_id]) > SPAM_THRESHOLD:
        if user_id not in user_cooldown_multipliers:
            user_cooldown_multipliers[user_id] = 1
            await update.message.reply_text("‚ö†Ô∏è **–ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï:** –ù–µ —Å–ø–∞–º—å—Ç–µ, –∏–Ω–∞—á–µ –±—É–¥–µ—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã.", parse_mode='Markdown')
        else:
            user_cooldown_multipliers[user_id] *= 2
            cooldown_time = COOLDOWN_BASE_TIME * user_cooldown_multipliers[user_id]
            user_cooldowns[user_id] = now + timedelta(seconds=cooldown_time)
            await update.message.reply_text(f"‚ùå **–ë–õ–û–ö–ò–†–û–í–ö–ê:** –í—ã –±—ã–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ {cooldown_time} —Å–µ–∫—É–Ω–¥ –∑–∞ —Å–ø–∞–º.", parse_mode='Markdown')
            
        user_message_timestamps[user_id] = []
        return False
        
    return True
    
# -------------------- CORE BOT FUNCTIONS --------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for the /start command"""
    user = update.effective_user
    user_id = user.id
    
    add_user(user_id, user.username, user.first_name, user.last_name)
    user_data = get_user(user_id)
    
    if not user_data or user_data['group_name'] not in ALL_GROUPS:
        return await ask_user_group(update, context)

    print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user.id}) –≤–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.")
    
    if user_id in SPECIAL_USERS and user_data['role'] != SPECIAL_USERS[user_id]['role']:
        keyboard = [[InlineKeyboardButton("üîÑ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ä–æ–ª—å", callback_data=f"fix_role_{user_id}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–æ–ª–∏. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å:",
            reply_markup=reply_markup
        )
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def ask_user_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks the user to select their group"""
    keyboard = [ALL_GROUPS[i:i+3] for i in range(0, len(ALL_GROUPS), 3)]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
    
    message_source = update.callback_query.message if update.callback_query else update.message
    await message_source.reply_text(
        "üëã –í—ã–±–µ—Ä–∏ —Å–≤–æ—é –≥—Ä—É–ø–ø—É:",
        reply_markup=reply_markup
    )
    
    return AWAITING_GROUP

async def handle_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the user's group selection and ends the conversation"""
    user = update.effective_user
    user_id = user.id
    group_name = update.message.text
    
    if group_name not in ALL_GROUPS:
        await update.message.reply_text(
            "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –≥—Ä—É–ø–ø—É –∏–∑ —Å–ø–∏—Å–∫–∞:",
            reply_markup=ReplyKeyboardMarkup([ALL_GROUPS[i:i+3] for i in range(0, len(ALL_GROUPS), 3)], 
                                           resize_keyboard=True, one_time_keyboard=True)
        )
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user_id}) –≤–≤–µ–ª –Ω–µ–≤–µ—Ä–Ω—É—é –≥—Ä—É–ø–ø—É: {group_name}")
        return AWAITING_GROUP
    
    update_user_group(user_id, group_name)
    
    await update.message.reply_text(
        f"‚úÖ –ì—Ä—É–ø–ø–∞ {group_name} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!",
        reply_markup=ReplyKeyboardRemove()
    )
    
    await show_main_menu(update, user_id)
    print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user_id}) —É—Å–ø–µ—à–Ω–æ –≤—ã–±—Ä–∞–ª –≥—Ä—É–ø–ø—É {group_name}.")
    return ConversationHandler.END

async def show_main_menu(update: Update, user_id: int):
    """Displays the main menu based on user rights"""
    user_data = get_user(user_id)
    if not user_data:
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /start –µ—â–µ —Ä–∞–∑.")
        return

    role = user_data['role']
    
    welcome_text = "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!"
    
    if user_id in SPECIAL_USERS:
        welcome_text = f"üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {SPECIAL_USERS[user_id]['name']}!"
    elif role == ROLE_IT_SPECIALIST:
        welcome_text = "üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –ê–π—Ç–∏—à–Ω–∏–∫!"
    elif role == ROLE_PHYSICAL_ORGANIZER:
        welcome_text = "üèÉ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –§–∏–∑. –æ—Ä–≥.!"
    elif role == ROLE_DEVELOPER:
        welcome_text = "üíª –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫!"

    keyboard_base = [
        ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
        ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
        ['üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é', 'üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É'],
        ['üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É']
    ]

    keyboard_special = []
    if role in [ROLE_IT_SPECIALIST, ROLE_DEVELOPER]:
        keyboard_special.extend([
            ['üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó', 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ'],
            ['üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å', 'üìä –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã'],
            ['üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', '–£–¥–∞–ª–µ–Ω–∏–µ']
        ])
    
    if role in [ROLE_PHYSICAL_ORGANIZER, ROLE_DEVELOPER]:
        keyboard_special.extend([
            ['üèÉ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–µ–Ω–∏–µ']
        ])
    
    if role == ROLE_DEVELOPER:
        keyboard_special.append(['–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π'])
    
    if role == ROLE_STUDENT:
        keyboard_base.extend([
            ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π', 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã'],
            ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ñ–∏–∑–æ—Ä–≥–æ–º']
        ])

    keyboard = keyboard_base + keyboard_special
    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    message_source = update.callback_query.message if update.callback_query else update.message
    await message_source.reply_text(welcome_text, reply_markup=reply_markup)

    print(f"–õ–û–ì: –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ø–æ–∫–∞–∑–∞–Ω–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_data['first_name']} (ID: {user_id}).")

async def show_deletion_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    if not user_data:
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /start –µ—â–µ —Ä–∞–∑.")
        return ConversationHandler.END

    role = user_data['role']
    keyboard = []
    
    if role in [ROLE_IT_SPECIALIST, ROLE_DEVELOPER]:
        keyboard.extend([
            ['–£–¥–∞–ª–∏—Ç—å –î–ó'],
            ['–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ'],
            ['–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è']
        ])
    
    if role in [ROLE_PHYSICAL_ORGANIZER, ROLE_DEVELOPER]:
        keyboard.append(['–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è'])
    
    if role == ROLE_DEVELOPER:
        keyboard.append(['–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è'])
    
    keyboard.append(['üîô –ù–∞–∑–∞–¥'])
    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å:", reply_markup=reply_markup)
    
async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels the current conversation and returns to the main menu"""
    user = update.effective_user
    user_id = user.id
    
    await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=ReplyKeyboardRemove())
    await show_main_menu(update, user_id)
    print(f"–õ–û–ì: –î–∏–∞–ª–æ–≥ –æ—Ç–º–µ–Ω–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {user.first_name} (ID: {user_id}).")
    return ConversationHandler.END

async def handle_simple_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for simple text messages that don't require a conversation"""
    user = update.effective_user
    user_id = user.id
    text = update.message.text
    user_data = get_user(user_id)
    
    if not await anti_spam(update, context):
        return
    
    print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user_id}) –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ: '{text}'")
    
    if not user_data or user_data['group_name'] not in ALL_GROUPS:
        add_user(user_id, user.username, user.first_name, user.last_name)
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–∂–º–∏ /start –∏ –≤—ã–±–µ—Ä–∏ —Å–≤–æ—é –≥—Ä—É–ø–ø—É.")
        return

    role = user_data['role']
    group_name = user_data['group_name']
    
    if text == 'üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ':
        await show_schedule_periods(update, user_id)
    
    elif text == 'üìù –î–ó':
        await show_homework(update, group_name)
    
    elif text == '‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è':
        await show_information(update, group_name, role)

    elif text == 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è' and (role in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER, ROLE_DEVELOPER]):
        await show_suggestions(update)
    
    elif text == '–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π' and role == ROLE_DEVELOPER:
        await show_users_list(update)

    elif text == 'üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É':
        donate_text = "–ï—Å–ª–∏ –Ω–µ –∂–∞–ª–∫–æ, –º–æ–∂–µ—à—å –¥–∞—Ç—å —Ä–∞–∑—Ä–∞–±—É –±–æ—Ç–∞ –¥–µ–Ω—é–∂–∫—É –Ω–∞ –¥–∞–ª—å–Ω–µ–π—à–µ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ –±–æ—Ç–∞ –∏ –Ω–∞ –ø–æ–∫—É—à–∞—Ç—åüòä"
        keyboard = [
            [InlineKeyboardButton("üí∏ –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å –∞–≤—Ç–æ—Ä–∞", url="https://www.donationalerts.com/r/ax_hikitka")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(donate_text, reply_markup=reply_markup)

    elif text == 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤':
        await show_call_schedule(update)
    
    elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ñ–∏–∑–æ—Ä–≥–æ–º':
        await contact_physical_organizer(update)
    
    elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π':
        await contact_starosta(update)

    elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã':
        await contact_deputy_starosta(update)
    
    elif text in ['üìÖ –°–µ–≥–æ–¥–Ω—è', 'üìÖ –ó–∞–≤—Ç—Ä–∞', 'üìÖ –ù–µ–¥–µ–ª—è', 'üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ']:
        await handle_schedule_period(update, context, group_name)
    
    elif text == 'üîô –ù–∞–∑–∞–¥':
        await show_main_menu(update, user_id)

    elif text == '–£–¥–∞–ª–µ–Ω–∏–µ':
        await show_deletion_menu(update, context)

    elif text == '–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' and role == ROLE_DEVELOPER:
        await delete_user_menu(update, context)

    elif text == '–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è' and (role == ROLE_DEVELOPER or role == ROLE_PHYSICAL_ORGANIZER):
        await delete_sport_notification_menu(update, context)
        
    elif text == '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è' and (role == ROLE_DEVELOPER or role == ROLE_IT_SPECIALIST):
        await delete_suggestions_menu(update, context)
        
    elif text == '–£–¥–∞–ª–∏—Ç—å –î–ó' and (role == ROLE_DEVELOPER or role == ROLE_IT_SPECIALIST):
        await delete_homework_menu(update, context)

    elif text == '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ' and (role == ROLE_DEVELOPER or role == ROLE_IT_SPECIALIST):
        await delete_notification_menu(update, context)

    elif text == 'üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å' and (role in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER, ROLE_DEVELOPER]):
        await ask_poll_question(update, context)

    elif text == 'üìä –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã' and (role in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER, ROLE_DEVELOPER]):
        await show_poll_results(update, context)
    
    else:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ üëá")
        print(f"–õ–û–ì: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ—Ç {user.first_name} (ID: {user_id}): '{text}'")

# -------------------- SCHEDULE DISPLAY FUNCTIONS --------------------

async def show_schedule_periods(update: Update, user_id: int):
    """Shows the schedule period selection"""
    keyboard = [
        ['üìÖ –°–µ–≥–æ–¥–Ω—è', 'üìÖ –ó–∞–≤—Ç—Ä–∞'],
        ['üìÖ –ù–µ–¥–µ–ª—è', 'üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ'],
        ['üîô –ù–∞–∑–∞–¥']
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è:", reply_markup=reply_markup)
    print(f"–õ–û–ì: –ü–æ–∫–∞–∑–∞–Ω –≤—ã–±–æ—Ä –ø–µ—Ä–∏–æ–¥–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}.")

async def handle_schedule_period(update: Update, context: ContextTypes.DEFAULT_TYPE, group_name: str):
    """Handles the schedule period selection"""
    text = update.message.text
    print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–ø—Ä–æ—Å–∏–ª —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ø–µ—Ä–∏–æ–¥–∞ '{text}'.")
    
    await update.message.reply_text("‚è≥ –ó–∞–≥—Ä—É–∂–∞—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ...", reply_markup=ReplyKeyboardRemove())
    schedule = get_schedule(text, group_name)
    await update.message.reply_text(schedule, parse_mode='HTML')
    await show_main_menu(update, update.effective_user.id)

# -------------------- DATABASE INTERACTION FUNCTIONS --------------------

def add_homework(subject, task, deadline, group_name, added_by, file_ids=None):
    """Adds homework to the database"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO homeworks (subject, task, deadline, group_name, added_by, file_ids)
                     VALUES (?, ?, ?, ?, ?, ?)''', (subject, task, deadline, group_name, added_by, json.dumps(file_ids)))
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ –î–ó –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –î–ó: {e}")
    finally:
        conn.close()

def get_homeworks(group_name):
    """Gets homework for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        homeworks = conn.execute('''SELECT h.*, u.first_name 
                                 FROM homeworks h JOIN users u ON h.added_by = u.user_id 
                                 WHERE h.group_name = ? ORDER BY h.created_at DESC''', (group_name,)).fetchall()
        return homeworks
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –î–ó: {e}")
        return []
    finally:
        conn.close()

def add_notification(message, group_name, added_by, file_ids=None):
    """Adds a notification to the database"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO notifications (message, group_name, added_by, file_ids)
                     VALUES (?, ?, ?, ?)''', (message, group_name, added_by, json.dumps(file_ids)))
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def get_notifications(group_name):
    """Gets notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT n.*, u.first_name 
                                     FROM notifications n JOIN users u ON n.added_by = u.user_id 
                                     WHERE n.group_name = ? ORDER BY n.created_at DESC''', (group_name,)).fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_sport_notification(message, group_name, added_by, file_ids=None):
    """Adds a sport notification to the database"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO sport_notifications (message, group_name, added_by, file_ids)
                     VALUES (?, ?, ?, ?)''', (message, group_name, added_by, json.dumps(file_ids)))
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def get_sport_notifications(group_name):
    """Gets sport notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     WHERE s.group_name = ? ORDER BY s.created_at DESC''', (group_name,)).fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_suggestion(user_id, message, file_ids=None):
    """Adds a suggestion to the database"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('INSERT INTO suggestions (user_id, message, file_ids) VALUES (?, ?, ?)', (user_id, message, json.dumps(file_ids)))
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –æ—Ç–ø—Ä–∞–≤–∏–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def get_suggestions():
    """Gets all suggestions"""
    conn = get_db_connection()
    if not conn: return []
    try:
        suggestions = conn.execute('''SELECT s.*, u.first_name, u.username, u.group_name
                                   FROM suggestions s JOIN users u ON s.user_id = u.user_id 
                                   ORDER BY s.created_at DESC''').fetchall()
        return suggestions
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def get_suggestion_by_id(suggestion_id):
    conn = get_db_connection()
    if not conn: return None
    try:
        suggestion = conn.execute('SELECT * FROM suggestions WHERE id = ?', (suggestion_id,)).fetchone()
        return suggestion
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_poll(question, options, creator_id):
    conn = get_db_connection()
    if not conn: return None
    try:
        cur = conn.cursor()
        cur.execute('INSERT INTO polls (question, options, creator_id) VALUES (?, ?, ?)', (question, json.dumps(options), creator_id))
        conn.commit()
        return cur.lastrowid
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –æ–ø—Ä–æ—Å–∞: {e}")
        return None
    finally:
        conn.close()

def get_latest_poll():
    conn = get_db_connection()
    if not conn: return None
    try:
        poll = conn.execute('SELECT * FROM polls ORDER BY created_at DESC LIMIT 1').fetchone()
        return poll
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–ø—Ä–æ—Å–∞: {e}")
        return None
    finally:
        conn.close()

def record_vote(poll_id, user_id, vote_option):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT OR REPLACE INTO poll_votes (poll_id, user_id, vote_option) VALUES (?, ?, ?)''', (poll_id, user_id, vote_option))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≥–æ–ª–æ—Å–∞: {e}")
    finally:
        conn.close()

def get_poll_results(poll_id):
    conn = get_db_connection()
    if not conn: return {}
    try:
        results = conn.execute('SELECT vote_option, COUNT(*) as count FROM poll_votes WHERE poll_id = ? GROUP BY vote_option', (poll_id,)).fetchall()
        return {row['vote_option']: row['count'] for row in results}
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ–ø—Ä–æ—Å–∞: {e}")
        return {}
    finally:
        conn.close()

# -------------------- MESSAGE SENDING (DIALOG) FUNCTIONS --------------------

async def ask_homework_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for homework details to send"""
    await update.message.reply_text(
        "üìù <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –î–ó</b>\n\n"
        "–ù–∞–ø–∏—à–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "<b>–ü—Ä–µ–¥–º–µ—Ç</b>\n"
        "<b>–ó–∞–¥–∞–Ω–∏–µ</b>\n"
        "<b>–°—Ä–æ–∫ —Å–¥–∞—á–∏</b>\n\n"
        "–ü—Ä–∏–º–µ—Ä:\n"
        "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞\n"
        "–†–µ—à–∏—Ç—å –∑–∞–¥–∞—á–∏ 1-10 –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 45\n"
        "–î–æ 15.09\n\n"
        "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
    )
    print(f"–õ–û–ì: –ó–∞–ø—Ä–æ—à–µ–Ω –≤–≤–æ–¥ –î–ó –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.effective_user.id}.")
    return AWAITING_HOMEWORK

async def ask_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for information to send to everyone"""
    await update.message.reply_text(
        "üì¢ <b>–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º</b>\n\n"
        "–ù–∞–ø–∏—à–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º —É—á–µ–Ω–∏–∫–∞–º.\n"
        "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é:",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
    )
    print(f"–õ–û–ì: –ó–∞–ø—Ä–æ—à–µ–Ω –≤–≤–æ–¥ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.effective_user.id}.")
    return AWAITING_INFO

async def ask_sport_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a sport notification to send"""
    await update.message.reply_text(
        "üèÉ <b>–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è</b>\n\n"
        "–ù–∞–ø–∏—à–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º —É—á–µ–Ω–∏–∫–∞–º.\n"
        "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é:",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
    )
    print(f"–õ–û–ì: –ó–∞–ø—Ä–æ—à–µ–Ω –≤–≤–æ–¥ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.effective_user.id}.")
    return AWAITING_SPORT

async def ask_suggestion_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a suggestion to improve the bot"""
    await update.message.reply_text(
        "üí° <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –±–æ—Ç–∞</b>\n\n"
        "–ù–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –±–æ—Ç–∞:\n\n"
        "–ß—Ç–æ –±—ã —Ç—ã —Ö–æ—Ç–µ–ª –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å?\n\n"
        "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
    )
    print(f"–õ–û–ì: –ó–∞–ø—Ä–æ—à–µ–Ω –≤–≤–æ–¥ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.effective_user.id}.")
    return AWAITING_SUGGESTION

# --- UPDATED MESSAGE HANDLING FUNCTIONS IN DIALOGS ---

async def handle_homework_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if user_id not in [uid for uid in SPECIAL_USERS if SPECIAL_USERS[uid]['role'] in [ROLE_IT_SPECIALIST, ROLE_DEVELOPER]]:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return await cancel_conversation(update, context)

    if update.message.media_group_id:
        if update.message.media_group_id not in multi_photo_state:
            multi_photo_state[update.message.media_group_id] = {'files': [], 'caption': None}
        
        if update.message.photo:
            multi_photo_state[update.message.media_group_id]['files'].append(('photo', update.message.photo[-1].file_id))
        elif update.message.video:
            multi_photo_state[update.message.media_group_id]['files'].append(('video', update.message.video.file_id))

        if update.message.caption:
            multi_photo_state[update.message.media_group_id]['caption'] = update.message.caption
        
        await update.message.reply_text("–ü–æ–ª—É—á–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤—Å–µ —Ñ–∞–π–ª—ã, –∞ –ø–æ—Ç–æ–º —è –æ–±—Ä–∞–±–æ—Ç–∞—é –∏—Ö –∫–∞–∫ –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.", reply_markup=ReplyKeyboardRemove())
        return AWAITING_HOMEWORK

    text = update.message.caption if update.message.caption else update.message.text
    file_ids = []
    if update.message.photo:
        file_ids.append(('photo', update.message.photo[-1].file_id))
    elif update.message.video:
        file_ids.append(('video', update.message.video.file_id))
        
    if text == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)

    if not text:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ –î–ó.")
        return AWAITING_HOMEWORK

    lines = text.strip().split('\n')
    if len(lines) >= 3:
        subject = lines[0].strip()
        task = lines[1].strip()
        deadline = lines[2].strip()
        
        add_homework(subject, task, deadline, user_data['group_name'], user_id, [fid[1] for fid in file_ids])
        await update.message.reply_text("‚úÖ –î–ó –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
        await send_homework_to_all(context.bot, subject, task, deadline, user_data['group_name'], user_id, file_ids)
        print(f"–õ–û–ì: –î–ó –¥–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {user_id} –¥–ª—è –≥—Ä—É–ø–ø—ã {user_data['group_name']}.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    else:
        await update.message.reply_text("‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ù—É–∂–Ω–æ 3 —Å—Ç—Ä–æ–∫–∏: –ø—Ä–µ–¥–º–µ—Ç, –∑–∞–¥–∞–Ω–∏–µ, —Å—Ä–æ–∫")
        return AWAITING_HOMEWORK

async def handle_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if user_id not in [uid for uid in SPECIAL_USERS if SPECIAL_USERS[uid]['role'] in [ROLE_IT_SPECIALIST, ROLE_DEVELOPER]]:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return await cancel_conversation(update, context)

    group_name = user_data['group_name']
    file_ids = []
    if update.message.photo:
        file_ids.append(('photo', update.message.photo[-1].file_id))
    if update.message.video:
        file_ids.append(('video', update.message.video.file_id))
        
    message_text = update.message.caption if update.message.caption else update.message.text

    if message_text == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)

    if not message_text:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        return AWAITING_INFO

    add_notification(message_text, group_name, user_id, [fid[1] for fid in file_ids])
    await update.message.reply_text("‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
    await send_notification_to_all(context.bot, message_text, group_name, user_id, file_ids)
    print(f"–õ–û–ì: –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {user_id} –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def handle_sport_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if user_id not in [uid for uid in SPECIAL_USERS if SPECIAL_USERS[uid]['role'] in [ROLE_PHYSICAL_ORGANIZER, ROLE_DEVELOPER]]:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return await cancel_conversation(update, context)

    group_name = user_data['group_name']
    file_ids = []
    if update.message.photo:
        file_ids.append(('photo', update.message.photo[-1].file_id))
    if update.message.video:
        file_ids.append(('video', update.message.video.file_id))

    message_text = update.message.caption if update.message.caption else update.message.text

    if message_text == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)

    if not message_text:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        return AWAITING_SPORT
    
    add_sport_notification(message_text, group_name, user_id, [fid[1] for fid in file_ids])
    await update.message.reply_text("‚úÖ –°–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
    await send_sport_notification_to_all(context.bot, message_text, group_name, user_id, file_ids)
    print(f"–õ–û–ì: –°–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {user_id} –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def handle_suggestion_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    text = update.message.text
    file_ids = []
    if update.message.photo:
        file_ids.append(('photo', update.message.photo[-1].file_id))
    if update.message.video:
        file_ids.append(('video', update.message.video.file_id))

    if text == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)
    
    if not text:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
        return AWAITING_SUGGESTION

    add_suggestion(user_id, text, [fid[1] for fid in file_ids])
    
    for special_id in SPECIAL_USERS:
        try:
            await context.bot.send_message(
                special_id,
                f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{text}"
            )
        except Exception as e:
            print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {special_id}: {e}")
    
    await update.message.reply_text("‚úÖ –°–ø–∞—Å–∏–±–æ –∑–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ! –ú—ã –µ–≥–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º.", reply_markup=ReplyKeyboardRemove())
    await show_main_menu(update, user_id)
    print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –æ—Ç–ø—Ä–∞–≤–∏–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
    return ConversationHandler.END

async def handle_suggestion_reply(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in [uid for uid in SPECIAL_USERS]:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è.")
        return ConversationHandler.END

    text = update.message.text
    if text == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)
    
    original_user_id = context.user_data.get('suggestion_user_id')
    if not original_user_id:
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∞–≤—Ç–æ—Ä–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è.")
        return await cancel_conversation(update, context)

    try:
        await context.bot.send_message(
            original_user_id,
            f"üì® **–û—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:**\n\n{text}",
            parse_mode='Markdown'
        )
        await update.message.reply_text("‚úÖ –í–∞—à –æ—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.", reply_markup=ReplyKeyboardRemove())
    except Exception as e:
        await update.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç: {e}", reply_markup=ReplyKeyboardRemove())

    await show_main_menu(update, user_id)
    return ConversationHandler.END

# --- POLL FUNCTIONS ---

async def ask_poll_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    if not user_data or user_data['role'] not in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER, ROLE_DEVELOPER]:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–ø—Ä–æ—Å–æ–≤.")
        return ConversationHandler.END
    
    await update.message.reply_text("‚úçÔ∏è –ù–∞–ø–∏—à–∏—Ç–µ –≤–æ–ø—Ä–æ—Å –¥–ª—è –æ–ø—Ä–æ—Å–∞:", reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True))
    return AWAITING_POLL_QUESTION

async def handle_poll_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    question = update.message.text
    context.user_data['poll_question'] = question
    await update.message.reply_text("üìù –¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤, –∫–∞–∂–¥—ã–π —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏ (–æ—Ç 2 –¥–æ 10 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤):", reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True))
    return AWAITING_POLL_OPTIONS

async def handle_poll_options(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    question = context.user_data.get('poll_question')
    options = [opt.strip() for opt in update.message.text.split('\n') if opt.strip()]

    if not (2 <= len(options) <= 10):
        await update.message.reply_text("‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 2 –¥–æ 10. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
        return AWAITING_POLL_OPTIONS

    poll_id = add_poll(question, options, user_id)
    if not poll_id:
        await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return await cancel_conversation(update, context)

    poll_text = f"üìä **–ù–û–í–´–ô –û–ü–†–û–°**\n\n**{question}**\n\n"
    keyboard = [[InlineKeyboardButton(option, callback_data=f"poll_{poll_id}_{i}")] for i, option in enumerate(options)]
    reply_markup = InlineKeyboardMarkup(keyboard)

    users = get_all_users()
    for user in users:
        try:
            await context.bot.send_message(user['user_id'], poll_text, reply_markup=reply_markup, parse_mode='Markdown')
        except Exception as e:
            print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")
    
    await update.message.reply_text("‚úÖ –û–ø—Ä–æ—Å —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º!", reply_markup=ReplyKeyboardRemove())
    return await show_main_menu(update, user_id)

async def handle_poll_vote_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    _, poll_id, option_index = query.data.split('_')
    poll_id = int(poll_id)
    option_index = int(option_index)

    conn = get_db_connection()
    poll = conn.execute('SELECT * FROM polls WHERE id = ?', (poll_id,)).fetchone()
    conn.close()

    if not poll:
        await query.edit_message_text("‚ùå –≠—Ç–æ—Ç –æ–ø—Ä–æ—Å –±–æ–ª—å—à–µ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω.")
        return

    options = json.loads(poll['options'])
    vote_option = options[option_index]
    
    record_vote(poll_id, user_id, vote_option)
    
    await query.edit_message_text(f"‚úÖ –í—ã –ø—Ä–æ–≥–æ–ª–æ—Å–æ–≤–∞–ª–∏ –∑–∞: **{vote_option}**", parse_mode='Markdown')

async def show_poll_results(update: Update, context: ContextTypes.DEFAULT_TYPE):
    latest_poll = get_latest_poll()
    if not latest_poll:
        await update.message.reply_text("‚ùå –ü–æ–∫–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø—Ä–æ—Å–æ–≤.")
        return
    
    poll_id = latest_poll['id']
    question = latest_poll['question']
    options = json.loads(latest_poll['options'])
    results = get_poll_results(poll_id)
    
    total_votes = sum(results.values())
    
    results_text = f"üìä **–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–ø—Ä–æ—Å–∞:**\n\n**{question}**\n\n"
    
    for option in options:
        count = results.get(option, 0)
        percentage = (count / total_votes) * 100 if total_votes > 0 else 0
        results_text += f"**{option}**: {count} –≥–æ–ª–æ—Å–æ–≤ ({percentage:.1f}%)\n"
    
    await update.message.reply_text(results_text, parse_mode='Markdown')

# -------------------- NOTIFICATION SENDING LOGIC --------------------

async def send_homework_to_all(bot, subject, task, deadline, group_name, added_by, file_ids=None):
    """Sends homework to all users in a group"""
    homework_text = (
        f"üìù <b>–ù–û–í–û–ï –î–û–ú–ê–®–ù–ï–ï –ó–ê–î–ê–ù–ò–ï</b>\n\n"
        f"üìö <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {subject}\n"
        f"üìã <b>–ó–∞–¥–∞–Ω–∏–µ:</b> {task}\n"
        f"‚è∞ <b>–°—Ä–æ–∫ —Å–¥–∞—á–∏:</b> {deadline}\n"
        f"üë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}\n"
    )
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    media = []
    if file_ids:
        for file_id in file_ids:
            if 'photo' in file_id:
                media.append(InputMediaPhoto(media=file_id['photo']))
            elif 'video' in file_id:
                media.append(InputMediaVideo(media=file_id['video']))
    
    for user in users:
        try:
            if media:
                media[0].caption = homework_text
                await bot.send_media_group(chat_id=user['user_id'], media=media)
            else:
                await bot.send_message(user['user_id'], homework_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_notification_to_all(bot, message, group_name, added_by, file_ids=None):
    """Sends a notification to all users in a group"""
    notification_text = (f"üì¢ <b>–í–ê–ñ–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n{message}\n\nüë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}")
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()

    media = []
    if file_ids:
        for file_id in file_ids:
            if 'photo' in file_id:
                media.append(InputMediaPhoto(media=file_id['photo']))
            elif 'video' in file_id:
                media.append(InputMediaVideo(media=file_id['video']))
    
    for user in users:
        try:
            if media:
                media[0].caption = notification_text
                await bot.send_media_group(chat_id=user['user_id'], media=media)
            else:
                await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_sport_notification_to_all(bot, message, group_name, added_by, file_ids=None):
    """Sends a sport notification to all users in a group"""
    sport_text = (f"üèÉ <b>–°–ü–û–†–¢–ò–í–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n{message}\n\nüë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}")
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()

    media = []
    if file_ids:
        for file_id in file_ids:
            if 'photo' in file_id:
                media.append(InputMediaPhoto(media=file_id['photo']))
            elif 'video' in file_id:
                media.append(InputMediaVideo(media=file_id['video']))

    for user in users:
        try:
            if media:
                media[0].caption = sport_text
                await bot.send_media_group(chat_id=user['user_id'], media=media)
            else:
                await bot.send_message(user['user_id'], sport_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

# -------------------- INFO DISPLAY FUNCTIONS --------------------

async def show_homework(update: Update, group_name: str):
    """Shows all homework for a group"""
    homeworks = get_homeworks(group_name)
    if not homeworks:
        await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π")
        return
    
    for hw in homeworks:
        hw_text = (
            f"üìù <b>–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ</b>\n"
            f"üìö <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {hw['subject']}\n"
            f"üìã <b>–ó–∞–¥–∞–Ω–∏–µ:</b> {hw['task']}\n"
            f"‚è∞ <b>–°—Ä–æ–∫:</b> {hw['deadline']}\n"
            f"üë§ <b>–î–æ–±–∞–≤–∏–ª:</b> {hw['first_name']}\n"
            f"üìÖ <b>–î–∞—Ç–∞:</b> {datetime.fromisoformat(hw['created_at']).strftime('%d.%m.%Y %H:%M')}"
        )
        file_ids = json.loads(hw['file_ids']) if hw['file_ids'] else []
        if file_ids:
            await update.message.reply_photo(photo=file_ids[0], caption=hw_text, parse_mode='HTML')
            if len(file_ids) > 1:
                media = [InputMediaPhoto(media=fid) for fid in file_ids[1:]]
                await update.message.reply_media_group(media=media)
        else:
            await update.message.reply_text(hw_text, parse_mode='HTML')
    
    await update.message.reply_text(f"üìä <b>–ü–æ–∫–∞–∑–∞–Ω–æ:</b> {len(homeworks)} –∑–∞–¥–∞–Ω–∏–π", parse_mode='HTML')

async def show_information(update: Update, group_name: str, role: str):
    """Shows information for the user"""
    user_count = get_total_user_count()
    info_text = f"üìä <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –±–æ—Ç–µ:</b> {user_count}\n\n<b>–ö–æ–Ω—Ç–∞–∫—Ç—ã:</b>\n"
    for data in SPECIAL_USERS.values():
        info_text += f"- <b>{data['name']}</b>: {data['username']}\n"
    await update.message.reply_text(info_text, parse_mode='HTML')

    notifications = get_notifications(group_name)
    sport_notifications = get_sport_notifications(group_name)
    if not notifications and not sport_notifications:
        await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")
        return
    
    if notifications:
        await update.message.reply_text("üì¢ <b>–í–∞–∂–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:</b>", parse_mode='HTML')
        for notif in notifications[:2]:
            notif_text = f"{notif['message']}\n\nüë§ <b>–û—Ç:</b> {notif['first_name']} | üìÖ {datetime.fromisoformat(notif['created_at']).strftime('%d.%m.%Y')}"
            file_ids = json.loads(notif['file_ids']) if notif['file_ids'] else []
            if file_ids:
                await update.message.reply_photo(photo=file_ids[0], caption=notif_text)
            else:
                await update.message.reply_text(notif_text)
    
    if sport_notifications:
        await update.message.reply_text("üèÉ <b>–°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:</b>", parse_mode='HTML')
        for sport in sport_notifications[:2]:
            sport_text = f"{sport['message']}\n\nüë§ <b>–û—Ç:</b> {sport['first_name']} | üìÖ {datetime.fromisoformat(sport['created_at']).strftime('%d.%m.%Y')}"
            file_ids = json.loads(sport['file_ids']) if sport['file_ids'] else []
            if file_ids:
                await update.message.reply_photo(photo=file_ids[0], caption=sport_text)
            else:
                await update.message.reply_text(sport_text)

async def show_suggestions(update: Update):
    """Shows suggestions from students"""
    suggestions = get_suggestions()
    if not suggestions:
        await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –æ—Ç —É—á–µ–Ω–∏–∫–æ–≤")
        return
    
    for s in suggestions[:5]:
        username = f"@{s['username']}" if s['username'] else s['first_name']
        suggestion_text = (
            f"üí° **–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {s['first_name']} ({s['group_name']})**\n\n"
            f"**{s['message']}**\n\n"
            f"**–Æ–∑–µ—Ä:** {username}\n"
            f"**–î–∞—Ç–∞:** {datetime.fromisoformat(s['created_at']).strftime('%d.%m.%Y')}"
        )
        
        file_ids = json.loads(s['file_ids']) if s['file_ids'] else []
        keyboard = [[InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"reply_sugg_{s['id']}")]]
        
        if file_ids:
            media = []
            for file_id in file_ids:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ñ–∞–π–ª–∞ –ø–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é –∏–ª–∏ –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
                if file_id.endswith('.mp4') or 'video' in file_id:
                    media.append(InputMediaVideo(media=file_id))
                else:
                    media.append(InputMediaPhoto(media=file_id))
            
            # –ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –º–µ–¥–∏–∞-–≥—Ä—É–ø–ø—ã –±—É–¥–µ—Ç —Å –ø–æ–¥–ø–∏—Å—å—é
            media[0].caption = suggestion_text
            
            await update.message.reply_media_group(media=media)
            await update.message.reply_text("–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –æ—Ç–≤–µ—Ç–∏—Ç—å:", reply_markup=InlineKeyboardMarkup(keyboard))
        else:
            await update.message.reply_text(suggestion_text, parse_mode='Markdown', reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_reply_suggestion_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    suggestion_id = int(query.data.split('_')[2])
    suggestion = get_suggestion_by_id(suggestion_id)
    if not suggestion:
        await query.edit_message_text("‚ùå –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return

    context.user_data['suggestion_user_id'] = suggestion['user_id']
    await context.bot.send_message(
        query.from_user.id,
        "–ù–∞–ø–∏—à–∏—Ç–µ —Å–≤–æ–π –æ—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:",
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
    )
    return AWAITING_SUGGESTION_REPLY

async def show_users_list(update: Update):
    """Shows a list of all users for the developer"""
    users = get_all_users()
    if not users:
        await update.message.reply_text("‚ùå –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
        return
    
    user_list_text = "üë• **–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π**\n\n"
    
    for user in users:
        username = user['username'] if user['username'] else "–ù–µ—Ç —é–∑–µ—Ä–Ω–µ–π–º–∞"
        user_list_text += (
            f"**–ò–º—è:** {user['first_name']}\n"
            f"**–ì—Ä—É–ø–ø–∞:** {user['group_name']}\n"
            f"**–Æ–∑–µ—Ä:** @{username}\n"
            f"**ID:** `{user['user_id']}`\n\n"
        )
    
    await update.message.reply_text(user_list_text, parse_mode='Markdown')

async def show_call_schedule(update: Update):
    """Shows the call schedule (–∑–≤–æ–Ω–∫–∏) based on day of week"""
    now = datetime.now(YEKATERINBURG_TZ)
    day_of_week = now.weekday()
    
    if day_of_week == 5:  # Saturday
        schedule_text = (
            "üîî **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ –Ω–∞ —Å—É–±–±–æ—Ç—É**\n\n"
            "1 –ø–∞—Ä–∞: **8:30 - 9:45**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "2 –ø–∞—Ä–∞: **9:55 - 11:10**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "3 –ø–∞—Ä–∞: **11:20 - 12:40**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 40 –º–∏–Ω—É—Ç - –û–ë–ï–î\n"
            "4 –ø–∞—Ä–∞: **13:20 - 14:35**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "5 –ø–∞—Ä–∞: **14:45 - 16:00**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "6 –ø–∞—Ä–∞: **16:10 - 17:25**\n"
        )
    else:
        schedule_text = (
            "üîî **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ (–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫-–ø—è—Ç–Ω–∏—Ü–∞)**\n\n"
            "1 –ø–∞—Ä–∞: **8:30 - 10:05**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "2 –ø–∞—Ä–∞: **10:15 - 11:50**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "3 –ø–∞—Ä–∞: **12:40 - 14:15**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 40 –º–∏–Ω—É—Ç - –û–ë–ï–î\n"
            "4 –ø–∞—Ä–∞: **14:25 - 16:00**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "5 –ø–∞—Ä–∞: **16:10 - 17:45**\n"
            "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
            "6 –ø–∞—Ä–∞: **17:55 - 19:30**\n"
        )
    
    await update.message.reply_text(schedule_text, parse_mode='Markdown')

async def contact_physical_organizer(update: Update):
    """Contact the physical organizer"""
    username = next((data['username'] for data in SPECIAL_USERS.values() if data['role'] == ROLE_PHYSICAL_ORGANIZER), None)
    if username:
        await update.message.reply_text(f"üèÉ <b>–°–≤—è–∑—å —Å –§–∏–∑. –æ—Ä–≥–æ–º</b>\n\nüìû Telegram: {username}", parse_mode='HTML')
    else:
        await update.message.reply_text("‚ùå –§–∏–∑. –æ—Ä–≥. –Ω–µ –Ω–∞–π–¥–µ–Ω")

async def contact_starosta(update: Update):
    """Contact the —Å—Ç–∞—Ä–æ—Å—Ç–∞"""
    username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == '–°—Ç–∞—Ä–æ—Å—Ç–∞'), None)
    if username:
        await update.message.reply_text(f"üëë <b>–°–≤—è–∑—å —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π</b>\n\nüìû Telegram: {username}", parse_mode='HTML')
    else:
        await update.message.reply_text("‚ùå –°—Ç–∞—Ä–æ—Å—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω")

async def contact_deputy_starosta(update: Update):
    """Contact the –∑–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã"""
    username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == '–ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã'), None)
    if username:
        await update.message.reply_text(f"üëë <b>–°–≤—è–∑—å —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã (—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º)</b>\n\nüìû Telegram: {username}", parse_mode='HTML')
    else:
        await update.message.reply_text("‚ùå –ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω")

# -------------------- DELETION FUNCTIONS --------------------

async def delete_homework_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    if user_id != DEVELOPER_ID and (not user_data or user_data['role'] != ROLE_IT_SPECIALIST):
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return ConversationHandler.END
        
    homeworks = get_homeworks(user_data['group_name'])
    if not homeworks:
        await update.message.reply_text("üìù –ù–µ—Ç –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return ConversationHandler.END
    
    keyboard = [[InlineKeyboardButton(f"‚ùå {hw['subject']} | {hw['deadline']}", callback_data=f"del_hw_{hw['id']}")] for hw in homeworks[:5]]
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –î–ó –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_HOMEWORK_DELETE

async def delete_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    if user_id != DEVELOPER_ID and (not user_data or user_data['role'] != ROLE_IT_SPECIALIST):
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return ConversationHandler.END
        
    user_data = get_user(user_id)
    notifications = get_notifications(user_data['group_name'])
    
    if not notifications:
        await update.message.reply_text("üì¢ –ù–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return ConversationHandler.END

    keyboard = []
    for n in notifications[:5]:
        button_text = f"üì¢ {n['message'][:20]}..."
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_notif_{n['id']}")])

    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_INFO_DELETE

async def delete_sport_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    if user_id != DEVELOPER_ID and (not user_data or user_data['role'] != ROLE_PHYSICAL_ORGANIZER):
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return ConversationHandler.END
        
    if user_id == DEVELOPER_ID:
        sport_notifications = get_all_sport_notifications()
    else:
        sport_notifications = get_sport_notifications(user_data['group_name'])

    if not sport_notifications:
        await update.message.reply_text("üèÉ –ù–µ—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return ConversationHandler.END

    keyboard = []
    for sport in sport_notifications[:10]:
        button_text = f"üèÉ {sport['message'][:20]}..."
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{sport['id']}")])

    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_SPORT_DELETE

async def delete_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return ConversationHandler.END
        
    users = [u for u in get_all_users() if u['user_id'] not in SPECIAL_USERS]
    if not users:
        await update.message.reply_text("üë• –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return ConversationHandler.END
        
    keyboard = [[InlineKeyboardButton(f"‚ùå {u['first_name']} (@{u['username']}) - –ì—Ä—É–ø–ø–∞: {u['group_name']} - ID: {u['user_id']}", callback_data=f"del_user_{u['user_id']}")] for u in users]
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_USER_DELETE

async def delete_suggestions_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    if user_id != DEVELOPER_ID and (not user_data or user_data['role'] not in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER]):
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return ConversationHandler.END
        
    suggestions = get_suggestions()
    if not suggestions:
        await update.message.reply_text("üí° –ù–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return ConversationHandler.END
    
    keyboard = [[InlineKeyboardButton(f"‚ùå {s['message'][:20]}...", callback_data=f"del_sugg_{s['id']}")] for s in suggestions[:5]]
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_SUGGESTION_DELETE

async def handle_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    parts = query.data.split('_')
    data_type = parts[1]
    item_id = int(parts[2])
    
    message = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞."
    try:
        if data_type == 'hw':
            delete_homework(item_id)
            message = "‚úÖ –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
        elif data_type == 'notif':
            delete_notification(item_id)
            message = "‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
        elif data_type == 'sport':
            delete_sport_notification(item_id)
            message = "‚úÖ –°–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
        elif data_type == 'user':
            delete_user(item_id)
            message = "‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω."
        elif data_type == 'sugg':
            delete_suggestion(item_id)
            message = "‚úÖ –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
        
        await query.edit_message_text(text=message)
    except Exception as e:
        await query.edit_message_text(text=f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: {e}")
    
    await show_main_menu(update, query.from_user.id)
    return ConversationHandler.END

# -------------------- ROLE FIX FUNCTION --------------------

async def handle_role_fix_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the role fix callback"""
    query = update.callback_query
    await query.answer()
    
    parts = query.data.split('_')
    user_id = int(parts[2])
    
    if query.from_user.id != user_id:
        await query.edit_message_text("‚ùå –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ä–æ–ª—å –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
        return
    
    user = query.from_user
    add_user(user_id, user.username, user.first_name, user.last_name)
    
    await query.edit_message_text("‚úÖ –í–∞—à–∞ —Ä–æ–ª—å –±—ã–ª–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞! –¢–µ–ø–µ—Ä—å —É –≤–∞—Å –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤—Å–µ –ø—Ä–∞–≤–∞.")
    await show_main_menu(update, user_id)

# -------------------- JOB QUEUE FUNCTIONS --------------------

async def init_schedule_cache(application):
    """Initializes the schedule cache"""
    global schedule_cache, last_schedule_check
    schedule_data = fetch_schedule_data()
    if schedule_data:
        schedule_cache = schedule_data
        last_schedule_check = datetime.now(YEKATERINBURG_TZ)
        print("–õ–û–ì: –ö—ç—à —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

# -------------------- MAIN FUNCTION --------------------

def main():
    """Main function to run the bot"""
    init_db()
    
    app = Application.builder().token(BOT_TOKEN).post_init(init_schedule_cache).build()
    
    job_queue = app.job_queue
    job_queue.run_repeating(check_schedule_changes, interval=3600, first=10)
    job_queue.run_daily(send_daily_schedule, time=time(hour=19, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
    job_queue.run_daily(send_morning_schedule, time=time(hour=7, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
    job_queue.run_repeating(check_next_lesson, interval=60, first=10)
    
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('start', start_command),
            MessageHandler(filters.Regex('^üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó$'), ask_homework_details),
            MessageHandler(filters.Regex('^üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), ask_notification_details),
            MessageHandler(filters.Regex('^üèÉ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), ask_sport_notification_details),
            MessageHandler(filters.Regex('^üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é$'), ask_suggestion_details),
            MessageHandler(filters.Regex('^–£–¥–∞–ª–µ–Ω–∏–µ$'), show_deletion_menu),
            MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –î–ó$'), delete_homework_menu),
            MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), delete_notification_menu),
            MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è$'), delete_sport_notification_menu),
            MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è$'), delete_suggestions_menu),
            MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è$'), delete_user_menu),
            MessageHandler(filters.Regex('^üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É$'), ask_user_group),
            MessageHandler(filters.Regex('^üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å$'), ask_poll_question),
        ],
        states={
            AWAITING_GROUP: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_group_selection)],
            AWAITING_HOMEWORK: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO, handle_homework_input)],
            AWAITING_INFO: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO, handle_notification_input)],
            AWAITING_SPORT: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO, handle_sport_input)],
            AWAITING_SUGGESTION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO, handle_suggestion_input)],
            AWAITING_POLL_QUESTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_poll_question)],
            AWAITING_POLL_OPTIONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_poll_options)],
            AWAITING_SUGGESTION_REPLY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_suggestion_reply)],
            AWAITING_HOMEWORK_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_hw_')],
            AWAITING_INFO_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_notif_')],
            AWAITING_SPORT_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sport_')],
            AWAITING_USER_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_user_')],
            AWAITING_SUGGESTION_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sugg_')]
        },
        fallbacks=[
            CommandHandler('start', start_command),
            MessageHandler(filters.Regex('^‚ùå –û—Ç–º–µ–Ω–∞$'), cancel_conversation)
        ],
        allow_reentry=True
    )
    
    app.add_handler(conv_handler)
    app.add_handler(CallbackQueryHandler(handle_role_fix_callback, pattern='^fix_role_'))
    app.add_handler(CallbackQueryHandler(handle_reply_suggestion_callback, pattern='^reply_sugg_'))
    app.add_handler(CallbackQueryHandler(handle_poll_vote_callback, pattern='^poll_'))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_simple_message))
    
    print("–õ–û–ì: –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    app.run_polling()

if __name__ == "__main__":
    main()
