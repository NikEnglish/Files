import sqlite3
import re
import json
import asyncio
import requests
import os
import collections
from datetime import datetime, timedelta, timezone, time
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler, PollHandler, PollAnswerHandler

# -------------------- CONSTANTS AND SETTINGS --------------------
BOT_TOKEN = "YOUR_TOKEN" # ЗАМЕНИ НА СВОЙ ТОКЕН
YEKATERINBURG_TZ = timezone(timedelta(hours=5))
DEFAULT_GROUP = "ИД-127"

# States for ConversationHandler
(AWAITING_HOMEWORK, AWAITING_INFO, AWAITING_SPORT, AWAITING_SUGGESTION, AWAITING_HOMEWORK_DELETE, 
 AWAITING_INFO_DELETE, AWAITING_SPORT_DELETE, AWAITING_USER_DELETE, AWAITING_SUGGESTION_DELETE, 
 AWAITING_GROUP, AWAITING_POLL_QUESTION, AWAITING_POLL_OPTIONS, 
 AWAITING_SUGGESTION_REPLY, AWAITING_DELETE_MENU) = range(14)

# User Roles
ROLE_STUDENT = 'student'
ROLE_PHYSICAL_ORGANIZER = 'physical_organizer'
ROLE_IT_SPECIALIST = 'it_specialist'

# Special Users (ID and username)
DEVELOPER_ID = 1775957387
SPECIAL_USERS = {
    5013216284: {'role': ROLE_IT_SPECIALIST, 'username': '@kimertuzz3', 'name': 'Староста'},
    DEVELOPER_ID: {'role': ROLE_IT_SPECIALIST, 'username': '@imya_polbzovatela', 'name': 'Зам Старосты'},
    5078637058: {'role': ROLE_PHYSICAL_ORGANIZER, 'username': '@NateDiazFight', 'name': 'Физ. орг.'}
}

# Full list of groups
ALL_GROUPS = [
    "ИД-126", "ИД-127", "МД-1126", "МД-1127", "МД-1128", "ОДЛД-107", "ОДЛД-108",
    "ПСД-144", "ПСД-145", "ТД-1128", "ТД-1129", "ТД-1130", "ТМД-123", "ТМД-124", "ТМД-125",
    "ЭД-1111", "ЭД-1112", "ЭД-1113", "ИД-224", "ИД-225", "МД-2123", "МД-2124", "МД-2125",
    "ОдЛД-205", "ОдЛД-206", "ПСД-242", "ПСД-243", "ТД-2125", "ТД-2126", "ТД-2127", "ТМД-220",
    "ТМД-221", "ТМД-222", "ЭД-2108", "ЭД-2109", "ЭД-2110", "ИД-323", "МД-3121", "МД-3122",
    "ОСАД-302", "ОдЛД-303", "ОдЛД-304", "ПСД-340", "ПСД-341", "ТД-3121", "ТД-3123", "ТМД-317",
    "ТМД-318", "ЭД-3106", "ЭД-3107", "ИД-421", "ИД-422"
]

# Schedule cache
schedule_cache = {}
last_schedule_check = None

# User notifications cache to prevent duplicate messages
user_notification_cache = {}
active_polls = {} # To track poll IDs and their original creators

# Spam protection
user_message_counts = collections.defaultdict(lambda: {'count': 0, 'time': None})
user_bans = collections.defaultdict(lambda: {'end_time': None, 'duration': 10}) # duration in minutes

# -------------------- DATABASE FUNCTIONS --------------------

def init_db():
    conn = None
    try:
        conn = sqlite3.connect('bot_data.db')
        cur = conn.cursor()
        
        cur.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            group_name TEXT,
            role TEXT DEFAULT 'student',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        cur.execute('''CREATE TABLE IF NOT EXISTS homeworks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            subject TEXT,
            task TEXT,
            deadline TEXT,
            group_name TEXT,
            added_by INTEGER,
            photos_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        cur.execute('''CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            photos_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            photos_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            photos_ids TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )''')
        
        cur.execute('''CREATE TABLE IF NOT EXISTS polls (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            creator_id INTEGER,
            poll_id TEXT UNIQUE,
            question TEXT,
            options TEXT,
            group_name TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        cur.execute('''CREATE TABLE IF NOT EXISTS poll_answers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            poll_id TEXT,
            user_id INTEGER,
            option_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        conn.commit()
        print("ЛОГ: База данных инициализирована.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при инициализации: {e}")
    finally:
        if conn:
            conn.close()

def get_db_connection():
    try:
        conn = sqlite3.connect('bot_data.db')
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при подключении: {e}")
        return None

def get_user(user_id):
    conn = get_db_connection()
    if not conn: return None
    try:
        user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        return user
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении пользователя: {e}")
        return None
    finally:
        conn.close()

def get_all_users():
    conn = get_db_connection()
    if not conn: return []
    try:
        users = conn.execute('SELECT user_id, first_name, username, group_name FROM users').fetchall()
        return users
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении списка пользователей: {e}")
        return []
    finally:
        conn.close()

def add_user(user_id, username, first_name, last_name):
    conn = get_db_connection()
    if not conn: return
    try:
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        role = ROLE_STUDENT
        if user_id in SPECIAL_USERS:
            role = SPECIAL_USERS[user_id]['role']
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, group_name, role)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, DEFAULT_GROUP, role))
            print(f"ЛОГ: Добавлен новый пользователь: {first_name} (ID: {user_id}) с группой {DEFAULT_GROUP} и ролью {role}")
        else:
            conn.execute('''UPDATE users 
                         SET username = ?, first_name = ?, last_name = ?, role = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, role, user_id))
            print(f"ЛОГ: Обновлен пользователь: {first_name} (ID: {user_id}), роль: {role}")
        
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении пользователя: {e}")
    finally:
        conn.close()

def update_user_group(user_id, group_name):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('UPDATE users SET group_name = ? WHERE user_id = ?', (group_name, user_id))
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} сменил группу на {group_name}")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при обновлении группы: {e}")
    finally:
        conn.close()
    
def get_total_user_count():
    conn = get_db_connection()
    if not conn: return 0
    try:
        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        return count
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при подсчете пользователей: {e}")
        return 0
    finally:
        conn.close()
    
def delete_homework(hw_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM homeworks WHERE id = ?', (hw_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении ДЗ: {e}")
    finally:
        conn.close()

def delete_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении уведомления: {e}")
    finally:
        conn.close()

def delete_sport_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM sport_notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении спортивного уведомления: {e}")
    finally:
        conn.close()

def delete_user(user_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} удален из базы данных.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении пользователя: {e}")
    finally:
        conn.close()

def delete_suggestion(suggestion_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM suggestions WHERE id = ?', (suggestion_id,))
        conn.commit()
        print(f"ЛОГ: Предложение {suggestion_id} удалено из базы данных.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении предложения: {e}")
    finally:
        conn.close()

def get_all_sport_notifications():
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     ORDER BY s.created_at DESC''').fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении спортивных уведомлений: {e}")
        return []
    finally:
        conn.close()

def get_all_homeworks():
    conn = get_db_connection()
    if not conn: return []
    try:
        homeworks = conn.execute('''SELECT h.*, u.first_name 
                                     FROM homeworks h JOIN users u ON h.added_by = u.user_id 
                                     ORDER BY h.created_at DESC''').fetchall()
        return homeworks
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении ДЗ: {e}")
        return []
    finally:
        conn.close()
        
def get_all_notifications():
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT n.*, u.first_name 
                                     FROM notifications n JOIN users u ON n.added_by = u.user_id 
                                     ORDER BY n.created_at DESC''').fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении уведомлений: {e}")
        return []
    finally:
        conn.close()

# -------------------- SCHEDULE FUNCTIONS --------------------

def fetch_schedule_data():
    try:
        url = "https://pmk-online.ru/students/schedule/"
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
        resp = requests.get(url, headers=headers, timeout=10)
        resp.raise_for_status()
        html = resp.text

        match = re.search(r"const scheduleData\s*=\s*(\{.*?\});", html, re.S)
        if not match:
            print("ОШИБКА: Не удалось найти scheduleData на сайте.")
            return None

        schedule_raw = match.group(1)
        schedule_json_str = schedule_raw.replace(";", "")
        return json.loads(schedule_json_str)
    
    except requests.exceptions.RequestException as e:
        print(f"ОШИБКА: Ошибка сети при загрузке расписания: {e}")
        return None
    except (json.JSONDecodeError, IndexError) as e:
        print(f"ОШИБКА: Ошибка обработки данных расписания: {e}")
        return None
    except Exception as e:
        print(f"ОШИБКА: Неизвестная ошибка при загрузке расписания: {e}")
        return None

def filter_today_lessons(lessons):
    today_yekat = datetime.now(YEKATERINBURG_TZ).date()
    return [lesson for lesson in lessons if lesson.get('date') and datetime.fromisoformat(lesson['date'].replace('Z', '+00:00')).astimezone(YEKATERINBURG_TZ).date() == today_yekat]

def filter_tomorrow_lessons(lessons):
    tomorrow_yekat = (datetime.now(YEKATERINBURG_TZ) + timedelta(days=1)).date()
    return [lesson for lesson in lessons if lesson.get('date') and datetime.fromisoformat(lesson['date'].replace('Z', '+00:00')).astimezone(YEKATERINBURG_TZ).date() == tomorrow_yekat]

def filter_week_lessons(lessons):
    today_yekat = datetime.now(YEKATERINBURG_TZ).date()
    week_end = today_yekat + timedelta(days=7)
    return [lesson for lesson in lessons if lesson.get('date') and today_yekat <= datetime.fromisoformat(lesson['date'].replace('Z', '+00:00')).astimezone(YEKATERINBURG_TZ).date() <= week_end]

def get_lesson_time(lesson_number, day_of_week):
    lesson_times = {
        1: ("08:30", "10:05"), 2: ("10:15", "11:50"), 3: ("12:40", "14:15"),
        4: ("14:25", "16:00"), 5: ("16:10", "17:45"), 6: ("17:55", "19:30"),
    }
    saturday_times = {
        1: ("8:30", "9:45"), 2: ("9:55", "11:10"), 3: ("11:20", "12:40"), 
        4: ("13:20", "14:35"), 5: ("14:45", "16:00"), 6: ("16:10", "17:25")
    }

    if day_of_week == 5: # 5 is Saturday
        return saturday_times.get(lesson_number, ("❓", "❓"))
    else:
        return lesson_times.get(lesson_number, ("❓", "❓"))

def format_schedule(lessons, title):
    if not lessons:
        return "✅ Нет занятий"
    
    lessons.sort(key=lambda x: (x.get('date', ''), x.get('lessonNumber', 0)))
    
    result = [f"<b>{title}</b>\n"]
    current_date = None
    for lesson in lessons:
        try:
            lesson_date_utc = datetime.fromisoformat(lesson['date'].replace('Z', '+00:00'))
            lesson_date_yekat = lesson_date_utc.astimezone(YEKATERINBURG_TZ)
            date_str = lesson_date_yekat.strftime('%d.%m.%Y')
            
            if date_str != current_date:
                current_date = date_str
                day_names = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье']
                day_of_week_num = lesson_date_yekat.weekday()
                day_of_week = day_names[day_of_week_num]
                result.append(f"\n📅 <b>{date_str} ({day_of_week})</b>")
            
            lesson_number = lesson.get('lessonNumber', 0)
            start_time, end_time = get_lesson_time(lesson_number, day_of_week_num)
            
            lesson_text = (
                f"    ⏰ {start_time}-{end_time} | {lesson_number} пара\n"
                f"    📚 {lesson.get('subjectFull', 'N/A')}\n"
                f"    👨‍🏫 {lesson.get('teacher', 'N/A')}\n"
                f"    🚪 {lesson.get('room', 'N/A')}\n"
            )
            result.append(lesson_text)
        except Exception as e:
            print(f"ОШИБКА: Не удалось отформатировать пару: {e}")
            continue
    
    result.append(f"\n📊 <b>Всего занятий:</b> {len(lessons)}")
    return "\n".join(result)

def get_schedule(period, group_name):
    try:
        global schedule_cache, last_schedule_check
        
        now = datetime.now(YEKATERINBURG_TZ)
        if last_schedule_check is None or (now - last_schedule_check).total_seconds() > 3600:
            schedule_data = fetch_schedule_data()
            if schedule_data:
                schedule_cache = schedule_data
                last_schedule_check = now
                print("ЛОГ: Расписание обновлено из интернета")
            else:
                print("ЛОГ: Не удалось обновить расписание, используем кэш")
        else:
            schedule_data = schedule_cache
            print("ЛОГ: Используем кэшированное расписание")
        
        if not schedule_data:
            return "❌ Не удалось загрузить расписание"

        if group_name not in schedule_data:
            return f"❌ Нет расписания для группы {group_name}"

        lessons = schedule_data[group_name]
        
        if period == '📅 Сегодня':
            filtered_lessons = filter_today_lessons(lessons)
            title = f"📅 Расписание на сегодня ({group_name})"
        elif period == '📅 Завтра':
            filtered_lessons = filter_tomorrow_lessons(lessons)
            title = f"📅 Расписание на завтра ({group_name})"
        elif period == '📅 Неделя':
            filtered_lessons = filter_week_lessons(lessons)
            title = f"📅 Расписание на неделю ({group_name})"
        else:
            filtered_lessons = lessons
            title = f"📅 Все расписание ({group_name})"

        if not filtered_lessons:
            return f"✅ Нет занятий для выбранного периода."

        return format_schedule(filtered_lessons, title)

    except Exception as e:
        print(f"ОШИБКА: Произошла ошибка при получении расписания: {str(e)}")
        return f"❌ Произошла ошибка: {str(e)}"

async def check_schedule_changes(context: ContextTypes.DEFAULT_TYPE):
    global schedule_cache, last_schedule_check
    
    new_schedule = fetch_schedule_data()
    
    if not new_schedule:
        return

    for group_name in new_schedule.keys():
        old_lessons = schedule_cache.get(group_name, [])
        new_lessons = new_schedule.get(group_name, [])
        
        old_set = set(json.dumps(lesson, sort_keys=True) for lesson in old_lessons)
        new_set = set(json.dumps(lesson, sort_keys=True) for lesson in new_lessons)
        
        added_lessons_json = new_set - old_set
        removed_lessons_json = old_set - new_set
        
        if added_lessons_json or removed_lessons_json:
            print(f"ЛОГ: Обнаружены изменения в расписании для группы {group_name}")
            
            change_message = f"🔄 <b>Обновление расписания для группы {group_name}</b>\n\n"
            
            if added_lessons_json:
                change_message += "🟢 <b>Добавлено:</b>\n"
                for lesson_json in added_lessons_json:
                    lesson = json.loads(lesson_json)
                    change_message += f"- {lesson.get('date')} | {lesson.get('subjectFull')}\n"
            
            if removed_lessons_json:
                if added_lessons_json:
                    change_message += "\n"
                change_message += "🔴 <b>Удалено:</b>\n"
                for lesson_json in removed_lessons_json:
                    lesson = json.loads(lesson_json)
                    change_message += f"- {lesson.get('date')} | {lesson.get('subjectFull')}\n"
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")

    schedule_cache = new_schedule
    last_schedule_check = datetime.now(YEKATERINBURG_TZ)

async def send_daily_schedule(context: ContextTypes.DEFAULT_TYPE):
    print("ЛОГ: Отправка ежедневного расписания...")
    
    for group_name in schedule_cache.keys():
        lessons = schedule_cache.get(group_name)
        if not lessons:
            continue

        tomorrow_lessons = filter_tomorrow_lessons(lessons)
        
        if tomorrow_lessons:
            schedule_text = format_schedule(tomorrow_lessons, f"📅 Расписание на завтра ({group_name})")
            
            homeworks = get_homeworks(group_name)
            if homeworks:
                homework_text = "\n\n📝 <b>Домашние задания:</b>\n"
                for hw in homeworks[:3]:
                    homework_text += f"• {hw['subject']}: {hw['task']} (до {hw['deadline']})\n"
                schedule_text += homework_text
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить расписание пользователю {user['user_id']}: {e}")

async def send_morning_schedule(context: ContextTypes.DEFAULT_TYPE):
    print("ЛОГ: Отправка утреннего расписания...")
    
    for group_name in schedule_cache.keys():
        lessons = schedule_cache.get(group_name)
        if not lessons:
            continue

        today_lessons = filter_today_lessons(lessons)
        
        if today_lessons:
            schedule_text = format_schedule(today_lessons, f"📅 Расписание на сегодня ({group_name})")
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить расписание пользователю {user['user_id']}: {e}")

async def check_next_lesson(context: ContextTypes.DEFAULT_TYPE):
    global schedule_cache, user_notification_cache
    
    now = datetime.now(YEKATERINBURG_TZ)
    today_date = now.date()
    
    users_with_groups = get_db_connection().execute('SELECT user_id, group_name FROM users').fetchall()
    
    for user in users_with_groups:
        user_id = user['user_id']
        group_name = user['group_name']
        
        lessons = schedule_cache.get(group_name)
        if not lessons:
            continue

        today_lessons = filter_today_lessons(lessons)
        
        if not today_lessons:
            continue
            
        for i, lesson in enumerate(today_lessons):
            try:
                lesson_number = lesson.get('lessonNumber', 0)
                
                notification_key = f"{user_id}_{today_date}_{lesson_number}"
                
                if user_notification_cache.get(notification_key) is True:
                    continue

                day_of_week_num = now.weekday()
                start_time_str, _ = get_lesson_time(lesson_number, day_of_week_num)
                
                start_time_naive = datetime.strptime(start_time_str, '%H:%M').time()
                start_time_aware = datetime.combine(now.date(), start_time_naive).replace(tzinfo=YEKATERINBURG_TZ)
                
                if now + timedelta(minutes=5) >= start_time_aware and now < start_time_aware:
                    next_lesson_text = (
                        f"📅 <b>Начало следующей пары через 5 минут ({group_name})</b>\n\n"
                        f"    ⏰ {get_lesson_time(lesson_number, day_of_week_num)[0]}-{get_lesson_time(lesson_number, day_of_week_num)[1]} | {lesson_number} пара\n"
                        f"    📚 {lesson.get('subjectFull', 'N/A')}\n"
                        f"    👨‍🏫 {lesson.get('teacher', 'N/A')}\n"
                        f"    🚪 {lesson.get('room', 'N/A')}\n"
                    )
                    
                    try:
                        await context.bot.send_message(user_id, next_lesson_text, parse_mode='HTML')
                        user_notification_cache[notification_key] = True
                    except Exception as e:
                        print(f"ОШИБКА: Не удалось отправить уведомление о следующей паре пользователю {user_id}: {e}")
                        
            except Exception as e:
                print(f"ОШИБКА: Не удалось обработать пару: {e}")
                continue
                
    if now.hour == 0 and now.minute == 0:
        user_notification_cache.clear()

# -------------------- SPAM PROTECTION --------------------

def is_spam(user_id):
    now = datetime.now()
    user_data = user_message_counts[user_id]
    
    # Check if user is currently banned
    if user_bans[user_id]['end_time'] and now < user_bans[user_id]['end_time']:
        return True, user_bans[user_id]['end_time'] - now
    
    # Reset count if last message was more than 10 seconds ago
    if user_data['time'] is None or (now - user_data['time']).total_seconds() > 10:
        user_data['count'] = 1
        user_data['time'] = now
    else:
        user_data['count'] += 1
    
    # Check for spam
    if user_data['count'] > 10:
        return True, None # Spam detected, not yet banned
    
    return False, None

def ban_user(user_id):
    now = datetime.now()
    duration = user_bans[user_id]['duration']
    user_bans[user_id]['end_time'] = now + timedelta(minutes=duration)
    user_bans[user_id]['duration'] = duration * 2
    user_message_counts[user_id]['count'] = 0
    return duration

async def anti_spam_check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    is_spammer, time_left = is_spam(user_id)
    
    if is_spammer:
        if time_left is None: # First warning, not yet banned
            ban_duration = ban_user(user_id)
            await update.message.reply_text(
                f"🚨 **ПРЕДУПРЕЖДЕНИЕ!**\n\n"
                f"Ваши сообщения похожи на спам. Вы заблокированы на {ban_duration} минут.\n\n"
                f"Пожалуйста, подождите перед отправкой следующего сообщения."
            )
            print(f"ЛОГ: Пользователь {user_id} заблокирован на {ban_duration} минут за спам.")
        else:
            await update.message.reply_text(f"❌ **Блокировка активна.** Осталось: {str(time_left).split('.')[0]}")
        return True
    return False

# -------------------- CORE BOT FUNCTIONS --------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id
    
    if await anti_spam_check(update, context):
        return

    add_user(user_id, user.username, user.first_name, user.last_name)
    user_data = get_user(user_id)
    
    if not user_data or user_data['group_name'] not in ALL_GROUPS:
        return await ask_user_group(update, context)

    print(f"ЛОГ: Пользователь {user.first_name} (ID: {user.id}) вернулся в главное меню.")
    
    if user_id in SPECIAL_USERS and user_data['role'] != SPECIAL_USERS[user_id]['role']:
        keyboard = [[InlineKeyboardButton("🔄 Принудительно исправить роль", callback_data=f"fix_role_{user_id}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "⚠️ Обнаружено несоответствие роли. Нажмите кнопку ниже, чтобы исправить:",
            reply_markup=reply_markup
        )
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def ask_user_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [ALL_GROUPS[i:i+3] for i in range(0, len(ALL_GROUPS), 3)]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
    
    message_source = update.callback_query.message if update.callback_query else update.message
    await message_source.reply_text(
        "👋 Выбери свою группу:",
        reply_markup=reply_markup
    )
    
    return AWAITING_GROUP

async def handle_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id
    group_name = update.message.text
    
    if await anti_spam_check(update, context):
        return AWAITING_GROUP
        
    if group_name not in ALL_GROUPS:
        await update.message.reply_text(
            "❌ Пожалуйста, выбери группу из списка:",
            reply_markup=ReplyKeyboardMarkup([ALL_GROUPS[i:i+3] for i in range(0, len(ALL_GROUPS), 3)], 
                                           resize_keyboard=True, one_time_keyboard=True)
        )
        print(f"ЛОГ: Пользователь {user.first_name} (ID: {user_id}) ввел неверную группу: {group_name}")
        return AWAITING_GROUP
    
    update_user_group(user_id, group_name)
    
    await update.message.reply_text(
        f"✅ Группа {group_name} сохранена!",
        reply_markup=ReplyKeyboardRemove()
    )
    
    await show_main_menu(update, user_id)
    print(f"ЛОГ: Пользователь {user.first_name} (ID: {user_id}) успешно выбрал группу {group_name}.")
    return ConversationHandler.END

async def show_main_menu(update: Update, user_id: int):
    user_data = get_user(user_id)
    if not user_data:
        await update.message.reply_text("Произошла ошибка, попробуйте /start еще раз.")
        return

    role = user_data['role']
    
    welcome_text = "👋 Добро пожаловать!"
    
    if user_id in SPECIAL_USERS:
        welcome_text = f"👑 Добро пожаловать, {SPECIAL_USERS[user_id]['name']}!"
    elif role == ROLE_IT_SPECIALIST:
        welcome_text = "👑 Добро пожаловать, Айтишник!"
    elif role == ROLE_PHYSICAL_ORGANIZER:
        welcome_text = "🏃 Добро пожаловать, Физ. орг.!"

    if user_id == DEVELOPER_ID:
        keyboard = [
            ['📅 Расписание', '📝 ДЗ'],
            ['ℹ️ Информация', '💡 Предложения', '💡 Предложить идею'],
            ['📢 Отправить ДЗ', '📢 Отправить уведомление', '📢 Опрос'],
            ['Удалить', '💰 Дать денюжку', '🔔 Расписание звонков'],
            ['📞 Связаться', '🎓 Сменить группу']
        ]
    elif role == ROLE_IT_SPECIALIST:
        keyboard = [
            ['📅 Расписание', '📝 ДЗ'],
            ['ℹ️ Информация', '💡 Предложения', '💡 Предложить идею'],
            ['📢 Отправить ДЗ', '📢 Отправить уведомление', '📢 Опрос'],
            ['Удалить', '💰 Дать денюжку', '🔔 Расписание звонков'],
            ['📞 Связаться', '🎓 Сменить группу']
        ]
    elif role == ROLE_PHYSICAL_ORGANIZER:
        keyboard = [
            ['📅 Расписание', '📝 ДЗ'],
            ['ℹ️ Информация', '💡 Предложения', '💡 Предложить идею'],
            ['🏃 Отправить спортивное уведомление'],
            ['Удалить', '💰 Дать денюжку', '🔔 Расписание звонков'],
            ['📞 Связаться', '🎓 Сменить группу']
        ]
    else:
        keyboard = [
            ['📅 Расписание', '📝 ДЗ'],
            ['ℹ️ Информация', '💡 Предложить идею'],
            ['💰 Дать денюжку', '🔔 Расписание звонков'],
            ['📞 Связаться', '🎓 Сменить группу']
        ]
    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    message_source = update.callback_query.message if update.callback_query else update.message
    await message_source.reply_text(welcome_text, reply_markup=reply_markup)

    print(f"ЛОГ: Главное меню показано для пользователя {user_data['first_name']} (ID: {user_id}).")

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id
    
    await update.message.reply_text("Действие отменено.", reply_markup=ReplyKeyboardRemove())
    await show_main_menu(update, user_id)
    print(f"ЛОГ: Диалог отменен пользователем {user.first_name} (ID: {user_id}).")
    return ConversationHandler.END

async def handle_simple_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = user.id
    text = update.message.text
    user_data = get_user(user_id)

    if await anti_spam_check(update, context):
        return
    
    print(f"ЛОГ: Пользователь {user.first_name} (ID: {user_id}) отправил сообщение: '{text}'")
    
    if not user_data or user_data['group_name'] not in ALL_GROUPS:
        add_user(user_id, user.username, user.first_name, user.last_name)
        await update.message.reply_text("Пожалуйста, нажми /start и выбери свою группу.")
        return

    role = user_data['role']
    group_name = user_data['group_name']
    
    if text == '📅 Расписание':
        await show_schedule_periods(update, user_id)
    
    elif text == '📝 ДЗ':
        await show_homework(update, group_name)
    
    elif text == 'ℹ️ Информация':
        await show_information(update)

    elif text == '💡 Предложения' and (role in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER] or user_id in SPECIAL_USERS):
        await show_suggestions(update)
    
    elif text == 'Список пользователей' and user_id == DEVELOPER_ID:
        await show_users_list(update)

    elif text == '💰 Дать денюжку':
        donate_text = "Если не жалко, можешь дать разрабу бота денюжку на дальнейшее развитие бота и на покушать😊"
        keyboard = [
            [InlineKeyboardButton("💸 Поддержать автора", url="https://www.donationalerts.com/r/ax_hikitka")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(donate_text, reply_markup=reply_markup)

    elif text == '🔔 Расписание звонков':
        await show_call_schedule(update)
    
    elif text == '📞 Связаться':
        await contact_menu(update)
    
    elif text in ['📅 Сегодня', '📅 Завтра', '📅 Неделя', '📅 Все расписание']:
        await handle_schedule_period(update, context, group_name)
    
    elif text == '🔙 Назад':
        await show_main_menu(update, user_id)
    
    elif text == 'Удалить' and (role in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER] or user_id == DEVELOPER_ID):
        await delete_menu(update)
        
    elif text in ALL_GROUPS:
        await handle_group_selection(update, context)

    else:
        await update.message.reply_text("Используй кнопки для навигации 👇")
        print(f"ЛОГ: Неизвестная команда от {user.first_name} (ID: {user_id}): '{text}'")

# -------------------- SCHEDULE DISPLAY FUNCTIONS --------------------

async def show_schedule_periods(update: Update, user_id: int):
    keyboard = [
        ['📅 Сегодня', '📅 Завтра'],
        ['📅 Неделя', '📅 Все расписание'],
        ['🔙 Назад']
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text("Выбери период для просмотра расписания:", reply_markup=reply_markup)
    print(f"ЛОГ: Показан выбор периода расписания для пользователя {user_id}.")

async def handle_schedule_period(update: Update, context: ContextTypes.DEFAULT_TYPE, group_name: str):
    text = update.message.text
    print(f"ЛОГ: Пользователь запросил расписание для периода '{text}'.")
    
    if await anti_spam_check(update, context):
        return

    await update.message.reply_text("⏳ Загружаю расписание...", reply_markup=ReplyKeyboardRemove())
    schedule = get_schedule(text, group_name)
    await update.message.reply_text(schedule, parse_mode='HTML')
    await show_main_menu(update, update.effective_user.id)

# -------------------- DATABASE INTERACTION FUNCTIONS --------------------

def add_homework(subject, task, deadline, group_name, added_by, photos_ids=None):
    conn = get_db_connection()
    if not conn: return
    try:
        photos_str = json.dumps(photos_ids) if photos_ids else None
        conn.execute('''INSERT INTO homeworks (subject, task, deadline, group_name, added_by, photos_ids)
                     VALUES (?, ?, ?, ?, ?, ?)''', (subject, task, deadline, group_name, added_by, photos_str))
        conn.commit()
        print(f"ЛОГ: Добавлено ДЗ для группы {group_name}.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении ДЗ: {e}")
    finally:
        conn.close()

def get_homeworks(group_name):
    conn = get_db_connection()
    if not conn: return []
    try:
        homeworks = conn.execute('''SELECT h.*, u.first_name 
                                 FROM homeworks h JOIN users u ON h.added_by = u.user_id 
                                 WHERE h.group_name = ? ORDER BY h.created_at DESC''', (group_name,)).fetchall()
        return homeworks
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении ДЗ: {e}")
        return []
    finally:
        conn.close()

def add_notification(message, group_name, added_by, photos_ids=None):
    conn = get_db_connection()
    if not conn: return
    try:
        photos_str = json.dumps(photos_ids) if photos_ids else None
        conn.execute('''INSERT INTO notifications (message, group_name, added_by, photos_ids)
                     VALUES (?, ?, ?, ?)''', (message, group_name, added_by, photos_str))
        conn.commit()
        print(f"ЛОГ: Добавлено уведомление для группы {group_name}.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении уведомления: {e}")
    finally:
        conn.close()

def get_notifications(group_name):
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT n.*, u.first_name 
                                     FROM notifications n JOIN users u ON n.added_by = u.user_id 
                                     WHERE n.group_name = ? ORDER BY n.created_at DESC''', (group_name,)).fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_sport_notification(message, group_name, added_by, photos_ids=None):
    conn = get_db_connection()
    if not conn: return
    try:
        photos_str = json.dumps(photos_ids) if photos_ids else None
        conn.execute('''INSERT INTO sport_notifications (message, group_name, added_by, photos_ids)
                     VALUES (?, ?, ?, ?)''', (message, group_name, added_by, photos_str))
        conn.commit()
        print(f"ЛОГ: Добавлено спортивное уведомление для группы {group_name}.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении спортивного уведомления: {e}")
    finally:
        conn.close()

def get_sport_notifications(group_name):
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     WHERE s.group_name = ? ORDER BY s.created_at DESC''', (group_name,)).fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении спортивных уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_suggestion(user_id, message, photos_ids=None):
    conn = get_db_connection()
    if not conn: return
    try:
        photos_str = json.dumps(photos_ids) if photos_ids else None
        conn.execute('INSERT INTO suggestions (user_id, message, photos_ids) VALUES (?, ?, ?)', (user_id, message, photos_str))
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} отправил предложение.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении предложения: {e}")
    finally:
        conn.close()

def get_suggestions():
    conn = get_db_connection()
    if not conn: return []
    try:
        suggestions = conn.execute('''SELECT s.*, u.first_name, u.username 
                                   FROM suggestions s JOIN users u ON s.user_id = u.user_id 
                                   ORDER BY s.created_at DESC''').fetchall()
        return suggestions
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении предложений: {e}")
        return []
    finally:
        conn.close()

def add_poll_to_db(creator_id, poll_id, question, options, group_name):
    conn = get_db_connection()
    if not conn: return
    try:
        options_str = json.dumps(options)
        conn.execute('''INSERT INTO polls (creator_id, poll_id, question, options, group_name)
                     VALUES (?, ?, ?, ?, ?)''', (creator_id, poll_id, question, options_str, group_name))
        conn.commit()
        print(f"ЛОГ: Опрос '{question}' добавлен в БД.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении опроса: {e}")
    finally:
        conn.close()

def get_poll_by_telegram_id(poll_id):
    conn = get_db_connection()
    if not conn: return None
    try:
        poll = conn.execute('SELECT * FROM polls WHERE poll_id = ?', (poll_id,)).fetchone()
        if poll:
            poll = dict(poll)
            poll['options'] = json.loads(poll['options'])
            return poll
        return None
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении опроса: {e}")
        return None
    finally:
        conn.close()

def get_poll_answers(poll_id):
    conn = get_db_connection()
    if not conn: return []
    try:
        answers = conn.execute('SELECT user_id, option_id FROM poll_answers WHERE poll_id = ?', (poll_id,)).fetchall()
        return answers
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении ответов на опрос: {e}")
        return []
    finally:
        conn.close()

def add_poll_answer(poll_id, user_id, option_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('INSERT OR REPLACE INTO poll_answers (poll_id, user_id, option_id) VALUES (?, ?, ?)', (poll_id, user_id, option_id))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении ответа на опрос: {e}")
    finally:
        conn.close()

# -------------------- MESSAGE SENDING (DIALOG) FUNCTIONS --------------------

async def ask_homework_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "📝 <b>Добавление нового ДЗ</b>\n\n"
        "Напиши в формате:\n"
        "<b>Предмет</b>\n"
        "<b>Задание</b>\n"
        "<b>Срок сдачи</b>\n\n"
        "Пример:\n"
        "Математика\n"
        "Решить задачи 1-10 на странице 45\n"
        "До 15.09\n\n"
        "Можно прикрепить фото или видео (сразу несколько)",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
    )
    print(f"ЛОГ: Запрошен ввод ДЗ от пользователя {update.effective_user.id}.")
    return AWAITING_HOMEWORK

async def ask_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "📢 <b>Отправка уведомления всем</b>\n\n"
        "Напиши уведомление, которое нужно отправить всем ученикам.\n"
        "Можно прикрепить фото или видео (сразу несколько)",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
    )
    print(f"ЛОГ: Запрошен ввод уведомления от пользователя {update.effective_user.id}.")
    return AWAITING_INFO

async def ask_sport_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "🏃 <b>Отправка спортивного уведомления</b>\n\n"
        "Напиши спортивное уведомление, которое нужно отправить всем ученикам.\n"
        "Можно прикрепить фото или видео (сразу несколько)",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
    )
    print(f"ЛОГ: Запрошен ввод спортивного уведомления от пользователя {update.effective_user.id}.")
    return AWAITING_SPORT

async def ask_suggestion_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "💡 <b>Предложение по улучшению бота</b>\n\n"
        "Напиши свое предложение по улучшению бота:\n\n"
        "Что бы ты хотел добавить или изменить? Можно приложить фото или видео.",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
    )
    print(f"ЛОГ: Запрошен ввод предложения от пользователя {update.effective_user.id}.")
    return AWAITING_SUGGESTION

async def ask_poll_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "📝 <b>Создание опроса</b>\n\n"
        "Напиши вопрос для опроса:",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
    )
    return AWAITING_POLL_QUESTION

async def handle_poll_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    question = update.message.text
    context.user_data['poll_question'] = question
    await update.message.reply_text(
        "✍️ Теперь напиши варианты ответов, каждый с новой строки:",
        parse_mode='HTML'
    )
    return AWAITING_POLL_OPTIONS

async def handle_poll_options(update: Update, context: ContextTypes.DEFAULT_TYPE):
    options = update.message.text.split('\n')
    if len(options) < 2:
        await update.message.reply_text("❌ Нужно как минимум 2 варианта ответа. Пожалуйста, попробуй еще раз:")
        return AWAITING_POLL_OPTIONS
    
    context.user_data['poll_options'] = options
    
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    group_name = user_data['group_name']
    question = context.user_data['poll_question']
    
    await update.message.reply_text("✅ Опрос создан и отправляется...", reply_markup=ReplyKeyboardRemove())
    
    poll_message = await send_poll_to_all(context.bot, question, options, group_name, user_id)
    if poll_message:
        poll_id = poll_message.poll.id
        add_poll_to_db(user_id, poll_id, question, options, group_name)

    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def handle_suggestion_reply(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message.text
    suggestion_id = context.user_data['suggestion_id']
    
    conn = get_db_connection()
    suggestion = conn.execute('SELECT * FROM suggestions WHERE id = ?', (suggestion_id,)).fetchone()
    conn.close()
    
    if not suggestion:
        await update.message.reply_text("❌ Предложение не найдено.")
        return await cancel_conversation(update, context)
        
    try:
        await context.bot.send_message(
            chat_id=suggestion['user_id'],
            text=f"📨 **Ответ на ваше предложение:**\n\n> {suggestion['message']}\n\n**Ответ:** {message}",
            parse_mode='Markdown'
        )
        await update.message.reply_text("✅ Ответ отправлен!", reply_markup=ReplyKeyboardRemove())
    except Exception as e:
        await update.message.reply_text(f"❌ Не удалось отправить ответ: {e}", reply_markup=ReplyKeyboardRemove())
    
    await show_main_menu(update, update.effective_user.id)
    return ConversationHandler.END

# --- UPDATED MESSAGE HANDLING FUNCTIONS IN DIALOGS ---

async def handle_homework_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if await anti_spam_check(update, context):
        return AWAITING_HOMEWORK

    if user_id not in SPECIAL_USERS or SPECIAL_USERS[user_id]['role'] != ROLE_IT_SPECIALIST:
        await update.message.reply_text("У вас нет прав для этого действия.")
        return await cancel_conversation(update, context)

    group_name = user_data['group_name']
    
    photos_ids = []
    if update.message.photo:
        photos_ids = [p.file_id for p in update.message.photo]
    
    if update.message.document and update.message.document.mime_type.startswith('video'):
        photos_ids.append(update.message.document.file_id)
    
    text = update.message.caption if update.message.caption else update.message.text
    
    if text == '❌ Отмена':
        return await cancel_conversation(update, context)

    if not text:
        await update.message.reply_text("❌ Пожалуйста, добавь описание к ДЗ.")
        return AWAITING_HOMEWORK

    lines = text.strip().split('\n')
    if len(lines) >= 3:
        subject = lines[0].strip()
        task = lines[1].strip()
        deadline = lines[2].strip()
        
        add_homework(subject, task, deadline, group_name, user_id, photos_ids)
        await update.message.reply_text("✅ ДЗ добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
        await send_homework_to_all(context.bot, subject, task, deadline, group_name, user_id, photos_ids)
        print(f"ЛОГ: ДЗ добавлено пользователем {user_id} для группы {group_name}.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    else:
        await update.message.reply_text("❌ Неправильный формат. Нужно 3 строки: предмет, задание, срок")
        return AWAITING_HOMEWORK

async def handle_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)

    if await anti_spam_check(update, context):
        return AWAITING_INFO

    if user_id not in SPECIAL_USERS or SPECIAL_USERS[user_id]['role'] != ROLE_IT_SPECIALIST:
        await update.message.reply_text("У вас нет прав для этого действия.")
        return await cancel_conversation(update, context)

    group_name = user_data['group_name']
    
    photos_ids = []
    if update.message.photo:
        photos_ids = [p.file_id for p in update.message.photo]
    
    if update.message.document and update.message.document.mime_type.startswith('video'):
        photos_ids.append(update.message.document.file_id)

    message_text = update.message.caption if update.message.caption else update.message.text

    if message_text == '❌ Отмена':
        return await cancel_conversation(update, context)

    if not message_text:
        await update.message.reply_text("❌ Пожалуйста, добавь текст уведомления.")
        return AWAITING_INFO

    add_notification(message_text, group_name, user_id, photos_ids)
    await update.message.reply_text("✅ Уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
    await send_notification_to_all(context.bot, message_text, group_name, user_id, photos_ids)
    print(f"ЛОГ: Уведомление отправлено пользователем {user_id} для группы {group_name}.")
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def handle_sport_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)

    if await anti_spam_check(update, context):
        return AWAITING_SPORT

    if user_id not in SPECIAL_USERS or SPECIAL_USERS[user_id]['role'] != ROLE_PHYSICAL_ORGANIZER:
        await update.message.reply_text("У вас нет прав для этого действия.")
        return await cancel_conversation(update, context)

    group_name = user_data['group_name']

    photos_ids = []
    if update.message.photo:
        photos_ids = [p.file_id for p in update.message.photo]
    
    if update.message.document and update.message.document.mime_type.startswith('video'):
        photos_ids.append(update.message.document.file_id)

    message_text = update.message.caption if update.message.caption else update.message.text

    if message_text == '❌ Отмена':
        return await cancel_conversation(update, context)

    if not message_text:
        await update.message.reply_text("❌ Пожалуйста, добавь текст спортивного уведомления.")
        return AWAITING_SPORT
    
    add_sport_notification(message_text, group_name, user_id, photos_ids)
    await update.message.reply_text("✅ Спортивное уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
    await send_sport_notification_to_all(context.bot, message_text, group_name, user_id, photos_ids)
    print(f"ЛОГ: Спортивное уведомление отправлено пользователем {user_id} для группы {group_name}.")
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def handle_suggestion_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if await anti_spam_check(update, context):
        return AWAITING_SUGGESTION

    photos_ids = []
    if update.message.photo:
        photos_ids = [p.file_id for p in update.message.photo]
    
    if update.message.document and update.message.document.mime_type.startswith('video'):
        photos_ids.append(update.message.document.file_id)

    text = update.message.caption if update.message.caption else update.message.text

    if text == '❌ Отмена':
        return await cancel_conversation(update, context)
    
    if not text:
        await update.message.reply_text("❌ Пожалуйста, напиши свое предложение.")
        return AWAITING_SUGGESTION

    add_suggestion(user_id, text, photos_ids)
    
    for special_id in SPECIAL_USERS:
        try:
            message_text = f"💡 Новое предложение от {user_data['first_name']} (@{user_data['username']}):\n\n{text}"
            keyboard = [[InlineKeyboardButton("💬 Ответить", callback_data=f"reply_sugg_{get_last_suggestion_id()}")]]
            
            if photos_ids:
                if len(photos_ids) == 1:
                    await context.bot.send_photo(special_id, photo=photos_ids[0], caption=message_text, reply_markup=InlineKeyboardMarkup(keyboard))
                else:
                    media = [telegram.InputMediaPhoto(media=p) for p in photos_ids]
                    await context.bot.send_media_group(special_id, media=media)
                    await context.bot.send_message(special_id, message_text, reply_markup=InlineKeyboardMarkup(keyboard))
            else:
                await context.bot.send_message(special_id, message_text, reply_markup=InlineKeyboardMarkup(keyboard))
        except Exception as e:
            print(f"Не удалось отправить предложение пользователю {special_id}: {e}")
    
    await update.message.reply_text("✅ Спасибо за предложение! Мы его рассмотрим.", reply_markup=ReplyKeyboardRemove())
    await show_main_menu(update, user_id)
    print(f"ЛОГ: Пользователь {user_id} отправил предложение.")
    return ConversationHandler.END

def get_last_suggestion_id():
    conn = get_db_connection()
    suggestion_id = conn.execute('SELECT MAX(id) FROM suggestions').fetchone()[0]
    conn.close()
    return suggestion_id

# --- NOTIFICATION SENDING LOGIC ---

async def send_homework_to_all(bot, subject, task, deadline, group_name, added_by, photos_ids=None):
    homework_text = (
        f"📝 <b>НОВОЕ ДОМАШНЕЕ ЗАДАНИЕ</b>\n\n"
        f"📚 <b>Предмет:</b> {subject}\n"
        f"📋 <b>Задание:</b> {task}\n"
        f"⏰ <b>Срок сдачи:</b> {deadline}\n"
        f"👥 <b>Группа:</b> {group_name}\n"
    )
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            if photos_ids:
                if len(photos_ids) > 1:
                    media = [telegram.InputMediaPhoto(media=p) if p.startswith('AgAD') else telegram.InputMediaVideo(media=p) for p in photos_ids]
                    await bot.send_media_group(chat_id=user['user_id'], media=media)
                    await bot.send_message(user['user_id'], homework_text, parse_mode='HTML')
                else:
                    await bot.send_photo(chat_id=user['user_id'], photo=photos_ids[0], caption=homework_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], homework_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить ДЗ пользователю {user['user_id']}: {e}")

async def send_notification_to_all(bot, message, group_name, added_by, photos_ids=None):
    notification_text = (f"📢 <b>ВАЖНОЕ УВЕДОМЛЕНИЕ</b>\n\n{message}\n\n👥 <b>Группа:</b> {group_name}")
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            if photos_ids:
                if len(photos_ids) > 1:
                    media = [telegram.InputMediaPhoto(media=p) if p.startswith('AgAD') else telegram.InputMediaVideo(media=p) for p in photos_ids]
                    await bot.send_media_group(chat_id=user['user_id'], media=media)
                    await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
                else:
                    await bot.send_photo(chat_id=user['user_id'], photo=photos_ids[0], caption=notification_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")

async def send_sport_notification_to_all(bot, message, group_name, added_by, photos_ids=None):
    sport_text = (f"🏃 <b>СПОРТИВНОЕ УВЕДОМЛЕНИЕ</b>\n\n{message}\n\n👥 <b>Группа:</b> {group_name}")
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()

    for user in users:
        try:
            if photos_ids:
                if len(photos_ids) > 1:
                    media = [telegram.InputMediaPhoto(media=p) if p.startswith('AgAD') else telegram.InputMediaVideo(media=p) for p in photos_ids]
                    await bot.send_media_group(chat_id=user['user_id'], media=media)
                    await bot.send_message(user['user_id'], sport_text, parse_mode='HTML')
                else:
                    await bot.send_photo(chat_id=user['user_id'], photo=photos_ids[0], caption=sport_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], sport_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить спортивное уведомление пользователю {user['user_id']}: {e}")

async def send_poll_to_all(bot, question, options, group_name, creator_id):
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    poll_message = None
    
    for i, user in enumerate(users):
        try:
            message = await bot.send_poll(
                chat_id=user['user_id'],
                question=question,
                options=options,
                is_anonymous=False,
                allows_multiple_answers=False
            )
            # We need the poll_id from any message to save to the database.
            # The poll_id is the same for all messages.
            if i == 0:
                poll_message = message
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить опрос пользователю {user['user_id']}: {e}")
    
    return poll_message

# -------------------- INFO DISPLAY FUNCTIONS --------------------

async def show_homework(update: Update, group_name: str):
    homeworks = get_homeworks(group_name)
    if not homeworks:
        await update.message.reply_text("📭 Пока нет домашних заданий")
        return
    
    for hw in homeworks:
        hw_text = (
            f"📝 <b>Домашнее задание</b>\n"
            f"📚 <b>Предмет:</b> {hw['subject']}\n"
            f"📋 <b>Задание:</b> {hw['task']}\n"
            f"⏰ <b>Срок:</b> {hw['deadline']}\n"
            f"👤 <b>Добавил:</b> {hw['first_name']}\n"
            f"📅 <b>Дата:</b> {datetime.fromisoformat(hw['created_at']).strftime('%d.%m.%Y %H:%M')}"
        )
        photos_ids = json.loads(hw['photos_ids']) if hw['photos_ids'] else []
        if photos_ids:
            if len(photos_ids) > 1:
                media = [telegram.InputMediaPhoto(media=p) if p.startswith('AgAD') else telegram.InputMediaVideo(media=p) for p in photos_ids]
                await update.message.reply_media_group(media=media)
                await update.message.reply_text(hw_text, parse_mode='HTML')
            else:
                await update.message.reply_photo(photo=photos_ids[0], caption=hw_text, parse_mode='HTML')
        else:
            await update.message.reply_text(hw_text, parse_mode='HTML')
    
    await update.message.reply_text(f"📊 <b>Показано:</b> {len(homeworks)} заданий", parse_mode='HTML')

async def show_information(update: Update):
    user_count = get_total_user_count()
    info_text = f"📊 <b>Пользователей в боте:</b> {user_count}\n\n<b>Контакты:</b>\n"
    for data in SPECIAL_USERS.values():
        info_text += f"- <b>{data['name']}</b>: {data['username']}\n"
    await update.message.reply_text(info_text, parse_mode='HTML')

async def show_suggestions(update: Update):
    suggestions = get_suggestions()
    if not suggestions:
        await update.message.reply_text("📭 Пока нет предложений от учеников")
        return
    
    for i, s in enumerate(suggestions[:5], 1):
        username = f"@{s['username']}" if s['username'] else s['first_name']
        suggestion_text = (
            f"💡 **Предложение от {username}**\n\n"
            f"{s['message']}\n\n"
            f"📅 {datetime.fromisoformat(s['created_at']).strftime('%d.%m.%Y %H:%M')}"
        )
        
        keyboard = [[InlineKeyboardButton("💬 Ответить", callback_data=f"reply_sugg_{s['id']}")]]
        
        photos_ids = json.loads(s['photos_ids']) if s['photos_ids'] else []
        if photos_ids:
            if len(photos_ids) > 1:
                media = [telegram.InputMediaPhoto(media=p) if p.startswith('AgAD') else telegram.InputMediaVideo(media=p) for p in photos_ids]
                await update.message.reply_media_group(media=media)
                await update.message.reply_text(suggestion_text, parse_mode='Markdown', reply_markup=InlineKeyboardMarkup(keyboard))
            else:
                await update.message.reply_photo(photo=photos_ids[0], caption=suggestion_text, parse_mode='Markdown', reply_markup=InlineKeyboardMarkup(keyboard))
        else:
            await update.message.reply_text(suggestion_text, parse_mode='Markdown', reply_markup=InlineKeyboardMarkup(keyboard))

async def show_users_list(update: Update):
    users = get_all_users()
    if not users:
        await update.message.reply_text("❌ В базе данных нет пользователей.")
        return
    
    user_list_text = "👥 **Список пользователей**\n\n"
    
    for user in users:
        username = user['username'] if user['username'] else "Нет юзернейма"
        user_list_text += (
            f"**Имя:** {user['first_name']}\n"
            f"**Группа:** {user['group_name']}\n"
            f"**Юзер:** @{username}\n"
            f"**ID:** `{user['user_id']}`\n\n"
        )
    
    await update.message.reply_text(user_list_text, parse_mode='Markdown')

async def show_call_schedule(update: Update):
    now = datetime.now(YEKATERINBURG_TZ)
    day_of_week = now.weekday()
    
    if day_of_week == 5:  # Saturday
        schedule_text = (
            "🔔 **Расписание звонков на субботу**\n\n"
            "1 пара: **8:30 - 9:45**\n"
            "Перемена: 10 минут\n"
            "2 пара: **9:55 - 11:10**\n"
            "Перемена: 10 минут\n"
            "3 пара: **11:20 - 12:40**\n"
            "Перемена: 40 минут - ОБЕД\n"
            "4 пара: **13:20 - 14:35**\n"
            "Перемена: 10 минут\n"
            "5 пара: **14:45 - 16:00**\n"
            "Перемена: 10 минут\n"
            "6 пара: **16:10 - 17:25**\n"
        )
    else:
        schedule_text = (
            "🔔 **Расписание звонков (понедельник-пятница)**\n\n"
            "1 пара: **8:30 - 10:05**\n"
            "Перемена: 10 минут\n"
            "2 пара: **10:15 - 11:50**\n"
            "Перемена: 10 минут\n"
            "3 пара: **12:40 - 14:15**\n"
            "Перемена: 40 минут - ОБЕД\n"
            "4 пара: **14:25 - 16:00**\n"
            "Перемена: 10 минут\n"
            "5 пара: **16:10 - 17:45**\n"
            "Перемена: 10 минут\n"
            "6 пара: **17:55 - 19:30**\n"
        )
    
    await update.message.reply_text(schedule_text, parse_mode='Markdown')

async def contact_menu(update: Update):
    keyboard = [
        ['📞 Связаться со старостой', '📞 Связаться с замом старосты'],
        ['📞 Связаться с физоргом'],
        ['🔙 Назад']
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    await update.message.reply_text("Выберите с кем связаться:", reply_markup=reply_markup)

async def contact_physical_organizer(update: Update):
    username = next((data['username'] for data in SPECIAL_USERS.values() if data['role'] == ROLE_PHYSICAL_ORGANIZER), None)
    if username:
        await update.message.reply_text(f"🏃 <b>Связь с Физ. оргом</b>\n\n📞 Telegram: {username}", parse_mode='HTML')
    else:
        await update.message.reply_text("❌ Физ. орг. не найден")

async def contact_starosta(update: Update):
    username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == 'Староста'), None)
    if username:
        await update.message.reply_text(f"👑 <b>Связь со старостой</b>\n\n📞 Telegram: {username}", parse_mode='HTML')
    else:
        await update.message.reply_text("❌ Староста не найден")

async def contact_deputy_starosta(update: Update):
    username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == 'Зам Старосты'), None)
    if username:
        await update.message.reply_text(f"👑 <b>Связь с замом старосты (разработчиком)</b>\n\n📞 Telegram: {username}", parse_mode='HTML')
    else:
        await update.message.reply_text("❌ Зам старосты не найден")

# -------------------- DELETION FUNCTIONS --------------------

async def delete_menu(update: Update):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    role = user_data['role']
    
    keyboard = []
    if role in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER] or user_id == DEVELOPER_ID:
        if role == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID:
            keyboard.append(['Удалить ДЗ', 'Удалить уведомление', 'Удалить предложения'])
        if role == ROLE_PHYSICAL_ORGANIZER or user_id == DEVELOPER_ID:
            keyboard.append(['Удалить спортивные уведомления'])
        if user_id == DEVELOPER_ID:
            keyboard.append(['Удалить пользователя'])
    
    if keyboard:
        keyboard.append(['🔙 Назад'])
        await update.message.reply_text("Что вы хотите удалить?", reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True))
        return AWAITING_DELETE_MENU
    else:
        await update.message.reply_text("У вас нет прав для этого действия.")
        return ConversationHandler.END

async def delete_homework_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if user_id == DEVELOPER_ID:
        homeworks = get_all_homeworks()
    else:
        homeworks = get_homeworks(user_data['group_name'])
        
    if not homeworks:
        await update.message.reply_text("📝 Нет домашних заданий для удаления.")
        return ConversationHandler.END
    
    keyboard = [[InlineKeyboardButton(f"❌ {hw['subject']} | {hw['deadline']}", callback_data=f"del_hw_{hw['id']}")] for hw in homeworks[:5]]
    await update.message.reply_text("Выберите ДЗ для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_HOMEWORK_DELETE

async def delete_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if user_id == DEVELOPER_ID:
        notifications = get_all_notifications()
    else:
        notifications = get_notifications(user_data['group_name'])
    
    if not notifications:
        await update.message.reply_text("📢 Нет уведомлений для удаления.")
        return ConversationHandler.END

    keyboard = []
    for n in notifications[:5]:
        button_text = f"📢 {n['message'][:20]}..."
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_notif_{n['id']}")])
    
    await update.message.reply_text("Выберите уведомление для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_INFO_DELETE

async def delete_sport_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if user_id == DEVELOPER_ID:
        sport_notifications = get_all_sport_notifications()
    else:
        sport_notifications = get_sport_notifications(user_data['group_name'])

    if not sport_notifications:
        await update.message.reply_text("🏃 Нет спортивных уведомлений для удаления.")
        return ConversationHandler.END

    keyboard = []
    for sport in sport_notifications[:10]:
        button_text = f"🏃 {sport['message'][:20]}..."
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{sport['id']}")])

    await update.message.reply_text("Выберите спортивное уведомление для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_SPORT_DELETE

async def delete_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("У вас нет прав для этого действия.")
        return ConversationHandler.END
        
    users = [u for u in get_all_users() if u['user_id'] not in SPECIAL_USERS]
    if not users:
        await update.message.reply_text("👥 Нет пользователей для удаления.")
        return ConversationHandler.END
        
    keyboard = [[InlineKeyboardButton(f"❌ {u['first_name']} (@{u['username']}) - Группа: {u['group_name']} - ID: {u['user_id']}", callback_data=f"del_user_{u['user_id']}")] for u in users]
    await update.message.reply_text("Выберите пользователя для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_USER_DELETE

async def delete_suggestions_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_data = get_user(user_id)
    
    if user_id != DEVELOPER_ID and (not user_data or user_data['role'] not in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER]):
        await update.message.reply_text("У вас нет прав для этого действия.")
        return ConversationHandler.END
        
    suggestions = get_suggestions()
    if not suggestions:
        await update.message.reply_text("💡 Нет предложений для удаления.")
        return ConversationHandler.END
    
    keyboard = [[InlineKeyboardButton(f"❌ {s['message'][:20]}...", callback_data=f"del_sugg_{s['id']}")] for s in suggestions[:5]]
    await update.message.reply_text("Выберите предложение для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
    return AWAITING_SUGGESTION_DELETE

async def handle_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    parts = query.data.split('_')
    data_type = parts[1]
    item_id = int(parts[2])
    
    message = "❌ Произошла ошибка."
    try:
        if data_type == 'hw':
            delete_homework(item_id)
            message = "✅ Домашнее задание успешно удалено."
        elif data_type == 'notif':
            delete_notification(item_id)
            message = "✅ Уведомление успешно удалено."
        elif data_type == 'sport':
            delete_sport_notification(item_id)
            message = "✅ Спортивное уведомление успешно удалено."
        elif data_type == 'user':
            delete_user(item_id)
            message = "✅ Пользователь успешно удален."
        elif data_type == 'sugg':
            delete_suggestion(item_id)
            message = "✅ Предложение успешно удалено."
        
        await query.edit_message_text(text=message)
    except Exception as e:
        await query.edit_message_text(text=f"❌ Ошибка при удалении: {e}")
    
    await show_main_menu(update, query.from_user.id)
    return ConversationHandler.END

# -------------------- CALLBACKS & HANDLERS --------------------

async def handle_suggestion_reply_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    suggestion_id = int(query.data.split('_')[2])
    
    context.user_data['suggestion_id'] = suggestion_id
    
    await query.message.reply_text("✍️ Напишите ответ на предложение:", reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True))
    
    return AWAITING_SUGGESTION_REPLY

async def handle_poll_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    answer = update.poll_answer
    user_id = answer.user.id
    poll_id = answer.poll_id
    option_id = answer.option_ids[0]
    
    poll_data = get_poll_by_telegram_id(poll_id)
    if not poll_data:
        print(f"ОШИБКА: Ответ на неизвестный опрос. ID опроса: {poll_id}")
        return

    add_poll_answer(poll_id, user_id, option_id)
    
    creator_id = poll_data['creator_id']
    all_answers = get_poll_answers(poll_id)
    
    results = collections.defaultdict(int)
    for ans in all_answers:
        results[ans['option_id']] += 1
        
    total_votes = sum(results.values())
    
    result_text = f"📊 **Результаты опроса:**\n\n**{poll_data['question']}**\n"
    for i, option in enumerate(poll_data['options']):
        votes = results[i]
        percent = (votes / total_votes) * 100 if total_votes > 0 else 0
        result_text += f"\n- {option}: **{votes}** ({percent:.1f}%)"
    
    try:
        await context.bot.send_message(creator_id, result_text, parse_mode='Markdown')
    except Exception as e:
        print(f"ОШИБКА: Не удалось отправить результаты опроса создателю {creator_id}: {e}")

async def handle_role_fix_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    parts = query.data.split('_')
    user_id = int(parts[2])
    
    if query.from_user.id != user_id:
        await query.edit_message_text("❌ Вы не можете исправить роль другого пользователя.")
        return
    
    user = query.from_user
    add_user(user_id, user.username, user.first_name, user.last_name)
    
    await query.edit_message_text("✅ Ваша роль была обновлена! Теперь у вас должны быть все права.")
    await show_main_menu(update, user_id)

# -------------------- MAIN FUNCTION --------------------

def main():
    init_db()
    
    app = Application.builder().token(BOT_TOKEN).post_init(init_schedule_cache).build()
    
    job_queue = app.job_queue
    job_queue.run_repeating(check_schedule_changes, interval=3600, first=10)
    job_queue.run_daily(send_daily_schedule, time=time(hour=19, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
    job_queue.run_daily(send_morning_schedule, time=time(hour=7, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
    job_queue.run_repeating(check_next_lesson, interval=60, first=10)
    
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('start', start_command),
            MessageHandler(filters.Regex('^📢 Отправить ДЗ$'), ask_homework_details),
            MessageHandler(filters.Regex('^📢 Отправить уведомление$'), ask_notification_details),
            MessageHandler(filters.Regex('^📢 Опрос$'), ask_poll_question),
            MessageHandler(filters.Regex('^🏃 Отправить спортивное уведомление$'), ask_sport_notification_details),
            MessageHandler(filters.Regex('^💡 Предложить идею$'), ask_suggestion_details),
            MessageHandler(filters.Regex('^Удалить$'), delete_menu),
            MessageHandler(filters.Regex('^🎓 Сменить группу$'), ask_user_group),
        ],
        states={
            AWAITING_GROUP: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_group_selection)],
            AWAITING_HOMEWORK: [MessageHandler(filters.TEXT | filters.PHOTO, handle_homework_input)],
            AWAITING_INFO: [MessageHandler(filters.TEXT | filters.PHOTO, handle_notification_input)],
            AWAITING_SPORT: [MessageHandler(filters.TEXT | filters.PHOTO, handle_sport_input)],
            AWAITING_SUGGESTION: [MessageHandler(filters.TEXT | filters.PHOTO, handle_suggestion_input)],
            AWAITING_SUGGESTION_REPLY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_suggestion_reply)],
            AWAITING_POLL_QUESTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_poll_question)],
            AWAITING_POLL_OPTIONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_poll_options)],
            AWAITING_DELETE_MENU: [
                MessageHandler(filters.Regex('^Удалить ДЗ$'), delete_homework_menu),
                MessageHandler(filters.Regex('^Удалить уведомление$'), delete_notification_menu),
                MessageHandler(filters.Regex('^Удалить спортивные уведомления$'), delete_sport_notification_menu),
                MessageHandler(filters.Regex('^Удалить предложения$'), delete_suggestions_menu),
                MessageHandler(filters.Regex('^Удалить пользователя$'), delete_user_menu),
                MessageHandler(filters.Regex('^🔙 Назад$'), cancel_conversation)
            ],
            AWAITING_HOMEWORK_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_hw_')],
            AWAITING_INFO_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_notif_')],
            AWAITING_SPORT_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sport_')],
            AWAITING_USER_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_user_')],
            AWAITING_SUGGESTION_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sugg_')]
        },
        fallbacks=[
            CommandHandler('start', start_command),
            MessageHandler(filters.Regex('^❌ Отмена$'), cancel_conversation)
        ],
        allow_reentry=True
    )
    
    app.add_handler(conv_handler)
    app.add_handler(CallbackQueryHandler(handle_suggestion_reply_callback, pattern='^reply_sugg_'))
    app.add_handler(CallbackQueryHandler(handle_role_fix_callback, pattern='^fix_role_'))
    app.add_handler(PollAnswerHandler(handle_poll_answer))
    app.add_handler(MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO & ~filters.COMMAND, handle_simple_message))
    
    print("ЛОГ: Бот запущен!")
    app.run_polling()

if __name__ == "__main__":
    main()
