import sqlite3
import re
import json
import asyncio
import requests
import os
from datetime import datetime, timedelta, timezone, time
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo, InputMediaDocument
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler, PollHandler
from telegram.constants import ParseMode

# -------------------- CONSTANTS AND SETTINGS --------------------
BOT_TOKEN = "7405848829:AAHxDv0DP_Co512vOvGw_PDsXYDjE4fgOJ0"
YEKATERINBURG_TZ = timezone(timedelta(hours=5))
DEFAULT_GROUP = None

# States for ConversationHandler
AWAITING_HOMEWORK, AWAITING_INFO, AWAITING_SPORT, AWAITING_SUGGESTION, AWAITING_HOMEWORK_DELETE, AWAITING_INFO_DELETE, AWAITING_SPORT_DELETE, AWAITING_USER_DELETE, AWAITING_SUGGESTION_DELETE, AWAITING_GROUP, AWAITING_POLL, AWAITING_SUGGESTION_RESPONSE, AWAITING_BIRTHDAY, AWAITING_GLOBAL_NOTIFICATION, AWAITING_ADD_SPECIAL_USER, AWAITING_USER_RIGHTS = range(16)

# User Roles
ROLE_STUDENT = 'student'
ROLE_PHYSICAL_ORGANIZER = 'physical_organizer'
ROLE_IT_SPECIALIST = 'it_specialist'
ROLE_CUSTOM = 'custom'

# Special Users (ID and username)
DEVELOPER_ID = 1775957387
SPECIAL_USERS = {
    5013216284: {'role': ROLE_IT_SPECIALIST, 'username': '@kimertuzz3', 'name': '–°—Ç–∞—Ä–æ—Å—Ç–∞'},
    DEVELOPER_ID: {'role': ROLE_IT_SPECIALIST, 'username': '@imya_polbzovatela', 'name': '–ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã (–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫)'},
    1610410800: {'role': ROLE_PHYSICAL_ORGANIZER, 'username': '@Dashulyabed', 'name': '–§–∏–∑. –æ—Ä–≥.'}
}

# Dynamic list of groups (will be populated from API)
ALL_GROUPS = []

# Schedule cache
schedule_cache = {}
last_schedule_check = None
groups_cache = []
last_groups_check = None

# Spam protection
user_message_times = {}
user_warnings = {}
user_blocks = {}
SPAM_THRESHOLD = 10
SPAM_WINDOW = 5
BLOCK_DURATIONS = [600, 1800, 3600, 7200, 36000, 180000]

# Media collection for multiple media support
user_media_collections = {}

# -------------------- DATABASE FUNCTIONS --------------------

def init_db():
    """Initializes the database with proper error handling"""
    conn = None
    try:
        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã
        if os.path.exists('bot_data.db'):
            try:
                conn = sqlite3.connect('bot_data.db')
                cur = conn.cursor()
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–ª–æ–Ω–∫–∏ custom_role_name
                cur.execute("PRAGMA table_info(users)")
                columns = [column[1] for column in cur.fetchall()]
                if 'custom_role_name' not in columns:
                    print("–õ–û–ì: –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–∞–∑—ã, –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º...")
                    conn.close()
                    os.remove('bot_data.db')
                    conn = sqlite3.connect('bot_data.db')
                    cur = conn.cursor()
            except Exception as e:
                print(f"–õ–û–ì: –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–∑—ã: {e}")
                if conn:
                    conn.close()
                os.remove('bot_data.db')
                conn = sqlite3.connect('bot_data.db')
                cur = conn.cursor()
        else:
            conn = sqlite3.connect('bot_data.db')
            cur = conn.cursor()
        
        # Users table with all required columns
        cur.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            group_name TEXT,
            role TEXT DEFAULT 'student',
            custom_role_name TEXT,
            can_send_homework BOOLEAN DEFAULT 0,
            can_send_notifications BOOLEAN DEFAULT 0,
            can_send_sport_notifications BOOLEAN DEFAULT 0,
            can_delete_homework BOOLEAN DEFAULT 0,
            can_delete_notifications BOOLEAN DEFAULT 0,
            can_delete_sport_notifications BOOLEAN DEFAULT 0,
            can_delete_suggestions BOOLEAN DEFAULT 0,
            can_create_polls BOOLEAN DEFAULT 0,
            can_manage_users BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        # Homeworks table
        cur.execute('''CREATE TABLE IF NOT EXISTS homeworks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            subject TEXT,
            task TEXT,
            deadline TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Homework media table
        cur.execute('''CREATE TABLE IF NOT EXISTS homework_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            homework_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (homework_id) REFERENCES homeworks (id) ON DELETE CASCADE
        )''')
        
        # Notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (notification_id) REFERENCES notifications (id) ON DELETE CASCADE
        )''')
        
        # Sport notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Sport notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sport_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (sport_notification_id) REFERENCES sport_notifications (id) ON DELETE CASCADE
        )''')
        
        # Suggestions table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )''')
        
        # Suggestion media table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id) ON DELETE CASCADE
        )''')
        
        # Suggestion responses table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_responses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            responder_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id),
            FOREIGN KEY (responder_id) REFERENCES users (user_id)
        )''')
        
        # Polls table
        cur.execute('''CREATE TABLE IF NOT EXISTS polls (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            question TEXT,
            options TEXT,
            group_name TEXT,
            added_by INTEGER,
            message_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Birthdays table
        cur.execute('''CREATE TABLE IF NOT EXISTS birthdays (
            user_id INTEGER PRIMARY KEY,
            birthday_date TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE
        )''')
        
        # Global notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Global notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            global_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (global_notification_id) REFERENCES global_notifications (id) ON DELETE CASCADE
        )''')
        
        conn.commit()
        print("–õ–û–ì: –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
    finally:
        if conn:
            conn.close()

def get_db_connection():
    """Creates a connection to the database"""
    try:
        conn = sqlite3.connect('bot_data.db')
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏: {e}")
        return None

def get_user(user_id):
    """Gets user information"""
    conn = get_db_connection()
    if not conn: return None
    try:
        user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        return user
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        return None
    finally:
        conn.close()

def get_all_users():
    """Gets a list of all users"""
    conn = get_db_connection()
    if not conn: return []
    try:
        users = conn.execute('SELECT user_id, first_name, username, group_name, role, custom_role_name FROM users').fetchall()
        return users
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return []
    finally:
        conn.close()

def add_user(user_id, username, first_name, last_name):
    """Adds a new user to the database or updates existing user"""
    conn = get_db_connection()
    if not conn: return
    try:
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        role = ROLE_STUDENT
        custom_role_name = None
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        if user_id in SPECIAL_USERS:
            role = SPECIAL_USERS[user_id]['role']
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, role, custom_role_name)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, role, custom_role_name))
            print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {first_name} (ID: {user_id}) —Å —Ä–æ–ª—å—é {role}")
        else:
            conn.execute('''UPDATE users 
                         SET username = ?, first_name = ?, last_name = ?, role = ?, custom_role_name = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, role, custom_role_name, user_id))
            print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {first_name} (ID: {user_id}), —Ä–æ–ª—å: {role}")
        
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
    finally:
        conn.close()

def update_user_rights(user_id, rights_data):
    """Updates user rights in the database"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''UPDATE users SET
                     can_send_homework = ?,
                     can_send_notifications = ?,
                     can_send_sport_notifications = ?,
                     can_delete_homework = ?,
                     can_delete_notifications = ?,
                     can_delete_sport_notifications = ?,
                     can_delete_suggestions = ?,
                     can_create_polls = ?,
                     can_manage_users = ?,
                     role = ?,
                     custom_role_name = ?
                     WHERE user_id = ?''',
                     (rights_data.get('can_send_homework', 0),
                      rights_data.get('can_send_notifications', 0),
                      rights_data.get('can_send_sport_notifications', 0),
                      rights_data.get('can_delete_homework', 0),
                      rights_data.get('can_delete_notifications', 0),
                      rights_data.get('can_delete_sport_notifications', 0),
                      rights_data.get('can_delete_suggestions', 0),
                      rights_data.get('can_create_polls', 0),
                      rights_data.get('can_manage_users', 0),
                      rights_data.get('role', ROLE_STUDENT),
                      rights_data.get('custom_role_name', None),
                      user_id))
        conn.commit()
        print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∞–≤: {e}")
        return False
    finally:
        conn.close()

def add_special_user(user_id, username, first_name, last_name, group_name, role_type, custom_name=None):
    """Adds a special user with specific rights"""
    conn = get_db_connection()
    if not conn: return False
    try:
        rights_data = {
            'role': ROLE_CUSTOM,
            'custom_role_name': custom_name
        }
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Ä–æ–ª–∏
        if role_type == 'starosta':
            rights_data.update({
                'can_send_homework': 1,
                'can_send_notifications': 1,
                'can_delete_homework': 1,
                'can_delete_notifications': 1,
                'can_delete_suggestions': 1,
                'can_create_polls': 1,
                'custom_role_name': '–°—Ç–∞—Ä–æ—Å—Ç–∞'
            })
        elif role_type == 'deputy_starosta':
            rights_data.update({
                'can_send_homework': 1,
                'can_send_notifications': 1,
                'can_delete_homework': 1,
                'can_delete_notifications': 1,
                'can_delete_suggestions': 1,
                'can_create_polls': 1,
                'custom_role_name': '–ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã'
            })
        elif role_type == 'physical_organizer':
            rights_data.update({
                'can_send_sport_notifications': 1,
                'can_delete_sport_notifications': 1,
                'can_create_polls': 1,
                'custom_role_name': '–§–∏–∑. –æ—Ä–≥.'
            })
        elif role_type == 'custom':
            rights_data.update({
                'can_send_homework': 1,
                'can_send_notifications': 1,
                'can_send_sport_notifications': 1,
                'can_delete_homework': 1,
                'can_delete_notifications': 1,
                'can_delete_sport_notifications': 1,
                'can_delete_suggestions': 1,
                'can_create_polls': 1,
                'can_manage_users': 1,
                'custom_role_name': custom_name
            })
        
        # –î–æ–±–∞–≤–ª—è–µ–º/–æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, group_name, role, custom_role_name,
                         can_send_homework, can_send_notifications, can_send_sport_notifications,
                         can_delete_homework, can_delete_notifications, can_delete_sport_notifications,
                         can_delete_suggestions, can_create_polls, can_manage_users)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, group_name,
                          rights_data['role'], rights_data['custom_role_name'],
                          rights_data.get('can_send_homework', 0),
                          rights_data.get('can_send_notifications', 0),
                          rights_data.get('can_send_sport_notifications', 0),
                          rights_data.get('can_delete_homework', 0),
                          rights_data.get('can_delete_notifications', 0),
                          rights_data.get('can_delete_sport_notifications', 0),
                          rights_data.get('can_delete_suggestions', 0),
                          rights_data.get('can_create_polls', 0),
                          rights_data.get('can_manage_users', 0)))
        else:
            conn.execute('''UPDATE users SET
                         username = ?, first_name = ?, last_name = ?, group_name = ?, role = ?, custom_role_name = ?,
                         can_send_homework = ?, can_send_notifications = ?, can_send_sport_notifications = ?,
                         can_delete_homework = ?, can_delete_notifications = ?, can_delete_sport_notifications = ?,
                         can_delete_suggestions = ?, can_create_polls = ?, can_manage_users = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, group_name,
                          rights_data['role'], rights_data['custom_role_name'],
                          rights_data.get('can_send_homework', 0),
                          rights_data.get('can_send_notifications', 0),
                          rights_data.get('can_send_sport_notifications', 0),
                          rights_data.get('can_delete_homework', 0),
                          rights_data.get('can_delete_notifications', 0),
                          rights_data.get('can_delete_sport_notifications', 0),
                          rights_data.get('can_delete_suggestions', 0),
                          rights_data.get('can_create_polls', 0),
                          rights_data.get('can_manage_users', 0),
                          user_id))
        
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω/–æ–±–Ω–æ–≤–ª–µ–Ω —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {first_name} (ID: {user_id}) —Å —Ä–æ–ª—å—é {rights_data['custom_role_name']}")
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        return False
    finally:
        conn.close()

def update_user_group(user_id, group_name):
    """Updates the user's group"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('UPDATE users SET group_name = ? WHERE user_id = ?', (group_name, user_id))
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Å–º–µ–Ω–∏–ª –≥—Ä—É–ø–ø—É –Ω–∞ {group_name}")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –≥—Ä—É–ø–ø—ã: {e}")
    finally:
        conn.close()

def set_user_birthday(user_id, birthday_date):
    """Sets or updates user's birthday"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''INSERT OR REPLACE INTO birthdays (user_id, birthday_date)
                     VALUES (?, ?)''', (user_id, birthday_date))
        conn.commit()
        print(f"–õ–û–ì: –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {birthday_date}")
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è: {e}")
        return False
    finally:
        conn.close()

def get_user_birthday(user_id):
    """Gets user's birthday"""
    conn = get_db_connection()
    if not conn: return None
    try:
        result = conn.execute('SELECT birthday_date FROM birthdays WHERE user_id = ?', (user_id,)).fetchone()
        return result['birthday_date'] if result else None
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def get_today_birthdays():
    """Gets all users who have birthday today"""
    conn = get_db_connection()
    if not conn: return []
    try:
        today = datetime.now().strftime('%d.%m')
        birthdays = conn.execute('''SELECT u.user_id, u.first_name, u.username, u.group_name, b.birthday_date 
                                 FROM users u JOIN birthdays b ON u.user_id = b.user_id 
                                 WHERE b.birthday_date LIKE ? AND u.group_name IS NOT NULL''', (f'{today}%',)).fetchall()
        return birthdays
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–Ω–µ–π —Ä–æ–∂–¥–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def get_total_user_count():
    """Gets the total number of users in the database"""
    conn = get_db_connection()
    if not conn: return 0
    try:
        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        return count
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return 0
    finally:
        conn.close()

def delete_homework(hw_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM homeworks WHERE id = ?', (hw_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –î–ó: {e}")
    finally:
        conn.close()

def delete_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def delete_sport_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM sport_notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def delete_user(user_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É–¥–∞–ª–µ–Ω –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
    finally:
        conn.close()

def delete_suggestion(suggestion_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM suggestions WHERE id = ?', (suggestion_id,))
        conn.commit()
        print(f"–õ–û–ì: –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {suggestion_id} —É–¥–∞–ª–µ–Ω–æ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def get_all_sport_notifications():
    """Gets all sport notifications"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     ORDER BY s.created_at DESC''').fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_homework(subject, task, deadline, group_name, added_by):
    """Adds homework to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO homeworks (subject, task, deadline, group_name, added_by)
                     VALUES (?, ?, ?, ?, ?)''', (subject, task, deadline, group_name, added_by))
        homework_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ –î–ó –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
        return homework_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –î–ó: {e}")
        return None
    finally:
        conn.close()

def add_homework_media(homework_id, media_type, media_id, caption=None):
    """Adds media to homework"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO homework_media (homework_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (homework_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ –î–ó: {e}")
    finally:
        conn.close()

def get_homeworks(group_name):
    """Gets homework for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        homeworks = conn.execute('''SELECT h.*, u.first_name 
                                 FROM homeworks h JOIN users u ON h.added_by = u.user_id 
                                 WHERE h.group_name = ? ORDER BY h.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for hw in homeworks:
            hw_dict = dict(hw)
            media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (hw_dict['id'],)).fetchall()
            hw_dict['media'] = [dict(m) for m in media]
            result.append(hw_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –î–ó: {e}")
        return []
    finally:
        conn.close()

def add_notification(message, group_name, added_by):
    """Adds a notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        notification_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
        return notification_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_notification_media(notification_id, media_type, media_id, caption=None):
    """Adds media to notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO notification_media (notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

def get_notifications(group_name):
    """Gets notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT n.*, u.first_name 
                                     FROM notifications n JOIN users u ON n.added_by = u.user_id 
                                     WHERE n.group_name = ? ORDER BY n.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for notif in notifications:
            notif_dict = dict(notif)
            media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notif_dict['id'],)).fetchall()
            notif_dict['media'] = [dict(m) for m in media]
            result.append(notif_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_sport_notification(message, group_name, added_by):
    """Adds a sport notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO sport_notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        sport_notification_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
        return sport_notification_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_sport_notification_media(sport_notification_id, media_type, media_id, caption=None):
    """Adds media to sport notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO sport_notification_media (sport_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (sport_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

def get_sport_notifications(group_name):
    """Gets sport notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     WHERE s.group_name = ? ORDER BY s.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for sport in notifications:
            sport_dict = dict(sport)
            media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_dict['id'],)).fetchall()
            sport_dict['media'] = [dict(m) for m in media]
            result.append(sport_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_suggestion(user_id, message):
    """Adds a suggestion to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO suggestions (user_id, message) VALUES (?, ?)', (user_id, message))
        suggestion_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –æ—Ç–ø—Ä–∞–≤–∏–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
        return suggestion_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_suggestion_media(suggestion_id, media_type, media_id, caption=None):
    """Adds media to suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_media (suggestion_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (suggestion_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

def add_suggestion_response(suggestion_id, responder_id, message):
    """Adds a response to a suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_responses (suggestion_id, responder_id, message)
                     VALUES (?, ?, ?)''', (suggestion_id, responder_id, message))
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {suggestion_id}.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ: {e}")
    finally:
        conn.close()

def get_suggestions():
    """Gets all suggestions"""
    conn = get_db_connection()
    if not conn: return []
    try:
        suggestions = conn.execute('''SELECT s.*, u.first_name, u.username 
                                   FROM suggestions s JOIN users u ON s.user_id = u.user_id 
                                   ORDER BY s.created_at DESC''').fetchall()
        
        result = []
        for s in suggestions:
            s_dict = dict(s)
            media = conn.execute('SELECT * FROM suggestion_media WHERE suggestion_id = ?', (s_dict['id'],)).fetchall()
            s_dict['media'] = [dict(m) for m in media]
            
            responses = conn.execute('''SELECT sr.*, u.first_name, u.username 
                                    FROM suggestion_responses sr JOIN users u ON sr.responder_id = u.user_id 
                                    WHERE sr.suggestion_id = ? ORDER BY sr.created_at''', (s_dict['id'],)).fetchall()
            s_dict['responses'] = [dict(r) for r in responses]
            
            result.append(s_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_poll(question, options, group_name, added_by, message_id):
    """Adds a poll to the database"""
    conn = get_db_connection()
    if not conn: return
    try:
        options_json = json.dumps(options)
        conn.execute('''INSERT INTO polls (question, options, group_name, added_by, message_id)
                     VALUES (?, ?, ?, ?, ?)''', (question, options_json, group_name, added_by, message_id))
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω –æ–ø—Ä–æ—Å –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –æ–ø—Ä–æ—Å–∞: {e}")
    finally:
        conn.close()

def add_global_notification(message, added_by):
    """Adds a global notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO global_notifications (message, added_by) VALUES (?, ?)', (message, added_by))
        global_notification_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ –≥–ª–æ–±–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.")
        return global_notification_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_global_notification_media(global_notification_id, media_type, media_id, caption=None):
    """Adds media to global notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO global_notification_media (global_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (global_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

# -------------------- SPAM PROTECTION --------------------

def check_spam(user_id):
    """Checks if user is spamming"""
    now = datetime.now().timestamp()
    
    if user_id in user_blocks and now < user_blocks[user_id]:
        return True, user_blocks[user_id] - now
    
    if user_id not in user_message_times:
        user_message_times[user_id] = []
        user_warnings[user_id] = 0
    
    user_message_times[user_id].append(now)
    user_message_times[user_id] = [t for t in user_message_times[user_id] if now - t < SPAM_WINDOW]
    
    if len(user_message_times[user_id]) >= SPAM_THRESHOLD:
        user_warnings[user_id] += 1
        warning_count = user_warnings[user_id]
        
        if warning_count - 1 < len(BLOCK_DURATIONS):
            block_duration = BLOCK_DURATIONS[warning_count - 1]
        else:
            block_duration = BLOCK_DURATIONS[-1]
        
        user_blocks[user_id] = now + block_duration
        user_message_times[user_id] = []
        return True, block_duration
    
    return False, 0

async def warn_user(update: Update, block_duration: int):
    """Warns user about spam"""
    minutes = block_duration // 60
    await update.message.reply_text(
        f"‚ö†Ô∏è –ù–µ —Å–ø–∞–º—å—Ç–µ! –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n"
        f"–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ {minutes} –º–∏–Ω—É—Ç."
    )

# -------------------- MEDIA COLLECTION FUNCTIONS --------------------

def init_user_media_collection(user_id):
    """Initializes media collection for a user"""
    if user_id not in user_media_collections:
        user_media_collections[user_id] = {
            'homework': [],
            'notification': [],
            'sport': [],
            'suggestion': [],
            'global_notification': []
        }

def add_to_media_collection(user_id, media_type, media_data):
    """Adds media to user's collection"""
    init_user_media_collection(user_id)
    user_media_collections[user_id][media_type].append(media_data)

def clear_media_collection(user_id, media_type):
    """Clears user's media collection"""
    if user_id in user_media_collections:
        user_media_collections[user_id][media_type] = []

def get_media_collection(user_id, media_type):
    """Gets user's media collection"""
    init_user_media_collection(user_id)
    return user_media_collections[user_id][media_type]

# -------------------- USER RIGHTS CHECK FUNCTIONS --------------------

def can_send_homework(user_id):
    """Checks if user can send homework"""
    user = get_user(user_id)
    if not user: return False
    return user['can_send_homework'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_send_notifications(user_id):
    """Checks if user can send notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_send_notifications'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_send_sport_notifications(user_id):
    """Checks if user can send sport notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_send_sport_notifications'] == 1 or user['role'] == ROLE_PHYSICAL_ORGANIZER or user_id == DEVELOPER_ID

def can_delete_homework(user_id):
    """Checks if user can delete homework"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_homework'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_delete_notifications(user_id):
    """Checks if user can delete notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_notifications'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_delete_sport_notifications(user_id):
    """Checks if user can delete sport notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_sport_notifications'] == 1 or user['role'] == ROLE_PHYSICAL_ORGANIZER or user_id == DEVELOPER_ID

def can_delete_suggestions(user_id):
    """Checks if user can delete suggestions"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_suggestions'] == 1 or user['role'] in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER] or user_id == DEVELOPER_ID

def can_create_polls(user_id):
    """Checks if user can create polls"""
    user = get_user(user_id)
    if not user: return False
    return user['can_create_polls'] == 1 or user['role'] in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER] or user_id == DEVELOPER_ID

def can_manage_users(user_id):
    """Checks if user can manage users"""
    user = get_user(user_id)
    if not user: return False
    return user['can_manage_users'] == 1 or user_id == DEVELOPER_ID

# -------------------- UPDATED SCHEDULE FUNCTIONS --------------------

def fetch_schedule_data():
    """Fetches schedule data from the new API endpoint"""
    try:
        url = "https://ops.pmk-online.ru/schedule/request.php?token=Uf40-ZZkp-t5Nv-ZD5v"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        print("–õ–û–ì: –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è —Å API...")
        resp = requests.get(url, headers=headers, timeout=15)
        resp.raise_for_status()
        data = resp.json()

        print(f"–õ–û–ì: –£—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ó–∞–Ω—è—Ç–∏–π: {len(data)}")
        return data
    except requests.exceptions.RequestException as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None

def fetch_groups_list():
    """Fetches and updates the list of groups from schedule data"""
    global ALL_GROUPS, groups_cache, last_groups_check
    
    try:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return ALL_GROUPS
        
        # Extract unique groups from schedule data
        groups = set()
        for lesson in schedule_data:
            if 'group' in lesson:
                groups.add(lesson['group'])
        
        # Sort groups by course and number
        def group_sort_key(group_name):
            try:
                # Extract course number (first digit after dash)
                parts = group_name.split('-')
                if len(parts) > 1:
                    number_part = parts[1]
                    # Find first digit in number part
                    for char in number_part:
                        if char.isdigit():
                            course = int(char)
                            return (course, group_name)
            except:
                pass
            return (0, group_name)
        
        sorted_groups = sorted(groups, key=group_sort_key)
        ALL_GROUPS = sorted_groups
        groups_cache = sorted_groups
        last_groups_check = datetime.now(YEKATERINBURG_TZ)
        
        print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª–µ–Ω —Å–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø. –í—Å–µ–≥–æ –≥—Ä—É–ø–ø: {len(ALL_GROUPS)}")
        return ALL_GROUPS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –≥—Ä—É–ø–ø: {e}")
        return ALL_GROUPS

def parse_lesson_data(lesson):
    """Parses lesson data from the new API format"""
    try:
        if not isinstance(lesson, dict):
            return None
            
        lesson_data = {}
        
        # Basic lesson information
        lesson_data['group'] = lesson.get('group', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')
        lesson_data['number'] = lesson.get('number', 0)
        lesson_data['type'] = lesson.get('type', '–ó–∞–Ω—è—Ç–∏–µ')
        lesson_data['subject'] = lesson.get('subject', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
        lesson_data['campus'] = lesson.get('campus', '–ù–µ —É–∫–∞–∑–∞–Ω')
        lesson_data['room'] = lesson.get('room', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')
        lesson_data['teacher'] = lesson.get('teacher', '–ù–µ —É–∫–∞–∑–∞–Ω')
        
        # Parse dates and convert to Yekaterinburg timezone
        start_time_str = lesson.get('startTime', '')
        end_time_str = lesson.get('endTime', '')
        
        if start_time_str:
            try:
                start_time_utc = datetime.fromisoformat(start_time_str.replace('Z', '+00:00'))
                start_time_yekat = start_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['date'] = start_time_yekat.strftime('%Y-%m-%d')
                lesson_data['start_time'] = start_time_yekat.strftime('%H:%M')
                lesson_data['datetime'] = start_time_yekat
            except:
                lesson_data['date'] = '–ù–µ —É–∫–∞–∑–∞–Ω–∞'
                lesson_data['start_time'] = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
        
        if end_time_str:
            try:
                end_time_utc = datetime.fromisoformat(end_time_str.replace('Z', '+00:00'))
                end_time_yekat = end_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['end_time'] = end_time_yekat.strftime('%H:%M')
            except:
                lesson_data['end_time'] = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
        
        return lesson_data
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞–Ω—è—Ç–∏—è: {e}")
        return None

def filter_lessons_by_date(lessons, target_date):
    """Filters lessons for a specific date"""
    try:
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if lesson_date == target_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–Ω—è—Ç–∏–π: {e}")
        return []

def filter_lessons_by_week(lessons, start_date):
    """Filters lessons for a week starting from start_date"""
    try:
        end_date = start_date + timedelta(days=7)
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if start_date <= lesson_date <= end_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–Ω—è—Ç–∏–π –Ω–∞ –Ω–µ–¥–µ–ª—é: {e}")
        return []

def get_type_emoji(lesson_type):
    """Returns emoji for lesson type"""
    emoji_map = {
        '–ó–∞–Ω—è—Ç–∏–µ': 'üìö',
        '–ü—Ä–∞–∫—Ç–∏–∫–∞': 'üî¨', 
        '–õ–µ–∫—Ü–∏—è': 'üìñ',
        '–≠–∫–∑–∞–º–µ–Ω': 'üìù',
        '–ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è': 'üí¨',
        '–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞': '‚öóÔ∏è',
        '–°–µ–º–∏–Ω–∞—Ä': 'üí°',
        '–ó–∞—á–µ—Ç': '‚úÖ'
    }
    return emoji_map.get(lesson_type, 'üìö')

def format_schedule(lessons, title):
    """Formats schedule for display with the new format"""
    try:
        if not lessons:
            return f"‚úÖ –ù–µ—Ç –∑–∞–Ω—è—Ç–∏–π –¥–ª—è {title.split('(')[-1].split(')')[0]}"
        
        # Sort lessons by date and time
        lessons.sort(key=lambda x: (x.get('datetime', datetime.min), x.get('number', 0)))
        
        result = [f"<b>{title}</b>\n"]
        current_date = None
        
        for lesson in lessons:
            try:
                if 'datetime' in lesson:
                    date_str = lesson['datetime'].strftime('%d.%m.%Y')
                    day_names = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
                    day_of_week = day_names[lesson['datetime'].weekday()]
                    
                    if date_str != current_date:
                        current_date = date_str
                        result.append(f"\nüìÖ <b>{date_str} ({day_of_week})</b>")
                    
                    type_emoji = get_type_emoji(lesson['type'])
                    start_time = lesson.get('start_time', '‚ùì')
                    end_time = lesson.get('end_time', '‚ùì')
                    
                    lesson_text = (
                        f"    {type_emoji} {lesson['type']}\n"
                        f"    ‚è∞ {start_time}-{end_time} | {lesson['number']} –ø–∞—Ä–∞\n"
                        f"    üìö {lesson['subject']}\n"
                        f"    üë®‚Äçüè´ {lesson['teacher']}\n"
                        f"    üö™ {lesson['room']}({lesson['campus']})\n"
                    )
                    result.append(lesson_text)
            except Exception as e:
                print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—É: {e}")
                continue
        
        result.append(f"\nüìä <b>–í—Å–µ–≥–æ –∑–∞–Ω—è—Ç–∏–π:</b> {len(lessons)}")
        return "\n".join(result)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {str(e)}"

def get_schedule(period, group_name):
    """Gets and formats the schedule with the new API"""
    try:
        global schedule_cache, last_schedule_check
        
        # Check cache
        now = datetime.now(YEKATERINBURG_TZ)
        if last_schedule_check is None or (now - last_schedule_check).total_seconds() > 3600:
            print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}")
            schedule_data = fetch_schedule_data()
            if schedule_data:
                schedule_cache = schedule_data
                last_schedule_check = now
                print("–õ–û–ì: –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –∏–∑ API")
            else:
                print("–õ–û–ì: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à –µ—Å–ª–∏ –µ—Å—Ç—å")
        else:
            schedule_data = schedule_cache
            print("–õ–û–ì: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
        
        if not schedule_data:
            return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        
        # Filter lessons for the specific group
        group_lessons = [lesson for lesson in schedule_data if lesson.get('group') == group_name]
        
        if not group_lessons:
            return f"‚ùå –ù–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}"
        
        # Filter lessons by period
        today_yekat = datetime.now(YEKATERINBURG_TZ).date()
        
        if period == 'üìÖ –°–µ–≥–æ–¥–Ω—è':
            filtered_lessons = filter_lessons_by_date(group_lessons, today_yekat)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ({group_name})"
        elif period == 'üìÖ –ó–∞–≤—Ç—Ä–∞':
            tomorrow_yekat = today_yekat + timedelta(days=1)
            filtered_lessons = filter_lessons_by_date(group_lessons, tomorrow_yekat)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({group_name})"
        elif period == 'üìÖ –ù–µ–¥–µ–ª—è':
            filtered_lessons = filter_lessons_by_week(group_lessons, today_yekat)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é ({group_name})"
        else:
            # For "–í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ" parse all lessons
            filtered_lessons = []
            for lesson in group_lessons:
                parsed = parse_lesson_data(lesson)
                if parsed:
                    filtered_lessons.append(parsed)
            title = f"üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ ({group_name})"
        
        return format_schedule(filtered_lessons, title)
        
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {str(e)}")
        return f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {str(e)}"

async def check_schedule_changes(context: ContextTypes.DEFAULT_TYPE):
    """Checks for schedule changes with the new API"""
    global schedule_cache, last_schedule_check
    
    print("–õ–û–ì: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏...")
    new_schedule = fetch_schedule_data()
    
    if not new_schedule:
        print("–õ–û–ì: –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è")
        return

    # Extract groups from new schedule
    new_groups = set()
    for lesson in new_schedule:
        if 'group' in lesson:
            new_groups.add(lesson['group'])
    
    # Compare with old groups
    old_groups = set()
    for lesson in schedule_cache:
        if 'group' in lesson:
            old_groups.add(lesson['group'])
    
    # Check for new or removed groups
    added_groups = new_groups - old_groups
    removed_groups = old_groups - new_groups
    
    if added_groups or removed_groups:
        print(f"–õ–û–ì: –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø–∞—Ö")
        
        for group_name in added_groups:
            change_message = f"üîÑ <b>–î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è –≥—Ä—É–ø–ø–∞: {group_name}</b>\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É' –¥–ª—è –≤—ã–±–æ—Ä–∞ —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã."
            
            # Notify special users about new group
            special_users = [u for u in get_all_users() if u['user_id'] in SPECIAL_USERS or u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")
        
        for group_name in removed_groups:
            change_message = f"üîÑ <b>–ì—Ä—É–ø–ø–∞ {group_name} —É–¥–∞–ª–µ–Ω–∞ –∏–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è</b>\n\n–£—á–µ–Ω–∏–∫–∏ —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã –º–æ–≥—É—Ç –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –≥—Ä—É–ø–ø—É."
            
            # Notify special users about removed group
            special_users = [u for u in get_all_users() if u['user_id'] in SPECIAL_USERS or u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

    schedule_cache = new_schedule
    last_schedule_check = datetime.now(YEKATERINBURG_TZ)

async def send_daily_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends daily schedule at 19:00 with the new API"""
    print("–õ–û–ì: –û—Ç–ø—Ä–∞–≤–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        tomorrow_yekat = (datetime.now(YEKATERINBURG_TZ) + timedelta(days=1)).date()
        tomorrow_lessons = filter_lessons_by_date(lessons, tomorrow_yekat)
        
        if tomorrow_lessons:
            schedule_text = format_schedule(tomorrow_lessons, f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({group_name})")
            
            homeworks = get_homeworks(group_name)
            if homeworks:
                homework_text = "\n\nüìù <b>–î–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:</b>\n"
                for hw in homeworks[:3]:
                    homework_text += f"‚Ä¢ {hw['subject']}: {hw['task']} (–¥–æ {hw['deadline']})\n"
                schedule_text += homework_text
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_morning_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends morning schedule at 07:00 with the new API"""
    print("–õ–û–ì: –û—Ç–ø—Ä–∞–≤–∫–∞ —É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        today_lessons = filter_lessons_by_date(lessons, datetime.now(YEKATERINBURG_TZ).date())
        
        if today_lessons:
            schedule_text = format_schedule(today_lessons, f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ({group_name})")
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

# -------------------- BIRTHDAY FUNCTIONS --------------------

async def ask_birthday_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks user to input birthday date"""
    user_id = update.effective_user.id
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    user_data = get_user(user_id)
    if not user_data or not user_data['group_name']:
        await update.message.reply_text("‚ùå –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ—é –≥—Ä—É–ø–ø—É!")
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    await update.message.reply_text(
        "üéÇ <b>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è</b>\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Å–≤–æ–µ–≥–æ —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>–î–î.–ú–ú</b>\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: 15.09 (–¥–ª—è 15 —Å–µ–Ω—Ç—è–±—Ä—è)\n\n"
        "–ë–æ—Ç –±—É–¥–µ—Ç –ø–æ–∑–¥—Ä–∞–≤–ª—è—Ç—å –≤–∞—Å –≤ –≤–∞—à –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è –∏ —É–≤–µ–¥–æ–º–ª—è—Ç—å –≤–∞—à—É –≥—Ä—É–ø–ø—É!",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
    )
    return AWAITING_BIRTHDAY

async def handle_birthday_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles birthday date input"""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    if text == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)
    
    try:
        if not re.match(r'^\d{1,2}\.\d{1,2}$', text):
            raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç")
        
        day, month = text.split('.')
        day = int(day)
        month = int(month)
        
        if month < 1 or month > 12:
            raise ValueError("–ú–µ—Å—è—Ü –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 1 –¥–æ 12")
        if day < 1 or day > 31:
            raise ValueError("–î–µ–Ω—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 1 –¥–æ 31")
        
        if month == 2 and day > 29:
            raise ValueError("–í —Ñ–µ–≤—Ä–∞–ª–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ 29 –¥–Ω–µ–π")
        elif month in [4, 6, 9, 11] and day > 30:
            raise ValueError("–í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ 30 –¥–Ω–µ–π")
            
        birthday_date = f"{day:02d}.{month:02d}"
        
        if set_user_birthday(user_id, birthday_date):
            await update.message.reply_text(
                f"‚úÖ –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {birthday_date}\n"
                f"–¢–µ–ø–µ—Ä—å –±–æ—Ç –±—É–¥–µ—Ç –ø–æ–∑–¥—Ä–∞–≤–ª—è—Ç—å –≤–∞—Å –∫–∞–∂–¥—ã–π –≥–æ–¥!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è")
            
    except ValueError as e:
        await update.message.reply_text(
            f"‚ùå {str(e)}. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>–î–î.–ú–ú</b>\n"
            "–ü—Ä–∏–º–µ—Ä: 15.09 (–¥–ª—è 15 —Å–µ–Ω—Ç—è–±—Ä—è)",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    except Exception as e:
        await update.message.reply_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def check_birthdays(context: ContextTypes.DEFAULT_TYPE):
    """Checks for birthdays and sends notifications"""
    print("–õ–û–ì: –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–π —Ä–æ–∂–¥–µ–Ω–∏–π...")
    
    today_birthdays = get_today_birthdays()
    
    for birthday_user in today_birthdays:
        user_id = birthday_user['user_id']
        user_name = birthday_user['first_name']
        username = f"@{birthday_user['username']}" if birthday_user['username'] else user_name
        group_name = birthday_user['group_name']
        
        try:
            await context.bot.send_message(
                user_id,
                f"üéÇ <b>–° –î–ù–ï–ú –†–û–ñ–î–ï–ù–ò–Ø, {user_name}!</b>\n\n"
                f"–ñ–µ–ª–∞–µ–º –≤–∞–º –≤—Å–µ–≥–æ —Å–∞–º–æ–≥–æ –ª—É—á—à–µ–≥–æ! üéâ",
                parse_mode='HTML'
            )
            print(f"–õ–û–ì: –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
        
        users_in_group = get_db_connection().execute(
            'SELECT user_id FROM users WHERE group_name = ? AND user_id != ?', 
            (group_name, user_id)
        ).fetchall()
        
        for group_user in users_in_group:
            try:
                await context.bot.send_message(
                    group_user['user_id'],
                    f"üéâ –£ {user_name} ({username}) —Å–µ–≥–æ–¥–Ω—è –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è!\n\n"
                    f"–ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø–æ–∑–¥—Ä–∞–≤–∏—Ç—å! üòä",
                    parse_mode='HTML'
                )
            except Exception as e:
                print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {group_user['user_id']}: {e}")
    
    if today_birthdays:
        print(f"–õ–û–ì: –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {len(today_birthdays)} –¥–Ω–µ–π —Ä–æ–∂–¥–µ–Ω–∏–π")

# -------------------- GLOBAL NOTIFICATION FUNCTIONS --------------------

async def ask_global_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for global notification details (only for developer)"""
    user_id = update.effective_user.id
    
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return ConversationHandler.END
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    clear_media_collection(user_id, 'global_notification')
    
    await update.message.reply_text(
        "üåç <b>–û—Ç–ø—Ä–∞–≤–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º</b>\n\n"
        "–ù–∞–ø–∏—à–∏ –≤–∞–∂–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –í–°–ï–ú —É—á–µ–Ω–∏–∫–∞–º –í–°–ï–• –≥—Ä—É–ø–ø.\n"
        "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
    )
    return AWAITING_GLOBAL_NOTIFICATION

async def handle_global_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles global notification input"""
    user_id = update.effective_user.id
    
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return await cancel_conversation(update, context)
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return AWAITING_GLOBAL_NOTIFICATION
    
    text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
    
    if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)
    
    if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
        media_collection = get_media_collection(user_id, 'global_notification')
        notification_text = context.user_data.get('global_notification_text', '')
        
        if not notification_text:
            await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
            return AWAITING_GLOBAL_NOTIFICATION

        global_notification_id = add_global_notification(notification_text, user_id)
        
        if global_notification_id:
            for media_item in media_collection:
                add_global_notification_media(global_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            await update.message.reply_text("‚úÖ –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
            await send_global_notification_to_all(context.bot, global_notification_id, notification_text, user_id)
            
            clear_media_collection(user_id, 'global_notification')
            context.user_data.pop('global_notification_text', None)
        else:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    if update.message.photo:
        photo = update.message.photo[-1]
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'photo',
            'id': photo.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.video:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'video',
            'id': update.message.video.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.document:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'document',
            'id': update.message.document.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    if text and text.strip():
        context.user_data['global_notification_text'] = text
        await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
    return AWAITING_GLOBAL_NOTIFICATION

async def send_global_notification_to_all(bot, global_notification_id, message, added_by):
    """Sends a global notification to all users"""
    global_text = (
        f"üåç <b>–í–ê–ñ–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï –û–¢ –†–ê–ó–†–ê–ë–û–¢–ß–ò–ö–ê</b>\n\n"
        f"{message}\n\n"
        f"üë§ <b>–û—Ç:</b> –ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã (–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫)"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM global_notification_media WHERE global_notification_id = ?', (global_notification_id,)).fetchall()
    conn.close()
    
    users = get_all_users()
    
    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=global_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=global_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=global_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=global_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=global_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=global_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], global_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

# -------------------- CORE BOT FUNCTIONS --------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for the /start command with dynamic groups"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        add_user(user_id, user.username, user.first_name, user.last_name)
        user_data = get_user(user_id)
        
        # Update groups list
        fetch_groups_list()
        
        if not user_data or not user_data['group_name'] or user_data['group_name'] not in ALL_GROUPS:
            print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user_id}) –Ω–µ –∏–º–µ–µ—Ç –≥—Ä—É–ø–ø—ã, –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –≤—ã–±–æ—Ä –≥—Ä—É–ø–ø—ã.")
            return await ask_user_group(update, context)

        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user.id}) –≤–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.")
        
        if user_id in SPECIAL_USERS and user_data['role'] != SPECIAL_USERS[user_id]['role']:
            keyboard = [[InlineKeyboardButton("üîÑ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ä–æ–ª—å", callback_data=f"fix_role_{user_id}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(
                "‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–æ–ª–∏. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å:",
                reply_markup=reply_markup
            )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ start_command: {e}")
        try:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def ask_user_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks the user to select their group with dynamic list"""
    try:
        # Update groups list from API
        groups = fetch_groups_list()
        if not groups:
            await update.message.reply_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                reply_markup=ReplyKeyboardRemove()
            )
            return ConversationHandler.END
        
        # Create keyboard with groups
        keyboard = [groups[i:i+3] for i in range(0, len(groups), 3)]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
        
        message_source = update.callback_query.message if update.callback_query else update.message
        await message_source.reply_text(
            "üëã –í—ã–±–µ—Ä–∏ —Å–≤–æ—é –≥—Ä—É–ø–ø—É:",
            reply_markup=reply_markup
        )
        
        return AWAITING_GROUP
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_user_group: {e}")
        return ConversationHandler.END

async def handle_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the user's group selection with dynamic list"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_GROUP
        
        group_name = update.message.text
        
        # Update groups list to ensure we have the latest
        current_groups = fetch_groups_list()
        
        if group_name not in current_groups:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –≥—Ä—É–ø–ø—É –∏–∑ —Å–ø–∏—Å–∫–∞:",
                reply_markup=ReplyKeyboardMarkup([current_groups[i:i+3] for i in range(0, len(current_groups), 3)], 
                                               resize_keyboard=True, one_time_keyboard=True)
            )
            return AWAITING_GROUP
        
        update_user_group(user_id, group_name)
        
        await update.message.reply_text(
            f"‚úÖ –ì—Ä—É–ø–ø–∞ {group_name} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!",
            reply_markup=ReplyKeyboardRemove()
        )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_group_selection: {e}")
        return ConversationHandler.END

async def show_main_menu(update: Update, user_id: int):
    """Displays the main menu based on user rights with error handling"""
    try:
        user_data = get_user(user_id)
        if not user_data:
            await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /start –µ—â–µ —Ä–∞–∑.")
            return

        role = user_data['role']
        custom_role = user_data['custom_role_name']
        
        welcome_text = "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!"
        
        if custom_role:
            welcome_text = f"üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {custom_role}!"
        elif user_id in SPECIAL_USERS:
            welcome_text = f"üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {SPECIAL_USERS[user_id]['name']}!"
        elif role == ROLE_IT_SPECIALIST:
            welcome_text = "üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –ê–π—Ç–∏—à–Ω–∏–∫!"
        elif role == ROLE_PHYSICAL_ORGANIZER:
            welcome_text = "üèÉ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –§–∏–∑. –æ—Ä–≥.!"

        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∞–≤
        if user_id == DEVELOPER_ID:
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó', 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', 'üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º'],
                ['–£–¥–∞–ª–∏—Ç—å –î–ó', '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è'],
                ['–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', '–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', '–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤', 'üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É'],
                ['üëë –î–æ–±–∞–≤–∏—Ç—å —Å–ø–µ—Ü –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏']
            ]
        elif can_manage_users(user_id):
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó', 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ'],
                ['–£–¥–∞–ª–∏—Ç—å –î–ó', '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è'],
                ['–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', '–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤', 'üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É'],
                ['üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏']
            ]
        elif can_send_homework(user_id) and can_send_notifications(user_id):
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó', 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ'],
                ['–£–¥–∞–ª–∏—Ç—å –î–ó', '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤', 'üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É']
            ]
        elif can_send_sport_notifications(user_id):
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üèÉ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤', 'üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É']
            ]
        else:
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
                ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π', 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã'],
                ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ñ–∏–∑–æ—Ä–≥–æ–º'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É']
            ]
        
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        
        message_source = update.callback_query.message if update.callback_query else update.message
        await message_source.reply_text(welcome_text, reply_markup=reply_markup)
        
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_main_menu: {e}")
        try:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–µ–Ω—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /start",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels the current conversation"""
    try:
        user = update.effective_user
        user_id = user.id
        
        await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ cancel_conversation: {e}")
        return ConversationHandler.END

async def handle_simple_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for simple text messages with error handling"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        text = update.message.text
        user_data = get_user(user_id)
        
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user_id}) –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ: '{text}'")
        
        if not user_data or not user_data['group_name'] or user_data['group_name'] not in ALL_GROUPS:
            add_user(user_id, user.username, user.first_name, user.last_name)
            return await ask_user_group(update, context)

        role = user_data['role']
        group_name = user_data['group_name']
        
        if text == 'üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ':
            await show_schedule_periods(update, user_id)
        
        elif text == 'üìù –î–ó':
            await show_homework(update, group_name)
        
        elif text == '‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è':
            await show_information(update, group_name, role)

        elif text == 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è' and can_delete_suggestions(user_id):
            await show_suggestions(update)
        
        elif text == '–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await show_users_list(update)

        elif text == 'üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É':
            donate_text = "–ï—Å–ª–∏ –Ω–µ –∂–∞–ª–∫–æ, –º–æ–∂–µ—à—å –¥–∞—Ç—å —Ä–∞–∑—Ä–∞–±—É –±–æ—Ç–∞ –¥–µ–Ω—é–∂–∫—É –Ω–∞ –¥–∞–ª—å–Ω–µ–π—à–µ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ –±–æ—Ç–∞ –∏ –Ω–∞ –ø–æ–∫—É—à–∞—Ç—åüòä"
            keyboard = [[InlineKeyboardButton("üí∏ –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å –∞–≤—Ç–æ—Ä–∞", url="https://www.donationalerts.com/r/ax_hikitka")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(donate_text, reply_markup=reply_markup)

        elif text == 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤':
            await show_call_schedule(update)
        
        elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ñ–∏–∑–æ—Ä–≥–æ–º':
            await contact_physical_organizer(update)
        
        elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π':
            await contact_starosta(update)

        elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã':
            await contact_deputy_starosta(update)
        
        elif text in ['üìÖ –°–µ–≥–æ–¥–Ω—è', 'üìÖ –ó–∞–≤—Ç—Ä–∞', 'üìÖ –ù–µ–¥–µ–ª—è', 'üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ']:
            await handle_schedule_period(update, context, group_name)
    
        elif text == 'üîô –ù–∞–∑–∞–¥':
            await show_main_menu(update, user_id)

        elif text == '–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' and user_id == DEVELOPER_ID:
            await delete_user_menu(update, context)

        elif text == '–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è' and can_delete_sport_notifications(user_id):
            await delete_sport_notification_menu(update, context)
            
        elif text == '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è' and can_delete_suggestions(user_id):
            await delete_suggestions_menu(update, context)
            
        elif text == '–£–¥–∞–ª–∏—Ç—å –î–ó' and can_delete_homework(user_id):
            await delete_homework_menu(update, context)

        elif text == '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ' and can_delete_notifications(user_id):
            await delete_notification_menu(update, context)
            
        elif text == 'üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å' and can_create_polls(user_id):
            await ask_poll_details(update, context)
        
        elif text == 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó' and can_send_homework(user_id):
            await ask_homework_details(update, context)
        
        elif text == 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ' and can_send_notifications(user_id):
            await ask_notification_details(update, context)
            
        elif text == 'üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º' and user_id == DEVELOPER_ID:
            await ask_global_notification_details(update, context)
        
        elif text == 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é':
            await ask_suggestion_details(update, context)
        
        elif text == 'üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è':
            await ask_birthday_date(update, context)
        
        elif text == 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É':
            return await ask_user_group(update, context)
            
        elif text == 'üëë –î–æ–±–∞–≤–∏—Ç—å —Å–ø–µ—Ü –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' and user_id == DEVELOPER_ID:
            await add_special_user_menu(update, context)
            
        elif text == 'üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await manage_user_rights_menu(update, context)

        else:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ üëá")
    
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_simple_message: {e}")
        try:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

# -------------------- SCHEDULE DISPLAY FUNCTIONS --------------------

async def show_schedule_periods(update: Update, user_id: int):
    """Shows the schedule period selection"""
    try:
        keyboard = [
            ['üìÖ –°–µ–≥–æ–¥–Ω—è', 'üìÖ –ó–∞–≤—Ç—Ä–∞'],
            ['üìÖ –ù–µ–¥–µ–ª—è', 'üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ'],
            ['üîô –ù–∞–∑–∞–¥']
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text("–í—ã–±–µ—Ä–∏ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è:", reply_markup=reply_markup)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_schedule_periods: {e}")

async def handle_schedule_period(update: Update, context: ContextTypes.DEFAULT_TYPE, group_name: str):
    """Handles the schedule period selection with error handling"""
    try:
        text = update.message.text
        await update.message.reply_text("‚è≥ –ó–∞–≥—Ä—É–∂–∞—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ...", reply_markup=ReplyKeyboardRemove())
        schedule = get_schedule(text, group_name)
        await update.message.reply_text(schedule, parse_mode='HTML')
        await show_main_menu(update, update.effective_user.id)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_schedule_period: {e}")
        await update.message.reply_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            parse_mode='HTML'
        )

# -------------------- MESSAGE SENDING FUNCTIONS --------------------

async def ask_homework_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for homework details to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_homework(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –î–ó.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'homework')
        
        await update.message.reply_text(
            "üìù <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –î–ó</b>\n\n"
            "–ù–∞–ø–∏—à–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "<b>–ü—Ä–µ–¥–º–µ—Ç</b>\n"
            "<b>–ó–∞–¥–∞–Ω–∏–µ</b>\n"
            "<b>–°—Ä–æ–∫ —Å–¥–∞—á–∏</b>\n\n"
            "–ü—Ä–∏–º–µ—Ä:\n"
            "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞\n"
            "–†–µ—à–∏—Ç—å –∑–∞–¥–∞—á–∏ 1-10 –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 45\n"
            "–î–æ 15.09\n\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –î–ó.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_homework_details: {e}")
        return ConversationHandler.END

async def ask_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for information to send to everyone"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'notification')
        
        await update.message.reply_text(
            "üì¢ <b>–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º</b>\n\n"
            "–ù–∞–ø–∏—à–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º —É—á–µ–Ω–∏–∫–∞–º.\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_INFO
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_notification_details: {e}")
        return ConversationHandler.END

async def ask_sport_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a sport notification to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'sport')
        
        await update.message.reply_text(
            "üèÉ <b>–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è</b>\n\n"
            "–ù–∞–ø–∏—à–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º —É—á–µ–Ω–∏–∫–∞–º.\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_SPORT
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_sport_notification_details: {e}")
        return ConversationHandler.END

async def ask_suggestion_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a suggestion to improve the bot"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'suggestion')
        
        await update.message.reply_text(
            "üí° <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –±–æ—Ç–∞</b>\n\n"
            "–ù–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –±–æ—Ç–∞:\n\n"
            "–ß—Ç–æ –±—ã —Ç—ã —Ö–æ—Ç–µ–ª –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å?\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_suggestion_details: {e}")
        return ConversationHandler.END

async def ask_poll_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for poll details to create"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_create_polls(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–ø—Ä–æ—Å–æ–≤.")
            return ConversationHandler.END
        
        await update.message.reply_text(
            "üìä <b>–°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ä–æ—Å–∞</b>\n\n"
            "–ù–∞–ø–∏—à–∏ –≤–æ–ø—Ä–æ—Å –∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "<b>–í–æ–ø—Ä–æ—Å</b>\n"
            "<b>–í–∞—Ä–∏–∞–Ω—Ç 1</b>\n"
            "<b>–í–∞—Ä–∏–∞–Ω—Ç 2</b>\n"
            "<b>–í–∞—Ä–∏–∞–Ω—Ç 3</b>\n\n"
            "–ü—Ä–∏–º–µ—Ä:\n"
            "–ö–∞–∫–æ–π –ø—Ä–µ–¥–º–µ—Ç —Å–∞–º—ã–π –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π?\n"
            "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞\n"
            "–§–∏–∑–∏–∫–∞\n"
            "–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞\n"
            "–ò—Å—Ç–æ—Ä–∏—è",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
        )
        return AWAITING_POLL
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_poll_details: {e}")
        return ConversationHandler.END

# -------------------- MESSAGE HANDLING FUNCTIONS --------------------

async def handle_homework_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles homework input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_HOMEWORK
        
        if not can_send_homework(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'homework')
            homework_text = context.user_data.get('homework_text', '')
            
            if not homework_text and not media_collection:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ –î–ó –∏–ª–∏ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã.")
                return AWAITING_HOMEWORK
                
            if not homework_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ –î–ó.")
                return AWAITING_HOMEWORK
                
            lines = homework_text.strip().split('\n')
            if len(lines) >= 3:
                subject = lines[0].strip()
                task = lines[1].strip()
                deadline = lines[2].strip()
                
                homework_id = add_homework(subject, task, deadline, group_name, user_id)
                
                if homework_id:
                    for media_item in media_collection:
                        add_homework_media(homework_id, media_item['type'], media_item['id'], media_item.get('caption'))
                    
                    await update.message.reply_text("‚úÖ –î–ó –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
                    await send_homework_to_all(context.bot, homework_id, subject, task, deadline, group_name, user_id)
                    
                    clear_media_collection(user_id, 'homework')
                    context.user_data.pop('homework_text', None)
                else:
                    await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –î–ó.")
                
                await show_main_menu(update, user_id)
                return ConversationHandler.END
            else:
                await update.message.reply_text("‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ù—É–∂–Ω–æ 3 —Å—Ç—Ä–æ–∫–∏: –ø—Ä–µ–¥–º–µ—Ç, –∑–∞–¥–∞–Ω–∏–µ, —Å—Ä–æ–∫")
                return AWAITING_HOMEWORK
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'homework', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        elif update.message.video:
            add_to_media_collection(user_id, 'homework', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        elif update.message.document:
            add_to_media_collection(user_id, 'homework', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        
        if text and text.strip():
            context.user_data['homework_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç –î–ó —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ –î–ó.")
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_homework_input: {e}")
        return AWAITING_HOMEWORK

async def handle_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_INFO
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'notification')
            notification_text = context.user_data.get('notification_text', '')
            
            if not notification_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
                return AWAITING_INFO

            notification_id = add_notification(notification_text, group_name, user_id)
            
            if notification_id:
                for media_item in media_collection:
                    add_notification_media(notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
                await send_notification_to_all(context.bot, notification_id, notification_text, group_name, user_id)
                
                clear_media_collection(user_id, 'notification')
                context.user_data.pop('notification_text', None)
            else:
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'notification', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        elif update.message.video:
            add_to_media_collection(user_id, 'notification', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        elif update.message.document:
            add_to_media_collection(user_id, 'notification', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        
        if text and text.strip():
            context.user_data['notification_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        return AWAITING_INFO
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_notification_input: {e}")
        return AWAITING_INFO

async def handle_sport_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles sport notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SPORT
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']

        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'sport')
            sport_text = context.user_data.get('sport_text', '')
            
            if not sport_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
                return AWAITING_SPORT
        
            sport_notification_id = add_sport_notification(sport_text, group_name, user_id)
            
            if sport_notification_id:
                for media_item in media_collection:
                    add_sport_notification_media(sport_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("‚úÖ –°–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
                await send_sport_notification_to_all(context.bot, sport_notification_id, sport_text, group_name, user_id)
                
                clear_media_collection(user_id, 'sport')
                context.user_data.pop('sport_text', None)
            else:
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'sport', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        elif update.message.video:
            add_to_media_collection(user_id, 'sport', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        elif update.message.document:
            add_to_media_collection(user_id, 'sport', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        
        if text and text.strip():
            context.user_data['sport_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        return AWAITING_SPORT
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_sport_input: {e}")
        return AWAITING_SPORT

async def handle_suggestion_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles suggestion input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'suggestion')
            suggestion_text = context.user_data.get('suggestion_text', '')
            
            if not suggestion_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
                return AWAITING_SUGGESTION

            suggestion_id = add_suggestion(user_id, suggestion_text)
            
            if suggestion_id:
                for media_item in media_collection:
                    add_suggestion_media(suggestion_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º —Å –ø—Ä–∞–≤–∞–º–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            special_users = [u for u in get_all_users() if can_delete_suggestions(u['user_id'])]
            
            for special_user in special_users:
                try:
                    if media_collection:
                        for media_item in media_collection:
                            if media_item['type'] == 'photo':
                                await context.bot.send_photo(
                                    chat_id=special_user['user_id'],
                                    photo=media_item['id'],
                                    caption=f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                            elif media_item['type'] == 'video':
                                await context.bot.send_video(
                                    chat_id=special_user['user_id'],
                                    video=media_item['id'],
                                    caption=f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                            elif media_item['type'] == 'document':
                                await context.bot.send_document(
                                    chat_id=special_user['user_id'],
                                    document=media_item['id'],
                                    caption=f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                    else:
                        await context.bot.send_message(
                            special_user['user_id'],
                            f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                            reply_markup=InlineKeyboardMarkup([
                                [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                            ])
                        )
                except Exception as e:
                    print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {special_user['user_id']}: {e}")
            
            await update.message.reply_text("‚úÖ –°–ø–∞—Å–∏–±–æ –∑–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ! –ú—ã –µ–≥–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º.", reply_markup=ReplyKeyboardRemove())
            
            clear_media_collection(user_id, 'suggestion')
            context.user_data.pop('suggestion_text', None)
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        elif update.message.video:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        elif update.message.document:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        
        if text and text.strip():
            context.user_data['suggestion_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_suggestion_input: {e}")
        return AWAITING_SUGGESTION

async def handle_poll_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles poll input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_POLL
        
        if not can_create_polls(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        text = update.message.text

        if text == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if not text:
            await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ –≤–æ–ø—Ä–æ—Å –∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤.")
            return AWAITING_POLL

        lines = text.strip().split('\n')
        if len(lines) < 3:
            await update.message.reply_text("‚ùå –ù—É–∂–Ω–æ –∫–∞–∫ –º–∏–Ω–∏–º—É–º: –≤–æ–ø—Ä–æ—Å –∏ 2 –≤–∞—Ä–∏–∞–Ω—Ç–∞ –æ—Ç–≤–µ—Ç–∞.")
            return AWAITING_POLL
        
        question = lines[0].strip()
        options = [line.strip() for line in lines[1:] if line.strip()]
        
        users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
        
        for user in users:
            try:
                message = await context.bot.send_poll(
                    chat_id=user['user_id'],
                    question=question,
                    options=options,
                    is_anonymous=False,
                    allows_multiple_answers=False
                )
                add_poll(question, options, group_name, user_id, message.message_id)
            except Exception as e:
                print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")
        
        await update.message.reply_text("‚úÖ –û–ø—Ä–æ—Å —Å–æ–∑–¥–∞–Ω –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_poll_input: {e}")
        return AWAITING_POLL

# -------------------- NOTIFICATION SENDING FUNCTIONS --------------------

async def send_homework_to_all(bot, homework_id, subject, task, deadline, group_name, added_by):
    """Sends homework to all users in a group"""
    homework_text = (
        f"üìù <b>–ù–û–í–û–ï –î–û–ú–ê–®–ù–ï–ï –ó–ê–î–ê–ù–ò–ï</b>\n\n"
        f"üìö <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {subject}\n"
        f"üìã <b>–ó–∞–¥–∞–Ω–∏–µ:</b> {task}\n"
        f"‚è∞ <b>–°—Ä–æ–∫ —Å–¥–∞—á–∏:</b> {deadline}\n"
        f"üë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}\n"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (homework_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=homework_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=homework_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=homework_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=homework_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], homework_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_notification_to_all(bot, notification_id, message, group_name, added_by):
    """Sends a notification to all users in a group"""
    notification_text = (f"üì¢ <b>–í–ê–ñ–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n{message}\n\nüë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}")
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=notification_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=notification_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=notification_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=notification_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_sport_notification_to_all(bot, sport_notification_id, message, group_name, added_by):
    """Sends a sport notification to all users in a group"""
    sport_text = (f"üèÉ <b>–°–ü–û–†–¢–ò–í–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n{message}\n\nüë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}")
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()

    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=sport_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=sport_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=sport_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=sport_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], sport_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

# -------------------- INFO DISPLAY FUNCTIONS --------------------

async def show_homework(update: Update, group_name: str):
    """Shows all homework for a group"""
    try:
        homeworks = get_homeworks(group_name)
        if not homeworks:
            await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π")
            return
        
        for hw in homeworks:
            hw_text = (
                f"üìù <b>–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ</b>\n"
                f"üìö <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {hw['subject']}\n"
                f"üìã <b>–ó–∞–¥–∞–Ω–∏–µ:</b> {hw['task']}\n"
                f"‚è∞ <b>–°—Ä–æ–∫:</b> {hw['deadline']}\n"
                f"üë§ <b>–î–æ–±–∞–≤–∏–ª:</b> {hw['first_name']}\n"
                f"üìÖ <b>–î–∞—Ç–∞:</b> {datetime.fromisoformat(hw['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if hw['media']:
                if len(hw['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(hw['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = hw['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=hw_text, parse_mode='HTML')
            else:
                await update.message.reply_text(hw_text, parse_mode='HTML')
        
        await update.message.reply_text(f"üìä <b>–ü–æ–∫–∞–∑–∞–Ω–æ:</b> {len(homeworks)} –∑–∞–¥–∞–Ω–∏–π", parse_mode='HTML')
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_homework: {e}")

async def show_information(update: Update, group_name: str, role: str):
    """Shows information for the user"""
    try:
        user_count = get_total_user_count()
        info_text = f"üìä <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –±–æ—Ç–µ:</b> {user_count}\n\n<b>–ö–æ–Ω—Ç–∞–∫—Ç—ã:</b>\n"
        for data in SPECIAL_USERS.values():
            info_text += f"- <b>{data['name']}</b>: {data['username']}\n"
        await update.message.reply_text(info_text, parse_mode='HTML')

        notifications = get_notifications(group_name)
        sport_notifications = get_sport_notifications(group_name)
        if not notifications and not sport_notifications:
            await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")
            return
        
        if notifications:
            await update.message.reply_text("üì¢ <b>–í–∞–∂–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:</b>", parse_mode='HTML')
            for notif in notifications[:2]:
                notif_text = f"{notif['message']}\n\nüë§ <b>–û—Ç:</b> {notif['first_name']} | üìÖ {datetime.fromisoformat(notif['created_at']).strftime('%d.%m.%Y')}"
                
                if notif['media']:
                    if len(notif['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(notif['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = notif['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=notif_text)
                else:
                    await update.message.reply_text(notif_text)
        
        if sport_notifications:
            await update.message.reply_text("üèÉ <b>–°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:</b>", parse_mode='HTML')
            for sport in sport_notifications[:2]:
                sport_text = f"{sport['message']}\n\nüë§ <b>–û—Ç:</b> {sport['first_name']} | üìÖ {datetime.fromisoformat(sport['created_at']).strftime('%d.%m.%Y')}"
                
                if sport['media']:
                    if len(sport['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(sport['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = sport['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=sport_text)
                else:
                    await update.message.reply_text(sport_text)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_information: {e}")

async def show_suggestions(update: Update):
    """Shows suggestions from students"""
    try:
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –æ—Ç —É—á–µ–Ω–∏–∫–æ–≤")
            return
        
        for s in suggestions[:5]:
            username = f"@{s['username']}" if s['username'] else s['first_name']
            suggestion_text = (
                f"üí° <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {username}</b>\n\n"
                f"{s['message']}\n\n"
                f"üìÖ {datetime.fromisoformat(s['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if s['responses']:
                suggestion_text += "\n\n<b>–û—Ç–≤–µ—Ç—ã:</b>\n"
                for response in s['responses']:
                    responder_name = f"@{response['username']}" if response['username'] else response['first_name']
                    suggestion_text += f"üë§ {responder_name}: {response['message']}\n"
            
            if s['media']:
                if len(s['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(s['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = s['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
            else:
                await update.message.reply_text(suggestion_text, parse_mode='HTML')
                
            if not s['responses']:
                await update.message.reply_text(
                    "üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{s['id']}")]
                    ])
                )
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_suggestions: {e}")

async def show_users_list(update: Update):
    """Shows a list of all users for the developer"""
    try:
        users = get_all_users()
        if not users:
            await update.message.reply_text("‚ùå –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            return
        
        user_list_text = "üë• <b>–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>\n\n"
        
        for user in users:
            username = user['username'] if user['username'] else "–ù–µ—Ç —é–∑–µ—Ä–Ω–µ–π–º–∞"
            role_display = user['custom_role_name'] if user['custom_role_name'] else user['role']
            group_display = user['group_name'] if user['group_name'] else "–ù–µ —É–∫–∞–∑–∞–Ω–∞"
            
            user_list_text += (
                f"<b>–ò–º—è:</b> {user['first_name']}\n"
                f"<b>–ì—Ä—É–ø–ø–∞:</b> {group_display}\n"
                f"<b>–†–æ–ª—å:</b> {role_display}\n"
                f"<b>–Æ–∑–µ—Ä:</b> @{username}\n"
                f"<b>ID:</b> <code>{user['user_id']}</code>\n\n"
            )
        
        # –†–∞–∑–±–∏–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏ –µ—Å–ª–∏ –æ–Ω–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ
        if len(user_list_text) > 4000:
            parts = []
            current_part = ""
            lines = user_list_text.split('\n\n')
            
            for line in lines:
                if len(current_part + line + '\n\n') > 4000:
                    parts.append(current_part)
                    current_part = line + '\n\n'
                else:
                    current_part += line + '\n\n'
            
            if current_part:
                parts.append(current_part)
            
            for i, part in enumerate(parts):
                await update.message.reply_text(
                    f"{part}\n<b>–ß–∞—Å—Ç—å {i+1}/{len(parts)}</b>", 
                    parse_mode='HTML'
                )
        else:
            await update.message.reply_text(user_list_text, parse_mode='HTML')
            
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_users_list: {e}")
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")

async def show_call_schedule(update: Update):
    """Shows the call schedule"""
    try:
        now = datetime.now(YEKATERINBURG_TZ)
        day_of_week = now.weekday()
        
        if day_of_week == 5:
            schedule_text = (
                "üîî **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ –Ω–∞ —Å—É–±–±–æ—Ç—É**\n\n"
                "1 –ø–∞—Ä–∞: **8:30 - 9:45**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "2 –ø–∞—Ä–∞: **9:55 - 11:10**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "3 –ø–∞—Ä–∞: **11:20 - 12:40**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 40 –º–∏–Ω—É—Ç - –û–ë–ï–î\n"
                "4 –ø–∞—Ä–∞: **13:20 - 14:35**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "5 –ø–∞—Ä–∞: **14:45 - 16:00**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "6 –ø–∞—Ä–∞: **16:10 - 17:25**\n"
            )
        else:
            schedule_text = (
                "üîî **–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ (–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫-–ø—è—Ç–Ω–∏—Ü–∞)**\n\n"
                "1 –ø–∞—Ä–∞: **8:30 - 10:05**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "2 –ø–∞—Ä–∞: **10:15 - 11:50**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "3 –ø–∞—Ä–∞: **12:40 - 14:15**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 40 –º–∏–Ω—É—Ç - –û–ë–ï–î\n"
                "4 –ø–∞—Ä–∞: **14:25 - 16:00**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "5 –ø–∞—Ä–∞: **16:10 - 17:45**\n"
                "–ü–µ—Ä–µ–º–µ–Ω–∞: 10 –º–∏–Ω—É—Ç\n"
                "6 –ø–∞—Ä–∞: **17:55 - 19:30**\n"
            )
        
        await update.message.reply_text(schedule_text, parse_mode='Markdown')
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_call_schedule: {e}")

async def contact_physical_organizer(update: Update):
    """Contact the physical organizer"""
    try:
        username = next((data['username'] for data in SPECIAL_USERS.values() if data['role'] == ROLE_PHYSICAL_ORGANIZER), None)
        if username:
            await update.message.reply_text(f"üèÉ <b>–°–≤—è–∑—å —Å –§–∏–∑. –æ—Ä–≥–æ–º</b>\n\nüìû Telegram: {username}", parse_mode='HTML')
        else:
            await update.message.reply_text("‚ùå –§–∏–∑. –æ—Ä–≥. –Ω–µ –Ω–∞–π–¥–µ–Ω")
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ contact_physical_organizer: {e}")

async def contact_starosta(update: Update):
    """Contact the —Å—Ç–∞—Ä–æ—Å—Ç–∞"""
    try:
        username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == '–°—Ç–∞—Ä–æ—Å—Ç–∞'), None)
        if username:
            await update.message.reply_text(f"üëë <b>–°–≤—è–∑—å —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π</b>\n\nüìû Telegram: {username}", parse_mode='HTML')
        else:
            await update.message.reply_text("‚ùå –°—Ç–∞—Ä–æ—Å—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω")
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ contact_starosta: {e}")

async def contact_deputy_starosta(update: Update):
    """Contact the –∑–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã"""
    try:
        username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == '–ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã (–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫)'), None)
        if username:
            await update.message.reply_text(f"üëë <b>–°–≤—è–∑—å —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã (—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º)</b>\n\nüìû Telegram: {username}", parse_mode='HTML')
        else:
            await update.message.reply_text("‚ùå –ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω")
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ contact_deputy_starosta: {e}")

# -------------------- DELETION FUNCTIONS --------------------

async def delete_homework_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows homework deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_homework(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        homeworks = get_homeworks(user_data['group_name'])
        if not homeworks:
            await update.message.reply_text("üìù –ù–µ—Ç –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END
        
        keyboard = [[InlineKeyboardButton(f"‚ùå {hw['subject']} | {hw['deadline']}", callback_data=f"del_hw_{hw['id']}")] for hw in homeworks[:5]]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –î–ó –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_HOMEWORK_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_homework_menu: {e}")
        return ConversationHandler.END

async def delete_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        user_data = get_user(user_id)
        notifications = get_notifications(user_data['group_name'])
        sport_notifications = get_sport_notifications(user_data['group_name'])
        
        if not notifications and not sport_notifications:
            await update.message.reply_text("üì¢ –ù–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END

        keyboard = []
        for n in notifications[:5]:
            button_text = f"üì¢ {n['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_notif_{n['id']}")])
        
        for s in sport_notifications[:5]:
            button_text = f"üèÉ {s['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{s['id']}")])

        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_INFO_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_notification_menu: {e}")
        return ConversationHandler.END

async def delete_sport_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows sport notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_sport_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        if user_id == DEVELOPER_ID:
            sport_notifications = get_all_sport_notifications()
        else:
            sport_notifications = get_sport_notifications(user_data['group_name'])

        if not sport_notifications:
            await update.message.reply_text("üèÉ –ù–µ—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END

        keyboard = []
        for sport in sport_notifications[:10]:
            button_text = f"üèÉ {sport['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{sport['id']}")])

        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SPORT_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_sport_notification_menu: {e}")
        return ConversationHandler.END

async def delete_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows user deletion menu"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        users = [u for u in get_all_users() if u['user_id'] not in SPECIAL_USERS]
        if not users:
            await update.message.reply_text("üë• –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END
            
        keyboard = [[InlineKeyboardButton(f"‚ùå {u['first_name']} (@{u['username']}) - –ì—Ä—É–ø–ø–∞: {u['group_name']} - ID: {u['user_id']}", callback_data=f"del_user_{u['user_id']}")] for u in users]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_USER_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_user_menu: {e}")
        return ConversationHandler.END

async def delete_suggestions_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows suggestions deletion menu"""
    try:
        user_id = update.effective_user.id
        if not can_delete_suggestions(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("üí° –ù–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END
        
        keyboard = [[InlineKeyboardButton(f"‚ùå {s['message'][:20]}...", callback_data=f"del_sugg_{s['id']}")] for s in suggestions[:5]]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SUGGESTION_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_suggestions_menu: {e}")
        return ConversationHandler.END

async def handle_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles deletion callbacks"""
    try:
        query = update.callback_query
        await query.answer()

        parts = query.data.split('_')
        data_type = parts[1]
        item_id = int(parts[2])
        
        message = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞."
        try:
            if data_type == 'hw':
                delete_homework(item_id)
                message = "‚úÖ –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            elif data_type == 'notif':
                delete_notification(item_id)
                message = "‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            elif data_type == 'sport':
                delete_sport_notification(item_id)
                message = "‚úÖ –°–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            elif data_type == 'user':
                delete_user(item_id)
                message = "‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω."
            elif data_type == 'sugg':
                delete_suggestion(item_id)
                message = "‚úÖ –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            
            await query.edit_message_text(text=message)
        except Exception as e:
            await query.edit_message_text(text=f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: {e}")
        
        await show_main_menu(update, query.from_user.id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_delete_callback: {e}")
        return ConversationHandler.END

# -------------------- SUGGESTION RESPONSE FUNCTION --------------------

async def handle_suggestion_response_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response callback"""
    try:
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split('_')
        suggestion_id = int(parts[1])
        
        context.user_data['responding_to_suggestion'] = suggestion_id
        
        await query.edit_message_text(
            "üí¨ <b>–û—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ</b>\n\n–ù–∞–ø–∏—à–∏ —Å–≤–æ–π –æ—Ç–≤–µ—Ç:",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
        )
        
        return AWAITING_SUGGESTION_RESPONSE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_suggestion_response_callback: {e}")
        return ConversationHandler.END

async def handle_suggestion_response_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION_RESPONSE
        
        text = update.message.text
        
        if text == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if not text:
            await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ –æ—Ç–≤–µ—Ç.")
            return AWAITING_SUGGESTION_RESPONSE
        
        suggestion_id = context.user_data.get('responding_to_suggestion')
        
        if not suggestion_id:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            return await cancel_conversation(update, context)
        
        conn = get_db_connection()
        suggestion = conn.execute('SELECT * FROM suggestions WHERE id = ?', (suggestion_id,)).fetchone()
        conn.close()
        
        if not suggestion:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            return await cancel_conversation(update, context)
        
        add_suggestion_response(suggestion_id, user_id, text)
        
        try:
            responder_name = user_data['first_name']
            if user_data['username']:
                responder_name = f"@{user_data['username']}"
            
            response_text = (
                f"üí¨ <b>–û—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ</b>\n\n"
                f"üë§ <b>–û—Ç:</b> {responder_name}\n"
                f"üí° <b>–í–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:</b> {suggestion['message'][:100]}...\n\n"
                f"üìù <b>–û—Ç–≤–µ—Ç:</b> {text}"
            )
            
            await context.bot.send_message(
                chat_id=suggestion['user_id'],
                text=response_text,
                parse_mode='HTML'
            )
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç –∞–≤—Ç–æ—Ä—É –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
        
        await update.message.reply_text("‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_suggestion_response_input: {e}")
        return AWAITING_SUGGESTION_RESPONSE

# -------------------- POLL HANDLER --------------------

async def handle_poll_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles poll answers"""
    pass

# -------------------- ROLE FIX FUNCTION --------------------

async def handle_role_fix_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the role fix callback"""
    try:
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split('_')
        user_id = int(parts[2])
        
        if query.from_user.id != user_id:
            await query.edit_message_text("‚ùå –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Ä–æ–ª—å –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return
        
        user = query.from_user
        add_user(user_id, user.username, user.first_name, user.last_name)
        
        await query.edit_message_text("‚úÖ –í–∞—à–∞ —Ä–æ–ª—å –±—ã–ª–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞! –¢–µ–ø–µ—Ä—å —É –≤–∞—Å –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤—Å–µ –ø—Ä–∞–≤–∞.")
        await show_main_menu(update, user_id)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_role_fix_callback: {e}")

# -------------------- SPECIAL USER MANAGEMENT FUNCTIONS --------------------

async def add_special_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows menu for adding special users"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
        
        await update.message.reply_text(
            "üëë <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
            "–í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å:",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
        )
        return AWAITING_ADD_SPECIAL_USER
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ add_special_user_menu: {e}")
        return ConversationHandler.END

async def handle_special_user_id_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles special user ID input"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)
        
        text = update.message.text.strip()
        
        if text == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        try:
            target_user_id = int(text)
            
            if target_user_id == user_id:
                await update.message.reply_text("‚ùå –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω—è—Ç—å —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∞!")
                return await cancel_conversation(update, context)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
            try:
                user = await context.bot.get_chat(target_user_id)
                context.user_data['special_user_data'] = {
                    'user_id': target_user_id,
                    'username': user.username,
                    'first_name': user.first_name,
                    'last_name': user.last_name
                }
                
                # –í—ã–±–æ—Ä –≥—Ä—É–ø–ø—ã
                keyboard = [ALL_GROUPS[i:i+3] for i in range(0, len(ALL_GROUPS), 3)]
                keyboard.append(['‚ùå –û—Ç–º–µ–Ω–∞'])
                await update.message.reply_text(
                    f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user.first_name} (@{user.username})\n\n"
                    "–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:",
                    reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
                )
                return AWAITING_GROUP
            except Exception as e:
                await update.message.reply_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –±–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–µ–º.")
                return await cancel_conversation(update, context)
                
        except ValueError:
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ID. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return AWAITING_ADD_SPECIAL_USER
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_special_user_id_input: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def handle_special_user_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles group selection for special user"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)
        
        group_name = update.message.text
        
        if group_name == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if group_name not in ALL_GROUPS:
            await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É –∏–∑ —Å–ø–∏—Å–∫–∞.")
            return AWAITING_GROUP
        
        context.user_data['special_user_data']['group_name'] = group_name
        
        # –í—ã–±–æ—Ä —Ç–∏–ø–∞ —Ä–æ–ª–∏
        keyboard = [
            ['üëë –°—Ç–∞—Ä–æ—Å—Ç–∞', 'üëë –ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã'],
            ['üèÉ –§–∏–∑. –æ—Ä–≥.', 'üîß –î—Ä—É–≥–æ–µ'],
            ['‚ùå –û—Ç–º–µ–Ω–∞']
        ]
        await update.message.reply_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ä–æ–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        )
        return AWAITING_ADD_SPECIAL_USER
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_special_user_group_selection: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def handle_special_user_role_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles role selection for special user"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)
        
        role_type = update.message.text
        
        if role_type == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        user_data = context.user_data['special_user_data']
        
        if role_type == 'üëë –°—Ç–∞—Ä–æ—Å—Ç–∞':
            role_key = 'starosta'
            custom_name = '–°—Ç–∞—Ä–æ—Å—Ç–∞'
        elif role_type == 'üëë –ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã':
            role_key = 'deputy_starosta'
            custom_name = '–ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã'
        elif role_type == 'üèÉ –§–∏–∑. –æ—Ä–≥.':
            role_key = 'physical_organizer'
            custom_name = '–§–∏–∑. –æ—Ä–≥.'
        elif role_type == 'üîß –î—Ä—É–≥–æ–µ':
            await update.message.reply_text(
                "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π —Ä–æ–ª–∏:",
                reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
            )
            return AWAITING_ADD_SPECIAL_USER
        else:
            await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ä–æ–ª–∏ –∏–∑ —Å–ø–∏—Å–∫–∞.")
            return AWAITING_ADD_SPECIAL_USER
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if add_special_user(
            user_data['user_id'],
            user_data['username'],
            user_data['first_name'],
            user_data['last_name'],
            user_data['group_name'],
            role_key,
            custom_name
        ):
            await update.message.reply_text(
                f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_data['first_name']} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ {custom_name} –≤ –≥—Ä—É–ø–ø—É {user_data['group_name']}!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text(
                "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
                reply_markup=ReplyKeyboardRemove()
            )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_special_user_role_selection: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def handle_custom_role_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles custom role name input"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)
        
        custom_name = update.message.text.strip()
        
        if custom_name == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        user_data = context.user_data['special_user_data']
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∫–∞—Å—Ç–æ–º–Ω–æ–π —Ä–æ–ª—å—é
        if add_special_user(
            user_data['user_id'],
            user_data['username'],
            user_data['first_name'],
            user_data['last_name'],
            user_data['group_name'],
            'custom',
            custom_name
        ):
            await update.message.reply_text(
                f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_data['first_name']} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ {custom_name} –≤ –≥—Ä—É–ø–ø—É {user_data['group_name']}!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text(
                "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
                reply_markup=ReplyKeyboardRemove()
            )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_custom_role_name: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def manage_user_rights_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows menu for managing user rights"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
        
        users = get_all_users()
        if not users:
            await update.message.reply_text("‚ùå –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            return ConversationHandler.END
        
        keyboard = []
        for user in users:
            if user['user_id'] == user_id:
                continue
                
            role_display = user['custom_role_name'] if user['custom_role_name'] else user['role']
            button_text = f"{user['first_name']} (@{user['username']}) - {role_display}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"manage_rights_{user['user_id']}")])
        
        await update.message.reply_text(
            "üë• <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∞–≤:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ manage_user_rights_menu: {e}")
        return ConversationHandler.END

async def handle_user_rights_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user selection for rights management"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID:
            await query.edit_message_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return
        
        parts = query.data.split('_')
        target_user_id = int(parts[2])
        
        if target_user_id == user_id:
            await query.edit_message_text("‚ùå –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω—è—Ç—å —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∞!")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        
        context.user_data['managing_user_id'] = target_user_id
        
        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å —Ç–µ–∫—É—â–∏–º–∏ –ø—Ä–∞–≤–∞–º–∏
        keyboard = [
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_send_homework'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ –î–ó", callback_data=f"toggle_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_send_notifications'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_send_sport_notifications'] else '‚ùå'} –°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data=f"toggle_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_homework'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –î–ó", callback_data=f"toggle_del_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_del_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_sport_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö", callback_data=f"toggle_del_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_suggestions'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π", callback_data=f"toggle_del_suggestions_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_create_polls'] else '‚ùå'} –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ä–æ—Å–æ–≤", callback_data=f"toggle_polls_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_manage_users'] else '‚ùå'} –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏", callback_data=f"toggle_manage_users_{target_user_id}")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data="back_to_users_list")],
            [InlineKeyboardButton("‚ùå –°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –ø—Ä–∞–≤–∞", callback_data=f"reset_rights_{target_user_id}")],
            [InlineKeyboardButton("‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏", callback_data="save_rights")]
        ]
        
        role_display = target_user['custom_role_name'] if target_user['custom_role_name'] else target_user['role']
        
        await query.edit_message_text(
            f"üë§ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
            f"<b>–ò–º—è:</b> {target_user['first_name']}\n"
            f"<b>–Æ–∑–µ—Ä–Ω–µ–π–º:</b> @{target_user['username']}\n"
            f"<b>–ì—Ä—É–ø–ø–∞:</b> {target_user['group_name']}\n"
            f"<b>–†–æ–ª—å:</b> {role_display}\n\n"
            f"<b>–¢–µ–∫—É—â–∏–µ –ø—Ä–∞–≤–∞:</b>\n"
            f"–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—Ä–∞–≤–æ –¥–ª—è –µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_user_rights_selection: {e}")
        return AWAITING_USER_RIGHTS

async def handle_rights_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles rights toggling"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID:
            await query.edit_message_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return
        
        if query.data == "back_to_users_list":
            return await manage_user_rights_menu(update, context)
        
        if query.data == "save_rights":
            await query.edit_message_text("‚úÖ –ü—Ä–∞–≤–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!")
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        parts = query.data.split('_')
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ callback_data
        if len(parts) == 3:
            # –°—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç: toggle_action_targetUserId
            action = parts[1]
            target_user_id = int(parts[2])
        elif len(parts) == 4:
            # –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç: toggle_del_type_targetUserId
            action = parts[1]
            sub_action = parts[2]
            target_user_id = int(parts[3])
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º action –∏ sub_action –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            if action == "del":
                action = f"del_{sub_action}"
            elif action == "manage" and sub_action == "users":
                action = "manage_users"
        else:
            await query.edit_message_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö.")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∞–≤–∞
        rights_data = {
            'can_send_homework': target_user['can_send_homework'],
            'can_send_notifications': target_user['can_send_notifications'],
            'can_send_sport_notifications': target_user['can_send_sport_notifications'],
            'can_delete_homework': target_user['can_delete_homework'],
            'can_delete_notifications': target_user['can_delete_notifications'],
            'can_delete_sport_notifications': target_user['can_delete_sport_notifications'],
            'can_delete_suggestions': target_user['can_delete_suggestions'],
            'can_create_polls': target_user['can_create_polls'],
            'can_manage_users': target_user['can_manage_users'],
            'role': target_user['role'],
            'custom_role_name': target_user['custom_role_name']
        }
        
        if action == "reset":
            # –°–±—Ä–æ—Å –≤—Å–µ—Ö –ø—Ä–∞–≤
            for key in rights_data:
                if key.startswith('can_'):
                    rights_data[key] = 0
            rights_data['role'] = ROLE_STUDENT
            rights_data['custom_role_name'] = None
        else:
            # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–µ –ø—Ä–∞–≤–æ
            if action == "homework":
                rights_data['can_send_homework'] = 1 - rights_data['can_send_homework']
            elif action == "notifications":
                rights_data['can_send_notifications'] = 1 - rights_data['can_send_notifications']
            elif action == "sport":
                rights_data['can_send_sport_notifications'] = 1 - rights_data['can_send_sport_notifications']
            elif action == "del_homework":
                rights_data['can_delete_homework'] = 1 - rights_data['can_delete_homework']
            elif action == "del_notifications":
                rights_data['can_delete_notifications'] = 1 - rights_data['can_delete_notifications']
            elif action == "del_sport":
                rights_data['can_delete_sport_notifications'] = 1 - rights_data['can_delete_sport_notifications']
            elif action == "del_suggestions":
                rights_data['can_delete_suggestions'] = 1 - rights_data['can_delete_suggestions']
            elif action == "polls":
                rights_data['can_create_polls'] = 1 - rights_data['can_create_polls']
            elif action == "manage_users":
                rights_data['can_manage_users'] = 1 - rights_data['can_manage_users']
        
        if update_user_rights(target_user_id, rights_data):
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–æ–≤—ã–º–∏ –ø—Ä–∞–≤–∞–º–∏
            updated_user = get_user(target_user_id)
            
            keyboard = [
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_send_homework'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ –î–ó", callback_data=f"toggle_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_send_notifications'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_send_sport_notifications'] else '‚ùå'} –°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data=f"toggle_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_homework'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –î–ó", callback_data=f"toggle_del_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_del_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_sport_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö", callback_data=f"toggle_del_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_suggestions'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π", callback_data=f"toggle_del_suggestions_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_create_polls'] else '‚ùå'} –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø—Ä–æ—Å–æ–≤", callback_data=f"toggle_polls_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_manage_users'] else '‚ùå'} –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏", callback_data=f"toggle_manage_users_{target_user_id}")],
                [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data="back_to_users_list")],
                [InlineKeyboardButton("‚ùå –°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –ø—Ä–∞–≤–∞", callback_data=f"reset_rights_{target_user_id}")],
                [InlineKeyboardButton("‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏", callback_data="save_rights")]
            ]
            
            role_display = updated_user['custom_role_name'] if updated_user['custom_role_name'] else updated_user['role']
            
            await query.edit_message_text(
                f"üë§ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
                f"<b>–ò–º—è:</b> {updated_user['first_name']}\n"
                f"<b>–Æ–∑–µ—Ä–Ω–µ–π–º:</b> @{updated_user['username']}\n"
                f"<b>–ì—Ä—É–ø–ø–∞:</b> {updated_user['group_name']}\n"
                f"<b>–†–æ–ª—å:</b> {role_display}\n"
                f"<b>ID:</b> <code>{updated_user['user_id']}</code>\n\n"
                f"<b>–¢–µ–∫—É—â–∏–µ –ø—Ä–∞–≤–∞:</b>\n"
                f"–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—Ä–∞–≤–æ –¥–ª—è –µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è:",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∞–≤.")
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_rights_toggle: {e}")
        await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∞–≤.")

# -------------------- JOB QUEUE FUNCTIONS --------------------

async def init_schedule_cache(application):
    """Initializes the schedule cache and groups list"""
    try:
        global schedule_cache, last_schedule_check
        schedule_data = fetch_schedule_data()
        if schedule_data:
            schedule_cache = schedule_data
            last_schedule_check = datetime.now(YEKATERINBURG_TZ)
            print("–õ–û–ì: –ö—ç—à —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        
        # Initialize groups list
        fetch_groups_list()
        print("–õ–û–ì: –°–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫—ç—à–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")

# -------------------- MAIN FUNCTION --------------------

def main():
    """Main function to run the bot"""
    try:
        init_db()
        
        app = Application.builder().token(BOT_TOKEN).post_init(init_schedule_cache).build()
        
        job_queue = app.job_queue
        job_queue.run_repeating(check_schedule_changes, interval=3600, first=10)
        job_queue.run_daily(send_daily_schedule, time=time(hour=19, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(send_morning_schedule, time=time(hour=7, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(check_birthdays, time=time(hour=0, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        
        conv_handler = ConversationHandler(
            entry_points=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó$'), ask_homework_details),
                MessageHandler(filters.Regex('^üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), ask_notification_details),
                MessageHandler(filters.Regex('^üèÉ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), ask_sport_notification_details),
                MessageHandler(filters.Regex('^üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é$'), ask_suggestion_details),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –î–ó$'), delete_homework_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), delete_notification_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è$'), delete_sport_notification_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è$'), delete_suggestions_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è$'), delete_user_menu),
                MessageHandler(filters.Regex('^üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É$'), ask_user_group),
                MessageHandler(filters.Regex('^üìä –°–æ–∑–¥–∞—Ç—å –æ–ø—Ä–æ—Å$'), ask_poll_details),
                MessageHandler(filters.Regex('^üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è$'), ask_birthday_date),
                MessageHandler(filters.Regex('^üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º$'), ask_global_notification_details),
                MessageHandler(filters.Regex('^üëë –î–æ–±–∞–≤–∏—Ç—å —Å–ø–µ—Ü –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è$'), add_special_user_menu),
                MessageHandler(filters.Regex('^üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏$'), manage_user_rights_menu),
            ],
            states={
                AWAITING_GROUP: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_group_selection),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_special_user_group_selection)
                ],
                AWAITING_HOMEWORK: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_homework_input)],
                AWAITING_INFO: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_notification_input)],
                AWAITING_SPORT: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_sport_input)],
                AWAITING_SUGGESTION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_suggestion_input)],
                AWAITING_POLL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_poll_input)],
                AWAITING_SUGGESTION_RESPONSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_suggestion_response_input)],
                AWAITING_BIRTHDAY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_birthday_input)],
                AWAITING_GLOBAL_NOTIFICATION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_global_notification_input)],
                AWAITING_ADD_SPECIAL_USER: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_special_user_id_input),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_special_user_role_selection),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_custom_role_name)
                ],
                AWAITING_USER_RIGHTS: [CallbackQueryHandler(handle_user_rights_selection, pattern='^manage_rights_')],
                AWAITING_HOMEWORK_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_hw_')],
                AWAITING_INFO_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_notif_')],
                AWAITING_SPORT_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sport_')],
                AWAITING_USER_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_user_')],
                AWAITING_SUGGESTION_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sugg_')]
            },
            fallbacks=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^‚ùå –û—Ç–º–µ–Ω–∞$'), cancel_conversation)
            ],
            allow_reentry=True
        )
        
        app.add_handler(conv_handler)
        app.add_handler(CallbackQueryHandler(handle_role_fix_callback, pattern='^fix_role_'))
        app.add_handler(CallbackQueryHandler(handle_suggestion_response_callback, pattern='^respond_'))
        app.add_handler(CallbackQueryHandler(handle_rights_toggle, pattern='^(toggle_|reset_|back_|save_)'))
        app.add_handler(PollHandler(handle_poll_answer))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_simple_message))
        
        print("–õ–û–ì: –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
        app.run_polling()
        
    except Exception as e:
        print(f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}")

if __name__ == "__main__":
    main()
