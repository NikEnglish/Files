import sqlite3
import re
import json
import asyncio
import requests
import os
from datetime import datetime, timedelta, timezone, time
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo, InputMediaDocument
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler
from telegram.constants import ParseMode

# -------------------- CONSTANTS AND SETTINGS --------------------
BOT_TOKEN = "7405848829:AAHxDv0DP_Co512vOvGw_PDsXYDjE4fgOJ0"
YEKATERINBURG_TZ = timezone(timedelta(hours=5))
DEFAULT_GROUP = None

# States for ConversationHandler
AWAITING_HOMEWORK, AWAITING_INFO, AWAITING_SPORT, AWAITING_SUGGESTION, AWAITING_HOMEWORK_DELETE, AWAITING_INFO_DELETE, AWAITING_SPORT_DELETE, AWAITING_USER_DELETE, AWAITING_SUGGESTION_DELETE, AWAITING_GROUP, AWAITING_SUGGESTION_RESPONSE, AWAITING_BIRTHDAY, AWAITING_GLOBAL_NOTIFICATION, AWAITING_ADD_SPECIAL_USER, AWAITING_USER_RIGHTS, AWAITING_ROLE_ASSIGNMENT, AWAITING_NOTIFICATION_SETTINGS = range(17)

# User Roles
ROLE_STUDENT = 'student'
ROLE_STAROSTA = 'starosta'
ROLE_DEPUTY_STAROSTA = 'deputy_starosta'
ROLE_PHYSICAL_ORGANIZER = 'physical_organizer'
ROLE_DEVELOPER = 'developer'
ROLE_CUSTOM = 'custom'

# Special Users (—Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫)
DEVELOPER_ID = 1775957387

# Dynamic list of groups (will be populated from API)
ALL_GROUPS = []

# Schedule cache
schedule_cache = {}
last_schedule_check = None
groups_cache = []
last_groups_check = None

# Spam protection
user_message_times = {}
user_warnings = {}
user_blocks = {}
SPAM_THRESHOLD = 10
SPAM_WINDOW = 5
BLOCK_DURATIONS = [600, 1800, 3600, 7200, 36000, 180000]

# Media collection for multiple media support
user_media_collections = {}

# -------------------- UPDATED CALL SCHEDULES --------------------

# Regular schedule (Monday-Friday)
REGULAR_CALL_SCHEDULE = [
    {"type": "lesson", "number": 1, "part": 1, "start": "8:30", "end": "9:15"},
    {"type": "break", "start": "9:15", "end": "9:20", "duration": 5},
    {"type": "lesson", "number": 1, "part": 2, "start": "9:20", "end": "10:05"},
    {"type": "break", "start": "10:05", "end": "10:15", "duration": 10},
    {"type": "lesson", "number": 2, "part": 1, "start": "10:15", "end": "11:00"},
    {"type": "break", "start": "11:00", "end": "11:05", "duration": 5},
    {"type": "lesson", "number": 2, "part": 2, "start": "11:05", "end": "11:50"},
    {"type": "break", "start": "11:50", "end": "12:40", "duration": 50},
    {"type": "lesson", "number": 3, "part": 1, "start": "12:40", "end": "13:25"},
    {"type": "break", "start": "13:25", "end": "13:30", "duration": 5},
    {"type": "lesson", "number": 3, "part": 2, "start": "13:30", "end": "14:15"},
    {"type": "break", "start": "14:15", "end": "14:25", "duration": 10},
    {"type": "lesson", "number": 4, "part": 1, "start": "14:25", "end": "15:10"},
    {"type": "break", "start": "15:10", "end": "15:15", "duration": 5},
    {"type": "lesson", "number": 4, "part": 2, "start": "15:15", "end": "16:00"},
    {"type": "break", "start": "16:00", "end": "16:10", "duration": 10},
    {"type": "lesson", "number": 5, "part": 1, "start": "16:10", "end": "16:55"},
    {"type": "break", "start": "16:55", "end": "17:00", "duration": 5},
    {"type": "lesson", "number": 5, "part": 2, "start": "17:00", "end": "17:45"},
    {"type": "break", "start": "17:45", "end": "17:55", "duration": 10},
    {"type": "lesson", "number": 6, "part": 1, "start": "17:55", "end": "18:40"},
    {"type": "break", "start": "18:40", "end": "18:45", "duration": 5},
    {"type": "lesson", "number": 6, "part": 2, "start": "18:45", "end": "19:30"}
]

# Saturday schedule
SATURDAY_CALL_SCHEDULE = {
    1: {"start": "8:30", "end": "9:45"},
    "break1": {"start": "9:45", "end": "9:55", "duration": 10},
    2: {"start": "9:55", "end": "11:10"},
    "break2": {"start": "11:10", "end": "11:20", "duration": 10},
    3: {"start": "11:20", "end": "12:40"},
    "break3": {"start": "12:40", "end": "13:20", "duration": 40},
    4: {"start": "13:20", "end": "14:35"},
    "break4": {"start": "14:35", "end": "14:45", "duration": 10},
    5: {"start": "14:45", "end": "16:00"},
    "break5": {"start": "16:00", "end": "16:10", "duration": 10},
    6: {"start": "16:10", "end": "17:25"}
}

# Short day schedule
SHORT_DAY_CALL_SCHEDULE = {
    1: {"start": "8:30", "end": "9:30"},
    "break1": {"start": "9:30", "end": "9:40", "duration": 10},
    2: {"start": "9:40", "end": "10:40"},
    "break2": {"start": "10:40", "end": "10:50", "duration": 10},
    3: {"start": "10:50", "end": "11:50"},
    "break3": {"start": "11:50", "end": "12:30", "duration": 40},
    4: {"start": "12:30", "end": "13:30"},
    "break4": {"start": "13:30", "end": "13:40", "duration": 10},
    5: {"start": "13:40", "end": "14:40"},
    "break5": {"start": "14:40", "end": "14:50", "duration": 10},
    6: {"start": "14:50", "end": "15:50"}
}

# -------------------- DATABASE FUNCTIONS --------------------

def init_db():
    """Initializes the database with proper error handling"""
    conn = None
    try:
        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –µ—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã
        if os.path.exists('bot_data.db'):
            try:
                conn = sqlite3.connect('bot_data.db')
                cur = conn.cursor()
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–∞–±–ª–∏—Ü—ã group_roles
                cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='group_roles'")
                if not cur.fetchone():
                    print("–õ–û–ì: –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–∞–∑—ã, –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º...")
                    conn.close()
                    os.remove('bot_data.db')
                    conn = sqlite3.connect('bot_data.db')
                    cur = conn.cursor()
            except Exception as e:
                print(f"–õ–û–ì: –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–∑—ã: {e}")
                if conn:
                    conn.close()
                os.remove('bot_data.db')
                    conn = sqlite3.connect('bot_data.db')
                cur = conn.cursor()
        else:
            conn = sqlite3.connect('bot_data.db')
            cur = conn.cursor()
        
        # Users table with all required columns
        cur.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            group_name TEXT,
            role TEXT DEFAULT 'student',
            custom_role_name TEXT,
            can_send_homework BOOLEAN DEFAULT 0,
            can_send_notifications BOOLEAN DEFAULT 0,
            can_send_sport_notifications BOOLEAN DEFAULT 0,
            can_send_global_notifications BOOLEAN DEFAULT 0,
            can_delete_homework BOOLEAN DEFAULT 0,
            can_delete_notifications BOOLEAN DEFAULT 0,
            can_delete_sport_notifications BOOLEAN DEFAULT 0,
            can_delete_suggestions BOOLEAN DEFAULT 0,
            can_manage_users BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        # Group roles table - —Ä–æ–ª–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã
        cur.execute('''CREATE TABLE IF NOT EXISTS group_roles (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            group_name TEXT NOT NULL,
            role_type TEXT NOT NULL,
            user_id INTEGER,
            username TEXT,
            first_name TEXT,
            assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(group_name, role_type),
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE SET NULL
        )''')
        
        # User notification settings table
        cur.execute('''CREATE TABLE IF NOT EXISTS user_notification_settings (
            user_id INTEGER PRIMARY KEY,
            lesson_start BOOLEAN DEFAULT 1,
            new_homework BOOLEAN DEFAULT 1,
            important_notifications BOOLEAN DEFAULT 1,
            sport_notifications BOOLEAN DEFAULT 1,
            tomorrow_schedule BOOLEAN DEFAULT 1,
            today_schedule BOOLEAN DEFAULT 1,
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE
        )''')
        
        # Homeworks table
        cur.execute('''CREATE TABLE IF NOT EXISTS homeworks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            subject TEXT,
            task TEXT,
            deadline TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Homework media table
        cur.execute('''CREATE TABLE IF NOT EXISTS homework_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            homework_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (homework_id) REFERENCES homeworks (id) ON DELETE CASCADE
        )''')
        
        # Notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (notification_id) REFERENCES notifications (id) ON DELETE CASCADE
        )''')
        
        # Sport notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Sport notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sport_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (sport_notification_id) REFERENCES sport_notifications (id) ON DELETE CASCADE
        )''')
        
        # Suggestions table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )''')
        
        # Suggestion media table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id) ON DELETE CASCADE
        )''')
        
        # Suggestion responses table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_responses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            responder_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id),
            FOREIGN KEY (responder_id) REFERENCES users (user_id)
        )''')
        
        # Birthdays table
        cur.execute('''CREATE TABLE IF NOT EXISTS birthdays (
            user_id INTEGER PRIMARY KEY,
            birthday_date TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE
        )''')
        
        # Global notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Global notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            global_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (global_notification_id) REFERENCES global_notifications (id) ON DELETE CASCADE
        )''')
        
        conn.commit()
        print("–õ–û–ì: –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
    finally:
        if conn:
            conn.close()

def get_db_connection():
    """Creates a connection to the database"""
    try:
        conn = sqlite3.connect('bot_data.db')
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏: {e}")
        return None

def get_user(user_id):
    """Gets user information"""
    conn = get_db_connection()
    if not conn: return None
    try:
        user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        return user
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        return None
    finally:
        conn.close()

def get_group_role(group_name, role_type):
    """Gets role for specific group"""
    conn = get_db_connection()
    if not conn: return None
    try:
        role = conn.execute(
            'SELECT * FROM group_roles WHERE group_name = ? AND role_type = ?', 
            (group_name, role_type)
        ).fetchone()
        return role
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–æ–ª–∏ –≥—Ä—É–ø–ø—ã: {e}")
        return None
    finally:
        conn.close()

def set_group_role(group_name, role_type, user_id, username, first_name):
    """Sets role for specific group"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''INSERT OR REPLACE INTO group_roles 
                     (group_name, role_type, user_id, username, first_name) 
                     VALUES (?, ?, ?, ?, ?)''',
                     (group_name, role_type, user_id, username, first_name))
        conn.commit()
        print(f"–õ–û–ì: –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —Ä–æ–ª—å {role_type} –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name} - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {first_name}")
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ —Ä–æ–ª–∏ –≥—Ä—É–ø–ø—ã: {e}")
        return False
    finally:
        conn.close()

def remove_group_role(group_name, role_type):
    """Removes role from group"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('DELETE FROM group_roles WHERE group_name = ? AND role_type = ?', 
                    (group_name, role_type))
        conn.commit()
        print(f"–õ–û–ì: –£–¥–∞–ª–µ–Ω–∞ —Ä–æ–ª—å {role_type} –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}")
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ä–æ–ª–∏ –≥—Ä—É–ø–ø—ã: {e}")
        return False
    finally:
        conn.close()

def get_user_notification_settings(user_id):
    """Gets user notification settings"""
    conn = get_db_connection()
    if not conn: return None
    try:
        settings = conn.execute('SELECT * FROM user_notification_settings WHERE user_id = ?', (user_id,)).fetchone()
        if not settings:
            # Create default settings if not exist
            conn.execute('INSERT INTO user_notification_settings (user_id) VALUES (?)', (user_id,))
            conn.commit()
            settings = conn.execute('SELECT * FROM user_notification_settings WHERE user_id = ?', (user_id,)).fetchone()
        return settings
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return None
    finally:
        conn.close()

def update_user_notification_settings(user_id, setting_name, value):
    """Updates user notification settings"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute(f'UPDATE user_notification_settings SET {setting_name} = ? WHERE user_id = ?', (value, user_id))
        conn.commit()
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return False
    finally:
        conn.close()

def get_all_users():
    """Gets a list of all users"""
    conn = get_db_connection()
    if not conn: return []
    try:
        users = conn.execute('SELECT user_id, first_name, username, group_name, role, custom_role_name FROM users').fetchall()
        return users
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return []
    finally:
        conn.close()

def add_user(user_id, username, first_name, last_name):
    """Adds a new user to the database or updates existing user"""
    conn = get_db_connection()
    if not conn: return
    try:
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        role = ROLE_STUDENT
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞
        if user_id == DEVELOPER_ID:
            role = ROLE_DEVELOPER
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, role)
                         VALUES (?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, role))
            # Add default notification settings
            conn.execute('INSERT INTO user_notification_settings (user_id) VALUES (?)', (user_id,))
            print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {first_name} (ID: {user_id}) —Å —Ä–æ–ª—å—é {role}")
        else:
            conn.execute('''UPDATE users 
                         SET username = ?, first_name = ?, last_name = ?, role = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, role, user_id))
            print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {first_name} (ID: {user_id}), —Ä–æ–ª—å: {role}")
        
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
    finally:
        conn.close()

def update_user_rights(user_id, rights_data):
    """Updates user rights in the database"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''UPDATE users SET
                     can_send_homework = ?,
                     can_send_notifications = ?,
                     can_send_sport_notifications = ?,
                     can_send_global_notifications = ?,
                     can_delete_homework = ?,
                     can_delete_notifications = ?,
                     can_delete_sport_notifications = ?,
                     can_delete_suggestions = ?,
                     can_manage_users = ?,
                     role = ?,
                     custom_role_name = ?
                     WHERE user_id = ?''',
                     (rights_data.get('can_send_homework', 0),
                      rights_data.get('can_send_notifications', 0),
                      rights_data.get('can_send_sport_notifications', 0),
                      rights_data.get('can_send_global_notifications', 0),
                      rights_data.get('can_delete_homework', 0),
                      rights_data.get('can_delete_notifications', 0),
                      rights_data.get('can_delete_sport_notifications', 0),
                      rights_data.get('can_delete_suggestions', 0),
                      rights_data.get('can_manage_users', 0),
                      rights_data.get('role', ROLE_STUDENT),
                      rights_data.get('custom_role_name', None),
                      user_id))
        conn.commit()
        print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∞–≤: {e}")
        return False
    finally:
        conn.close()

def update_user_group(user_id, group_name):
    """Updates the user's group"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('UPDATE users SET group_name = ? WHERE user_id = ?', (group_name, user_id))
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Å–º–µ–Ω–∏–ª –≥—Ä—É–ø–ø—É –Ω–∞ {group_name}")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –≥—Ä—É–ø–ø—ã: {e}")
    finally:
        conn.close()

def set_user_birthday(user_id, birthday_date):
    """Sets or updates user's birthday"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''INSERT OR REPLACE INTO birthdays (user_id, birthday_date)
                     VALUES (?, ?)''', (user_id, birthday_date))
        conn.commit()
        print(f"–õ–û–ì: –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {birthday_date}")
        return True
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è: {e}")
        return False
    finally:
        conn.close()

def get_user_birthday(user_id):
    """Gets user's birthday"""
    conn = get_db_connection()
    if not conn: return None
    try:
        result = conn.execute('SELECT birthday_date FROM birthdays WHERE user_id = ?', (user_id,)).fetchone()
        return result['birthday_date'] if result else None
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def get_today_birthdays():
    """Gets all users who have birthday today"""
    conn = get_db_connection()
    if not conn: return []
    try:
        today = datetime.now().strftime('%d.%m')
        birthdays = conn.execute('''SELECT u.user_id, u.first_name, u.username, u.group_name, b.birthday_date 
                                 FROM users u JOIN birthdays b ON u.user_id = b.user_id 
                                 WHERE b.birthday_date LIKE ? AND u.group_name IS NOT NULL''', (f'{today}%',)).fetchall()
        return birthdays
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–Ω–µ–π —Ä–æ–∂–¥–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def get_total_user_count():
    """Gets the total number of users in the database"""
    conn = get_db_connection()
    if not conn: return 0
    try:
        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        return count
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return 0
    finally:
        conn.close()

def delete_homework(hw_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM homeworks WHERE id = ?', (hw_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –î–ó: {e}")
    finally:
        conn.close()

def delete_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def delete_sport_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM sport_notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def delete_user(user_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É–¥–∞–ª–µ–Ω –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
    finally:
        conn.close()

def delete_suggestion(suggestion_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM suggestions WHERE id = ?', (suggestion_id,))
        conn.commit()
        print(f"–õ–û–ì: –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {suggestion_id} —É–¥–∞–ª–µ–Ω–æ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
    finally:
        conn.close()

def get_all_sport_notifications():
    """Gets all sport notifications"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     ORDER BY s.created_at DESC''').fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_homework(subject, task, deadline, group_name, added_by):
    """Adds homework to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO homeworks (subject, task, deadline, group_name, added_by)
                     VALUES (?, ?, ?, ?, ?)''', (subject, task, deadline, group_name, added_by))
        homework_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ –î–ó –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
        return homework_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –î–ó: {e}")
        return None
    finally:
        conn.close()

def add_homework_media(homework_id, media_type, media_id, caption=None):
    """Adds media to homework"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO homework_media (homework_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (homework_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ –î–ó: {e}")
    finally:
        conn.close()

def get_homeworks(group_name):
    """Gets homework for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        homeworks = conn.execute('''SELECT h.*, u.first_name 
                                 FROM homeworks h JOIN users u ON h.added_by = u.user_id 
                                 WHERE h.group_name = ? ORDER BY h.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for hw in homeworks:
            hw_dict = dict(hw)
            media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (hw_dict['id'],)).fetchall()
            hw_dict['media'] = [dict(m) for m in media]
            result.append(hw_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –î–ó: {e}")
        return []
    finally:
        conn.close()

def add_notification(message, group_name, added_by):
    """Adds a notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        notification_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
        return notification_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_notification_media(notification_id, media_type, media_id, caption=None):
    """Adds media to notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO notification_media (notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

def get_notifications(group_name):
    """Gets notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT n.*, u.first_name 
                                     FROM notifications n JOIN users u ON n.added_by = u.user_id 
                                     WHERE n.group_name = ? ORDER BY n.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for notif in notifications:
            notif_dict = dict(notif)
            media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notif_dict['id'],)).fetchall()
            notif_dict['media'] = [dict(m) for m in media]
            result.append(notif_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_sport_notification(message, group_name, added_by):
    """Adds a sport notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO sport_notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        sport_notification_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}.")
        return sport_notification_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_sport_notification_media(sport_notification_id, media_type, media_id, caption=None):
    """Adds media to sport notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO sport_notification_media (sport_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (sport_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

def get_sport_notifications(group_name):
    """Gets sport notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     WHERE s.group_name = ? ORDER BY s.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for sport in notifications:
            sport_dict = dict(sport)
            media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_dict['id'],)).fetchall()
            sport_dict['media'] = [dict(m) for m in media]
            result.append(sport_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_suggestion(user_id, message):
    """Adds a suggestion to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO suggestions (user_id, message) VALUES (?, ?)', (user_id, message))
        suggestion_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –æ—Ç–ø—Ä–∞–≤–∏–ª –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
        return suggestion_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_suggestion_media(suggestion_id, media_type, media_id, caption=None):
    """Adds media to suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_media (suggestion_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (suggestion_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

def add_suggestion_response(suggestion_id, responder_id, message):
    """Adds a response to a suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_responses (suggestion_id, responder_id, message)
                     VALUES (?, ?, ?)''', (suggestion_id, responder_id, message))
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ {suggestion_id}.")
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ: {e}")
    finally:
        conn.close()

def get_suggestions():
    """Gets all suggestions"""
    conn = get_db_connection()
    if not conn: return []
    try:
        suggestions = conn.execute('''SELECT s.*, u.first_name, u.username 
                                   FROM suggestions s JOIN users u ON s.user_id = u.user_id 
                                   ORDER BY s.created_at DESC''').fetchall()
        
        result = []
        for s in suggestions:
            s_dict = dict(s)
            media = conn.execute('SELECT * FROM suggestion_media WHERE suggestion_id = ?', (s_dict['id'],)).fetchall()
            s_dict['media'] = [dict(m) for m in media]
            
            responses = conn.execute('''SELECT sr.*, u.first_name, u.username 
                                    FROM suggestion_responses sr JOIN users u ON sr.responder_id = u.user_id 
                                    WHERE sr.suggestion_id = ? ORDER BY sr.created_at''', (s_dict['id'],)).fetchall()
            s_dict['responses'] = [dict(r) for r in responses]
            
            result.append(s_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π: {e}")
        return []
    finally:
        conn.close()

def add_global_notification(message, added_by):
    """Adds a global notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO global_notifications (message, added_by) VALUES (?, ?)', (message, added_by))
        global_notification_id = cursor.lastrowid
        conn.commit()
        print(f"–õ–û–ì: –î–æ–±–∞–≤–ª–µ–Ω–æ –≥–ª–æ–±–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.")
        return global_notification_id
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        return None
    finally:
        conn.close()

def add_global_notification_media(global_notification_id, media_type, media_id, caption=None):
    """Adds media to global notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO global_notification_media (global_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (global_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ–¥–∏–∞ –∫ –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é: {e}")
    finally:
        conn.close()

# -------------------- SPAM PROTECTION --------------------

def check_spam(user_id):
    """Checks if user is spamming"""
    now = datetime.now().timestamp()
    
    if user_id in user_blocks and now < user_blocks[user_id]:
        return True, user_blocks[user_id] - now
    
    if user_id not in user_message_times:
        user_message_times[user_id] = []
        user_warnings[user_id] = 0
    
    user_message_times[user_id].append(now)
    user_message_times[user_id] = [t for t in user_message_times[user_id] if now - t < SPAM_WINDOW]
    
    if len(user_message_times[user_id]) >= SPAM_THRESHOLD:
        user_warnings[user_id] += 1
        warning_count = user_warnings[user_id]
        
        if warning_count - 1 < len(BLOCK_DURATIONS):
            block_duration = BLOCK_DURATIONS[warning_count - 1]
        else:
            block_duration = BLOCK_DURATIONS[-1]
        
        user_blocks[user_id] = now + block_duration
        user_message_times[user_id] = []
        return True, block_duration
    
    return False, 0

async def warn_user(update: Update, block_duration: int):
    """Warns user about spam"""
    minutes = block_duration // 60
    await update.message.reply_text(
        f"‚ö†Ô∏è –ù–µ —Å–ø–∞–º—å—Ç–µ! –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n"
        f"–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ {minutes} –º–∏–Ω—É—Ç."
    )

# -------------------- MEDIA COLLECTION FUNCTIONS --------------------

def init_user_media_collection(user_id):
    """Initializes media collection for a user"""
    if user_id not in user_media_collections:
        user_media_collections[user_id] = {
            'homework': [],
            'notification': [],
            'sport': [],
            'suggestion': [],
            'global_notification': []
        }

def add_to_media_collection(user_id, media_type, media_data):
    """Adds media to user's collection"""
    init_user_media_collection(user_id)
    user_media_collections[user_id][media_type].append(media_data)

def clear_media_collection(user_id, media_type):
    """Clears user's media collection"""
    if user_id in user_media_collections:
        user_media_collections[user_id][media_type] = []

def get_media_collection(user_id, media_type):
    """Gets user's media collection"""
    init_user_media_collection(user_id)
    return user_media_collections[user_id][media_type]

# -------------------- USER RIGHTS CHECK FUNCTIONS --------------------

def can_send_homework(user_id, group_name=None):
    """Checks if user can send homework"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user['can_send_homework'] == 1:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—Ç–∞—Ä–æ—Å—Ç–æ–π —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_send_notifications(user_id, group_name=None):
    """Checks if user can send notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user['can_send_notifications'] == 1:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—Ç–∞—Ä–æ—Å—Ç–æ–π —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_send_sport_notifications(user_id, group_name=None):
    """Checks if user can send sport notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user['can_send_sport_notifications'] == 1:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ñ–∏–∑–æ—Ä–≥–æ–º —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã
    if group_name and user['group_name'] == group_name:
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        if fizorg and fizorg['user_id'] == user_id:
            return True
    
    return False

def can_send_global_notifications(user_id):
    """Checks if user can send global notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    return user['can_send_global_notifications'] == 1

def can_delete_homework(user_id, group_name=None):
    """Checks if user can delete homework"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user['can_delete_homework'] == 1:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—Ç–∞—Ä–æ—Å—Ç–æ–π —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_delete_notifications(user_id, group_name=None):
    """Checks if user can delete notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user['can_delete_notifications'] == 1:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—Ç–∞—Ä–æ—Å—Ç–æ–π —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_delete_sport_notifications(user_id, group_name=None):
    """Checks if user can delete sport notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user['can_delete_sport_notifications'] == 1:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ñ–∏–∑–æ—Ä–≥–æ–º —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã
    if group_name and user['group_name'] == group_name:
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        if fizorg and fizorg['user_id'] == user_id:
            return True
    
    return False

def can_delete_suggestions(user_id):
    """Checks if user can delete suggestions"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    if user_id == DEVELOPER_ID:
        return True
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    return user['can_delete_suggestions'] == 1

def can_manage_users(user_id):
    """Checks if user can manage users"""
    user = get_user(user_id)
    if not user: return False
    
    # –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –º–æ–∂–µ—Ç –≤—Å—ë
    return user_id == DEVELOPER_ID

def get_user_role_display(user_id):
    """Gets user role display name"""
    user = get_user(user_id)
    if not user: return "–°—Ç—É–¥–µ–Ω—Ç"
    
    if user_id == DEVELOPER_ID:
        return "–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫"
    
    if user['custom_role_name']:
        return user['custom_role_name']
    
    role_map = {
        ROLE_STAROSTA: "–°—Ç–∞—Ä–æ—Å—Ç–∞",
        ROLE_DEPUTY_STAROSTA: "–ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã",
        ROLE_PHYSICAL_ORGANIZER: "–§–∏–∑–æ—Ä–≥",
        ROLE_STUDENT: "–°—Ç—É–¥–µ–Ω—Ç"
    }
    
    return role_map.get(user['role'], "–°—Ç—É–¥–µ–Ω—Ç")

# -------------------- CONTACT FUNCTIONS --------------------

async def contact_developer(update: Update):
    """Contact the developer"""
    try:
        await update.message.reply_text(
            "üë®‚Äçüíª <b>–°–≤—è–∑—å —Å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º</b>\n\n"
            "üìû Telegram: @imya_polbzovatela\n"
            "üí¨ –ü–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞ –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É",
            parse_mode='HTML'
        )
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ contact_developer: {e}")

async def contact_starosta(update: Update, group_name: str):
    """Contact the starosta for specific group"""
    try:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta:
            username = f"@{starosta['username']}" if starosta['username'] else starosta['first_name']
            await update.message.reply_text(
                f"üëë <b>–°–≤—è–∑—å —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π –≥—Ä—É–ø–ø—ã {group_name}</b>\n\n"
                f"üë§ –ò–º—è: {starosta['first_name']}\n"
                f"üìû Telegram: {username}",
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                f"‚ùå –î–ª—è –≥—Ä—É–ø–ø—ã {group_name} —Å—Ç–∞—Ä–æ—Å—Ç–∞ –µ—â–µ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω.\n"
                f"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É –¥–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è —Å—Ç–∞—Ä–æ—Å—Ç—ã."
            )
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ contact_starosta: {e}")

async def contact_deputy_starosta(update: Update, group_name: str):
    """Contact the deputy starosta for specific group"""
    try:
        deputy = get_group_role(group_name, ROLE_DEPUTY_STAROSTA)
        if deputy:
            username = f"@{deputy['username']}" if deputy['username'] else deputy['first_name']
            await update.message.reply_text(
                f"üëë <b>–°–≤—è–∑—å —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã –≥—Ä—É–ø–ø—ã {group_name}</b>\n\n"
                f"üë§ –ò–º—è: {deputy['first_name']}\n"
                f"üìû Telegram: {username}",
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                f"‚ùå –î–ª—è –≥—Ä—É–ø–ø—ã {group_name} –∑–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã –µ—â–µ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω.\n"
                f"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É –¥–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∑–∞–º–∞ —Å—Ç–∞—Ä–æ—Å—Ç—ã."
            )
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ contact_deputy_starosta: {e}")

async def contact_physical_organizer(update: Update, group_name: str):
    """Contact the physical organizer for specific group"""
    try:
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        if fizorg:
            username = f"@{fizorg['username']}" if fizorg['username'] else fizorg['first_name']
            await update.message.reply_text(
                f"üèÉ <b>–°–≤—è–∑—å —Å —Ñ–∏–∑–æ—Ä–≥–æ–º –≥—Ä—É–ø–ø—ã {group_name}</b>\n\n"
                f"üë§ –ò–º—è: {fizorg['first_name']}\n"
                f"üìû Telegram: {username}",
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                f"‚ùå –î–ª—è –≥—Ä—É–ø–ø—ã {group_name} —Ñ–∏–∑–æ—Ä–≥ –µ—â–µ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω.\n"
                f"–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É –¥–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è —Ñ–∏–∑–æ—Ä–≥–∞."
            )
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ contact_physical_organizer: {e}")

# -------------------- UPDATED SCHEDULE FUNCTIONS --------------------

def fetch_schedule_data():
    """Fetches schedule data from the new API endpoint"""
    try:
        url = "https://ops.pmk-online.ru/schedule/request.php?token=Uf40-ZZkp-t5Nv-ZD5v"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        print("–õ–û–ì: –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è —Å API...")
        resp = requests.get(url, headers=headers, timeout=15)
        resp.raise_for_status()
        data = resp.json()

        print(f"–õ–û–ì: –£—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ó–∞–Ω—è—Ç–∏–π: {len(data)}")
        return data
    except requests.exceptions.RequestException as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return None

def fetch_groups_list():
    """Fetches and updates the list of groups from schedule data"""
    global ALL_GROUPS, groups_cache, last_groups_check
    
    try:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return ALL_GROUPS
        
        # Extract unique groups from schedule data
        groups = set()
        for lesson in schedule_data:
            if 'group' in lesson:
                groups.add(lesson['group'])
        
        # Sort groups by course and number
        def group_sort_key(group_name):
            try:
                # Extract course number (first digit after dash)
                parts = group_name.split('-')
                if len(parts) > 1:
                    number_part = parts[1]
                    # Find first digit in number part
                    for char in number_part:
                        if char.isdigit():
                            course = int(char)
                            return (course, group_name)
            except:
                pass
            return (0, group_name)
        
        sorted_groups = sorted(groups, key=group_sort_key)
        ALL_GROUPS = sorted_groups
        groups_cache = sorted_groups
        last_groups_check = datetime.now(YEKATERINBURG_TZ)
        
        print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª–µ–Ω —Å–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø. –í—Å–µ–≥–æ –≥—Ä—É–ø–ø: {len(ALL_GROUPS)}")
        return ALL_GROUPS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –≥—Ä—É–ø–ø: {e}")
        return ALL_GROUPS

def parse_lesson_data(lesson):
    """Parses lesson data from the new API format"""
    try:
        if not isinstance(lesson, dict):
            return None
            
        lesson_data = {}
        
        # Basic lesson information
        lesson_data['group'] = lesson.get('group', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')
        lesson_data['number'] = lesson.get('number', 0)
        lesson_data['type'] = lesson.get('type', '–ó–∞–Ω—è—Ç–∏–µ')
        lesson_data['subject'] = lesson.get('subject', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
        lesson_data['campus'] = lesson.get('campus', '–ù–µ —É–∫–∞–∑–∞–Ω')
        lesson_data['room'] = lesson.get('room', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')
        lesson_data['teacher'] = lesson.get('teacher', '–ù–µ —É–∫–∞–∑–∞–Ω')
        
        # Parse dates and convert to Yekaterinburg timezone
        start_time_str = lesson.get('startTime', '')
        end_time_str = lesson.get('endTime', '')
        
        if start_time_str:
            try:
                start_time_utc = datetime.fromisoformat(start_time_str.replace('Z', '+00:00'))
                start_time_yekat = start_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['date'] = start_time_yekat.strftime('%Y-%m-%d')
                lesson_data['start_time'] = start_time_yekat.strftime('%H:%M')
                lesson_data['datetime'] = start_time_yekat
            except:
                lesson_data['date'] = '–ù–µ —É–∫–∞–∑–∞–Ω–∞'
                lesson_data['start_time'] = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
        
        if end_time_str:
            try:
                end_time_utc = datetime.fromisoformat(end_time_str.replace('Z', '+00:00'))
                end_time_yekat = end_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['end_time'] = end_time_yekat.strftime('%H:%M')
            except:
                lesson_data['end_time'] = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
        
        return lesson_data
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∑–∞–Ω—è—Ç–∏—è: {e}")
        return None

def filter_lessons_by_date(lessons, target_date):
    """Filters lessons for a specific date"""
    try:
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if lesson_date == target_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–Ω—è—Ç–∏–π: {e}")
        return []

def filter_lessons_by_week(lessons, start_date):
    """Filters lessons for a week starting from start_date"""
    try:
        end_date = start_date + timedelta(days=7)
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if start_date <= lesson_date <= end_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–Ω—è—Ç–∏–π –Ω–∞ –Ω–µ–¥–µ–ª—é: {e}")
        return []

def get_type_emoji(lesson_type):
    """Returns emoji for lesson type"""
    emoji_map = {
        '–ó–∞–Ω—è—Ç–∏–µ': 'üìö',
        '–ü—Ä–∞–∫—Ç–∏–∫–∞': 'üî¨', 
        '–õ–µ–∫—Ü–∏—è': 'üìñ',
        '–≠–∫–∑–∞–º–µ–Ω': 'üìù',
        '–ö–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è': 'üí¨',
        '–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞': '‚öóÔ∏è',
        '–°–µ–º–∏–Ω–∞—Ä': 'üí°',
        '–ó–∞—á–µ—Ç': '‚úÖ'
    }
    return emoji_map.get(lesson_type, 'üìö')

def format_schedule(lessons, title):
    """Formats schedule for display with the new format"""
    try:
        if not lessons:
            return f"‚úÖ –ù–µ—Ç –∑–∞–Ω—è—Ç–∏–π –¥–ª—è {title.split('(')[-1].split(')')[0]}"
        
        # Sort lessons by date and time
        lessons.sort(key=lambda x: (x.get('datetime', datetime.min), x.get('number', 0)))
        
        result = [f"<b>{title}</b>\n"]
        current_date = None
        
        for lesson in lessons:
            try:
                if 'datetime' in lesson:
                    date_str = lesson['datetime'].strftime('%d.%m.%Y')
                    day_names = ['–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä–≥', '–ü—è—Ç–Ω–∏—Ü–∞', '–°—É–±–±–æ—Ç–∞', '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ']
                    day_of_week = day_names[lesson['datetime'].weekday()]
                    
                    if date_str != current_date:
                        current_date = date_str
                        result.append(f"\nüìÖ <b>{date_str} ({day_of_week})</b>")
                    
                    type_emoji = get_type_emoji(lesson['type'])
                    start_time = lesson.get('start_time', '‚ùì')
                    end_time = lesson.get('end_time', '‚ùì')
                    
                    lesson_text = (
                        f"    {type_emoji} {lesson['type']}\n"
                        f"    ‚è∞ {start_time}-{end_time} | {lesson['number']} –ø–∞—Ä–∞\n"
                        f"    üìö {lesson['subject']}\n"
                        f"    üë®‚Äçüè´ {lesson['teacher']}\n"
                        f"    üö™ {lesson['room']}({lesson['campus']})\n"
                    )
                    result.append(lesson_text)
            except Exception as e:
                print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—É: {e}")
                continue
        
        result.append(f"\nüìä <b>–í—Å–µ–≥–æ –∑–∞–Ω—è—Ç–∏–π:</b> {len(lessons)}")
        return "\n".join(result)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        return f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {str(e)}"

def get_schedule(period, group_name):
    """Gets and formats the schedule with the new API"""
    try:
        global schedule_cache, last_schedule_check
        
        # Check cache
        now = datetime.now(YEKATERINBURG_TZ)
        if last_schedule_check is None or (now - last_schedule_check).total_seconds() > 3600:
            print(f"–õ–û–ì: –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}")
            schedule_data = fetch_schedule_data()
            if schedule_data:
                schedule_cache = schedule_data
                last_schedule_check = now
                print("–õ–û–ì: –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –∏–∑ API")
            else:
                print("–õ–û–ì: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à –µ—Å–ª–∏ –µ—Å—Ç—å")
        else:
            schedule_data = schedule_cache
            print("–õ–û–ì: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
        
        if not schedule_data:
            return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        
        # Filter lessons for the specific group
        group_lessons = [lesson for lesson in schedule_data if lesson.get('group') == group_name]
        
        if not group_lessons:
            return f"‚ùå –ù–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}"
        
        # Filter lessons by period
        today_yekat = datetime.now(YEKATERINBURG_TZ).date()
        
        if period == 'üìÖ –°–µ–≥–æ–¥–Ω—è':
            filtered_lessons = filter_lessons_by_date(group_lessons, today_yekat)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ({group_name})"
        elif period == 'üìÖ –ó–∞–≤—Ç—Ä–∞':
            tomorrow_yekat = today_yekat + timedelta(days=1)
            filtered_lessons = filter_lessons_by_date(group_lessons, tomorrow_yekat)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({group_name})"
        elif period == 'üìÖ –ù–µ–¥–µ–ª—è':
            filtered_lessons = filter_lessons_by_week(group_lessons, today_yekat)
            title = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é ({group_name})"
        else:
            # For "–í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ" parse all lessons
            filtered_lessons = []
            for lesson in group_lessons:
                parsed = parse_lesson_data(lesson)
                if parsed:
                    filtered_lessons.append(parsed)
            title = f"üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ ({group_name})"
        
        return format_schedule(filtered_lessons, title)
        
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {str(e)}")
        return f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {str(e)}"

async def check_schedule_changes(context: ContextTypes.DEFAULT_TYPE):
    """Checks for schedule changes with the new API"""
    global schedule_cache, last_schedule_check
    
    print("–õ–û–ì: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏...")
    new_schedule = fetch_schedule_data()
    
    if not new_schedule:
        print("–õ–û–ì: –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è")
        return

    # Extract groups from new schedule
    new_groups = set()
    for lesson in new_schedule:
        if 'group' in lesson:
            new_groups.add(lesson['group'])
    
    # Compare with old groups
    old_groups = set()
    for lesson in schedule_cache:
        if 'group' in lesson:
            old_groups.add(lesson['group'])
    
    # Check for new or removed groups
    added_groups = new_groups - old_groups
    removed_groups = old_groups - new_groups
    
    if added_groups or removed_groups:
        print(f"–õ–û–ì: –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø–∞—Ö")
        
        for group_name in added_groups:
            change_message = f"üîÑ <b>–î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è –≥—Ä—É–ø–ø–∞: {group_name}</b>\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É' –¥–ª—è –≤—ã–±–æ—Ä–∞ —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã."
            
            # Notify special users about new group
            special_users = [u for u in get_all_users() if u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")
        
        for group_name in removed_groups:
            change_message = f"üîÑ <b>–ì—Ä—É–ø–ø–∞ {group_name} —É–¥–∞–ª–µ–Ω–∞ –∏–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è</b>\n\n–£—á–µ–Ω–∏–∫–∏ —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã –º–æ–≥—É—Ç –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –≥—Ä—É–ø–ø—É."
            
            # Notify special users about removed group
            special_users = [u for u in get_all_users() if u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

    schedule_cache = new_schedule
    last_schedule_check = datetime.now(YEKATERINBURG_TZ)

async def send_daily_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends daily schedule at 19:00 with the new API"""
    print("–õ–û–ì: –û—Ç–ø—Ä–∞–≤–∫–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        tomorrow_yekat = (datetime.now(YEKATERINBURG_TZ) + timedelta(days=1)).date()
        tomorrow_lessons = filter_lessons_by_date(lessons, tomorrow_yekat)
        
        if tomorrow_lessons:
            schedule_text = format_schedule(tomorrow_lessons, f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ ({group_name})")
            
            homeworks = get_homeworks(group_name)
            if homeworks:
                homework_text = "\n\nüìù <b>–î–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è:</b>\n"
                for hw in homeworks[:3]:
                    homework_text += f"‚Ä¢ {hw['subject']}: {hw['task']} (–¥–æ {hw['deadline']})\n"
                schedule_text += homework_text
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    # Check user notification settings
                    settings = get_user_notification_settings(user['user_id'])
                    if settings and settings['tomorrow_schedule']:
                        await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_morning_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends morning schedule at 07:00 with the new API"""
    print("–õ–û–ì: –û—Ç–ø—Ä–∞–≤–∫–∞ —É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        today_lessons = filter_lessons_by_date(lessons, datetime.now(YEKATERINBURG_TZ).date())
        
        if today_lessons:
            schedule_text = format_schedule(today_lessons, f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è ({group_name})")
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    # Check user notification settings
                    settings = get_user_notification_settings(user['user_id'])
                    if settings and settings['today_schedule']:
                        await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

# -------------------- UPDATED CALL SCHEDULE FUNCTIONS --------------------

async def show_call_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows the appropriate call schedule based on day of week"""
    try:
        now = datetime.now(YEKATERINBURG_TZ)
        day_of_week = now.weekday()  # 0=Monday, 6=Sunday
        
        if day_of_week == 5:  # Saturday
            schedule_text = format_call_schedule(SATURDAY_CALL_SCHEDULE, "–°—É–±–±–æ—Ç–∞")
        elif day_of_week == 6:  # Sunday
            schedule_text = "üîî <b>–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ - –≤—ã—Ö–æ–¥–Ω–æ–π –¥–µ–Ω—å</b>"
        else:  # Monday-Friday
            schedule_text = format_call_schedule(REGULAR_CALL_SCHEDULE, "–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫-–ü—è—Ç–Ω–∏—Ü–∞")
        
        await update.message.reply_text(schedule_text, parse_mode='HTML')
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_call_schedule: {e}")

def format_call_schedule(schedule, day_type):
    """Formats call schedule for display"""
    result = [f"üîî <b>–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ ({day_type})</b>\n\n"]
    
    if isinstance(schedule, list):
        # –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —Å —Å–ø–∏—Å–∫–æ–º
        for item in schedule:
            if item['type'] == 'lesson':
                part_text = " (1-—è —á–∞—Å—Ç—å)" if item['part'] == 1 else " (2-—è —á–∞—Å—Ç—å)"
                result.append(f"{item['number']} –ø–∞—Ä–∞{part_text}: {item['start']} - {item['end']}")
            else:  # break
                result.append(f"üïì –ü–µ—Ä–µ–º–µ–Ω–∞: {item['start']} - {item['end']} ({item['duration']} –º–∏–Ω)")
    else:
        # –°—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç (–¥–ª—è —Å—É–±–±–æ—Ç—ã –∏ –∫–æ—Ä–æ—Ç–∫–∏—Ö –¥–Ω–µ–π)
        for key, value in schedule.items():
            if isinstance(key, int):  # Lesson
                result.append(f"{key} –ø–∞—Ä–∞: {value['start']} - {value['end']}")
            else:  # Break
                if 'duration' in value:
                    result.append(f"üïì –ü–µ—Ä–µ–º–µ–Ω–∞: {value['start']} - {value['end']} ({value['duration']} –º–∏–Ω)")
                else:
                    result.append(f"üïì –ü–µ—Ä–µ–º–µ–Ω–∞: {value['start']} - {value['end']}")
    
    return "\n".join(result)

# -------------------- LESSON NOTIFICATION FUNCTIONS --------------------

async def check_lesson_notifications(context: ContextTypes.DEFAULT_TYPE):
    """Checks if any lessons are starting in 5 minutes and sends notifications"""
    try:
        global schedule_cache
        
        if not schedule_cache:
            return
        
        now = datetime.now(YEKATERINBURG_TZ)
        today = now.date()
        
        # Group lessons by group name
        groups_lessons = {}
        for lesson in schedule_cache:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if lesson_date == today:
                    group_name = parsed['group']
                    if group_name not in groups_lessons:
                        groups_lessons[group_name] = []
                    groups_lessons[group_name].append(parsed)
        
        for group_name, lessons in groups_lessons.items():
            for lesson in lessons:
                lesson_time = lesson['datetime']
                time_diff = (lesson_time - now).total_seconds()
                
                # Check if lesson starts in 5 minutes (300 seconds)
                if 240 <= time_diff <= 300:  # 4-5 minutes to avoid missing due to timing
                    await send_lesson_notification(context.bot, group_name, lesson)
    
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ check_lesson_notifications: {e}")

async def send_lesson_notification(bot, group_name, lesson):
    """Sends notification about upcoming lesson"""
    try:
        notification_text = (
            f"üïì <b>–ß–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ø–∞—Ä–∞</b>\n\n"
            f"üìö <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {lesson['subject']}\n"
            f"üë®‚Äçüè´ <b>–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å:</b> {lesson['teacher']}\n"
            f"üö™ <b>–ö–∞–±–∏–Ω–µ—Ç:</b> {lesson['room']} ({lesson['campus']})\n"
            f"‚è∞ <b>–í—Ä–µ–º—è:</b> {lesson['start_time']}-{lesson['end_time']}\n"
            f"üìñ <b>–¢–∏–ø:</b> {lesson['type']}"
        )
        
        users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
        
        for user in users:
            try:
                # Check user notification settings
                settings = get_user_notification_settings(user['user_id'])
                if settings and settings['lesson_start']:
                    await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
            except Exception as e:
                print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")
    
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ send_lesson_notification: {e}")

# -------------------- NOTIFICATION SETTINGS FUNCTIONS --------------------

async def show_notification_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows notification settings menu"""
    try:
        user_id = update.effective_user.id
        settings = get_user_notification_settings(user_id)
        
        if not settings:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.")
            return
        
        keyboard = [
            [InlineKeyboardButton(f"üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–∞—á–∞–ª–µ –ø–∞—Ä—ã: {'‚úÖ' if settings['lesson_start'] else '‚ùå'}", callback_data='toggle_lesson_start')],
            [InlineKeyboardButton(f"üìù –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤–æ–º –î–ó: {'‚úÖ' if settings['new_homework'] else '‚ùå'}", callback_data='toggle_new_homework')],
            [InlineKeyboardButton(f"üì¢ –í–∞–∂–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {'‚úÖ' if settings['important_notifications'] else '‚ùå'}", callback_data='toggle_important_notifications')],
            [InlineKeyboardButton(f"üèÉ –°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {'‚úÖ' if settings['sport_notifications'] else '‚ùå'}", callback_data='toggle_sport_notifications')],
            [InlineKeyboardButton(f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ –≤–µ—á–µ—Ä–æ–º: {'‚úÖ' if settings['tomorrow_schedule'] else '‚ùå'}", callback_data='toggle_tomorrow_schedule')],
            [InlineKeyboardButton(f"üåÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è —É—Ç—Ä–æ–º: {'‚úÖ' if settings['today_schedule'] else '‚ùå'}", callback_data='toggle_today_schedule')],
            [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data='done_notification_settings')]
        ]
        
        await update.message.reply_text(
            "üîß <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π</b>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ, –∫–∞–∫–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∞—Ç—å:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_NOTIFICATION_SETTINGS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_notification_settings: {e}")
        return ConversationHandler.END

async def handle_notification_settings_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles notification settings callbacks"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        if query.data == 'done_notification_settings':
            await query.edit_message_text("‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!")
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        # Toggle settings
        setting_map = {
            'toggle_lesson_start': 'lesson_start',
            'toggle_new_homework': 'new_homework',
            'toggle_important_notifications': 'important_notifications',
            'toggle_sport_notifications': 'sport_notifications',
            'toggle_tomorrow_schedule': 'tomorrow_schedule',
            'toggle_today_schedule': 'today_schedule'
        }
        
        if query.data in setting_map:
            current_settings = get_user_notification_settings(user_id)
            current_value = current_settings[setting_map[query.data]]
            new_value = 1 - current_value
            
            if update_user_notification_settings(user_id, setting_map[query.data], new_value):
                # Update the message with new settings
                return await show_notification_settings(update, context)
            else:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫.")
        
        return AWAITING_NOTIFICATION_SETTINGS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_notification_settings_callback: {e}")
        return ConversationHandler.END

# -------------------- BIRTHDAY FUNCTIONS --------------------

async def ask_birthday_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks user to input birthday date"""
    user_id = update.effective_user.id
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    user_data = get_user(user_id)
    if not user_data or not user_data['group_name']:
        await update.message.reply_text("‚ùå –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ—é –≥—Ä—É–ø–ø—É!")
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    await update.message.reply_text(
        "üéÇ <b>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è</b>\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Å–≤–æ–µ–≥–æ —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>–î–î.–ú–ú</b>\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: 15.09 (–¥–ª—è 15 —Å–µ–Ω—Ç—è–±—Ä—è)\n\n"
        "–ë–æ—Ç –±—É–¥–µ—Ç –ø–æ–∑–¥—Ä–∞–≤–ª—è—Ç—å –≤–∞—Å –≤ –≤–∞—à –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è –∏ —É–≤–µ–¥–æ–º–ª—è—Ç—å –≤–∞—à—É –≥—Ä—É–ø–ø—É!",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
    )
    return AWAITING_BIRTHDAY

async def handle_birthday_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles birthday date input"""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    if text == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)
    
    try:
        if not re.match(r'^\d{1,2}\.\d{1,2}$', text):
            raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç")
        
        day, month = text.split('.')
        day = int(day)
        month = int(month)
        
        if month < 1 or month > 12:
            raise ValueError("–ú–µ—Å—è—Ü –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 1 –¥–æ 12")
        if day < 1 or day > 31:
            raise ValueError("–î–µ–Ω—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 1 –¥–æ 31")
        
        if month == 2 and day > 29:
            raise ValueError("–í —Ñ–µ–≤—Ä–∞–ª–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ 29 –¥–Ω–µ–π")
        elif month in [4, 6, 9, 11] and day > 30:
            raise ValueError("–í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ 30 –¥–Ω–µ–π")
            
        birthday_date = f"{day:02d}.{month:02d}"
        
        if set_user_birthday(user_id, birthday_date):
            await update.message.reply_text(
                f"‚úÖ –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {birthday_date}\n"
                f"–¢–µ–ø–µ—Ä—å –±–æ—Ç –±—É–¥–µ—Ç –ø–æ–∑–¥—Ä–∞–≤–ª—è—Ç—å –≤–∞—Å –∫–∞–∂–¥—ã–π –≥–æ–¥!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è")
            
    except ValueError as e:
        await update.message.reply_text(
            f"‚ùå {str(e)}. –í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ <b>–î–î.–ú–ú</b>\n"
            "–ü—Ä–∏–º–µ—Ä: 15.09 (–¥–ª—è 15 —Å–µ–Ω—Ç—è–±—Ä—è)",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    except Exception as e:
        await update.message.reply_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def check_birthdays(context: ContextTypes.DEFAULT_TYPE):
    """Checks for birthdays and sends notifications"""
    print("–õ–û–ì: –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–π —Ä–æ–∂–¥–µ–Ω–∏–π...")
    
    today_birthdays = get_today_birthdays()
    
    for birthday_user in today_birthdays:
        user_id = birthday_user['user_id']
        user_name = birthday_user['first_name']
        username = f"@{birthday_user['username']}" if birthday_user['username'] else user_name
        group_name = birthday_user['group_name']
        
        try:
            await context.bot.send_message(
                user_id,
                f"üéÇ <b>–° –î–ù–ï–ú –†–û–ñ–î–ï–ù–ò–Ø, {user_name}!</b>\n\n"
                f"–ñ–µ–ª–∞–µ–º –≤–∞–º –≤—Å–µ–≥–æ —Å–∞–º–æ–≥–æ –ª—É—á—à–µ–≥–æ! üéâ",
                parse_mode='HTML'
            )
            print(f"–õ–û–ì: –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}")
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
        
        users_in_group = get_db_connection().execute(
            'SELECT user_id FROM users WHERE group_name = ? AND user_id != ?', 
            (group_name, user_id)
        ).fetchall()
        
        for group_user in users_in_group:
            try:
                await context.bot.send_message(
                    group_user['user_id'],
                    f"üéâ –£ {user_name} ({username}) —Å–µ–≥–æ–¥–Ω—è –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è!\n\n"
                    f"–ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø–æ–∑–¥—Ä–∞–≤–∏—Ç—å! üòä",
                    parse_mode='HTML'
                )
            except Exception as e:
                print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {group_user['user_id']}: {e}")
    
    if today_birthdays:
        print(f"–õ–û–ì: –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {len(today_birthdays)} –¥–Ω–µ–π —Ä–æ–∂–¥–µ–Ω–∏–π")

# -------------------- GLOBAL NOTIFICATION FUNCTIONS --------------------

async def ask_global_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for global notification details (only for developer and authorized users)"""
    user_id = update.effective_user.id
    
    if not can_send_global_notifications(user_id):
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return ConversationHandler.END
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    clear_media_collection(user_id, 'global_notification')
    
    await update.message.reply_text(
        "üåç <b>–û—Ç–ø—Ä–∞–≤–∫–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º</b>\n\n"
        "–ù–∞–ø–∏—à–∏ –≤–∞–∂–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –í–°–ï–ú —É—á–µ–Ω–∏–∫–∞–º –í–°–ï–• –≥—Ä—É–ø–ø.\n"
        "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
    )
    return AWAITING_GLOBAL_NOTIFICATION

async def handle_global_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles global notification input"""
    user_id = update.effective_user.id
    
    if not can_send_global_notifications(user_id):
        await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return await cancel_conversation(update, context)
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return AWAITING_GLOBAL_NOTIFICATION
    
    text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
    
    if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
        return await cancel_conversation(update, context)
    
    if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
        media_collection = get_media_collection(user_id, 'global_notification')
        notification_text = context.user_data.get('global_notification_text', '')
        
        if not notification_text:
            await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
            return AWAITING_GLOBAL_NOTIFICATION

        global_notification_id = add_global_notification(notification_text, user_id)
        
        if global_notification_id:
            for media_item in media_collection:
                add_global_notification_media(global_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            await update.message.reply_text("‚úÖ –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
            await send_global_notification_to_all(context.bot, global_notification_id, notification_text, user_id)
            
            clear_media_collection(user_id, 'global_notification')
            context.user_data.pop('global_notification_text', None)
        else:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    if update.message.photo:
        photo = update.message.photo[-1]
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'photo',
            'id': photo.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.video:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'video',
            'id': update.message.video.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.document:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'document',
            'id': update.message.document.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    if text and text.strip():
        context.user_data['global_notification_text'] = text
        await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
    return AWAITING_GLOBAL_NOTIFICATION

async def send_global_notification_to_all(bot, global_notification_id, message, added_by):
    """Sends a global notification to all users"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    global_text = (
        f"üåç <b>–ì–õ–û–ë–ê–õ–¨–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n"
        f"{message}\n\n"
        f"üë§ <b>–û—Ç:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM global_notification_media WHERE global_notification_id = ?', (global_notification_id,)).fetchall()
    conn.close()
    
    users = get_all_users()
    
    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['important_notifications']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=global_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=global_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=global_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=global_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=global_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=global_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], global_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

# -------------------- CORE BOT FUNCTIONS --------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for the /start command with dynamic groups"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        add_user(user_id, user.username, user.first_name, user.last_name)
        user_data = get_user(user_id)
        
        # Update groups list
        fetch_groups_list()
        
        if not user_data or not user_data['group_name'] or user_data['group_name'] not in ALL_GROUPS:
            print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user_id}) –Ω–µ –∏–º–µ–µ—Ç –≥—Ä—É–ø–ø—ã, –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –≤—ã–±–æ—Ä –≥—Ä—É–ø–ø—ã.")
            return await ask_user_group(update, context)

        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user.id}) –≤–µ—Ä–Ω—É–ª—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ start_command: {e}")
        try:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def ask_user_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks the user to select their group with dynamic list"""
    try:
        # Update groups list from API
        groups = fetch_groups_list()
        if not groups:
            await update.message.reply_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                reply_markup=ReplyKeyboardRemove()
            )
            return ConversationHandler.END
        
        # Create keyboard with groups
        keyboard = [groups[i:i+3] for i in range(0, len(groups), 3)]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
        
        message_source = update.callback_query.message if update.callback_query else update.message
        await message_source.reply_text(
            "üëã –í—ã–±–µ—Ä–∏ —Å–≤–æ—é –≥—Ä—É–ø–ø—É:",
            reply_markup=reply_markup
        )
        
        return AWAITING_GROUP
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_user_group: {e}")
        return ConversationHandler.END

async def handle_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the user's group selection with dynamic list"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_GROUP
        
        group_name = update.message.text
        
        # Update groups list to ensure we have the latest
        current_groups = fetch_groups_list()
        
        if group_name not in current_groups:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ –≥—Ä—É–ø–ø—É –∏–∑ —Å–ø–∏—Å–∫–∞:",
                reply_markup=ReplyKeyboardMarkup([current_groups[i:i+3] for i in range(0, len(current_groups), 3)], 
                                               resize_keyboard=True, one_time_keyboard=True)
            )
            return AWAITING_GROUP
        
        update_user_group(user_id, group_name)
        
        await update.message.reply_text(
            f"‚úÖ –ì—Ä—É–ø–ø–∞ {group_name} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!",
            reply_markup=ReplyKeyboardRemove()
        )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_group_selection: {e}")
        return ConversationHandler.END

async def show_main_menu(update: Update, user_id: int):
    """Displays the main menu based on user rights with error handling"""
    try:
        user_data = get_user(user_id)
        if not user_data:
            await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /start –µ—â–µ —Ä–∞–∑.")
            return

        role = user_data['role']
        group_name = user_data['group_name']
        
        welcome_text = "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!"
        
        if user_id == DEVELOPER_ID:
            welcome_text = "üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫!"
        elif role == ROLE_STAROSTA:
            welcome_text = "üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –°—Ç–∞—Ä–æ—Å—Ç–∞!"
        elif role == ROLE_DEPUTY_STAROSTA:
            welcome_text = "üëë –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –ó–∞–º –°—Ç–∞—Ä–æ—Å—Ç—ã!"
        elif role == ROLE_PHYSICAL_ORGANIZER:
            welcome_text = "üèÉ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, –§–∏–∑–æ—Ä–≥!"
        elif user_data['custom_role_name']:
            welcome_text = f"üîß –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {user_data['custom_role_name']}!"

        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∞–≤
        if user_id == DEVELOPER_ID:
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó', 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', 'üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º'],
                ['–£–¥–∞–ª–∏—Ç—å –î–ó', '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è'],
                ['–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', '–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', '–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É', 'üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π'],
                ['üëë –ù–∞–∑–Ω–∞—á–∏—Ç—å —Ä–æ–ª—å', 'üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏']
            ]
        elif can_manage_users(user_id):
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó', 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', 'üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º'],
                ['–£–¥–∞–ª–∏—Ç—å –î–ó', '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è'],
                ['–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è', '–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É', 'üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π'],
                ['üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏']
            ]
        elif can_send_homework(user_id, group_name) and can_send_notifications(user_id, group_name):
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó', 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ'],
                ['–£–¥–∞–ª–∏—Ç—å –î–ó', '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É', 'üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π']
            ]
        elif can_send_sport_notifications(user_id, group_name):
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üèÉ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É', 'üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π']
            ]
        elif can_send_global_notifications(user_id):
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
                ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º', 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π'],
                ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã', 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ñ–∏–∑–æ—Ä–≥–æ–º'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É', 'üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π']
            ]
        else:
            keyboard = [
                ['üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ', 'üìù –î–ó'],
                ['‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è', 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é'],
                ['üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É', 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤'],
                ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º', 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π'],
                ['üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã', 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ñ–∏–∑–æ—Ä–≥–æ–º'],
                ['üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è', 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É', 'üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π']
            ]
        
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        
        message_source = update.callback_query.message if update.callback_query else update.message
        await message_source.reply_text(welcome_text, reply_markup=reply_markup)
        
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_main_menu: {e}")
        try:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–µ–Ω—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /start",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels the current conversation"""
    try:
        user = update.effective_user
        user_id = user.id
        
        await update.message.reply_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ cancel_conversation: {e}")
        return ConversationHandler.END

async def handle_simple_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for simple text messages with error handling"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        text = update.message.text
        user_data = get_user(user_id)
        
        print(f"–õ–û–ì: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.first_name} (ID: {user_id}) –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ: '{text}'")
        
        if not user_data or not user_data['group_name'] or user_data['group_name'] not in ALL_GROUPS:
            add_user(user_id, user.username, user.first_name, user.last_name)
            return await ask_user_group(update, context)

        role = user_data['role']
        group_name = user_data['group_name']
        
        if text == 'üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ':
            await show_schedule_periods(update, user_id)
        
        elif text == 'üìù –î–ó':
            await show_homework(update, group_name)
        
        elif text == '‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è':
            await show_information(update, group_name, role)

        elif text == 'üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è' and can_delete_suggestions(user_id):
            await show_suggestions(update)
        
        elif text == '–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await show_users_list(update)

        elif text == 'üí∞ –î–∞—Ç—å –¥–µ–Ω—é–∂–∫—É':
            donate_text = "–ï—Å–ª–∏ –Ω–µ –∂–∞–ª–∫–æ, –º–æ–∂–µ—à—å –¥–∞—Ç—å —Ä–∞–∑—Ä–∞–±—É –±–æ—Ç–∞ –¥–µ–Ω—é–∂–∫—É –Ω–∞ –¥–∞–ª—å–Ω–µ–π—à–µ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ –±–æ—Ç–∞ –∏ –Ω–∞ –ø–æ–∫—É—à–∞—Ç—åüòä"
            keyboard = [[InlineKeyboardButton("üí∏ –ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å –∞–≤—Ç–æ—Ä–∞", url="https://www.donationalerts.com/r/ax_hikitka")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(donate_text, reply_markup=reply_markup)

        elif text == 'üîî –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤':
            await show_call_schedule(update, context)
        
        elif text == 'üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π':
            return await show_notification_settings(update, context)
        
        elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º':
            await contact_developer(update)
        
        elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å–æ —Å—Ç–∞—Ä–æ—Å—Ç–æ–π':
            await contact_starosta(update, group_name)

        elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –∑–∞–º–æ–º —Å—Ç–∞—Ä–æ—Å—Ç—ã':
            await contact_deputy_starosta(update, group_name)
        
        elif text == 'üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å —Ñ–∏–∑–æ—Ä–≥–æ–º':
            await contact_physical_organizer(update, group_name)
        
        elif text in ['üìÖ –°–µ–≥–æ–¥–Ω—è', 'üìÖ –ó–∞–≤—Ç—Ä–∞', 'üìÖ –ù–µ–¥–µ–ª—è', 'üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ']:
            await handle_schedule_period(update, context, group_name)
    
        elif text == 'üîô –ù–∞–∑–∞–¥':
            await show_main_menu(update, user_id)

        elif text == '–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è' and user_id == DEVELOPER_ID:
            await delete_user_menu(update, context)

        elif text == '–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è' and can_delete_sport_notifications(user_id, group_name):
            await delete_sport_notification_menu(update, context)
            
        elif text == '–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è' and can_delete_suggestions(user_id):
            await delete_suggestions_menu(update, context)
            
        elif text == '–£–¥–∞–ª–∏—Ç—å –î–ó' and can_delete_homework(user_id, group_name):
            await delete_homework_menu(update, context)

        elif text == '–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ' and can_delete_notifications(user_id, group_name):
            await delete_notification_menu(update, context)
        
        elif text == 'üëë –ù–∞–∑–Ω–∞—á–∏—Ç—å —Ä–æ–ª—å' and user_id == DEVELOPER_ID:
            await start_role_assignment(update, context)
            
        elif text == 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó' and can_send_homework(user_id, group_name):
            await ask_homework_details(update, context)
        
        elif text == 'üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ' and can_send_notifications(user_id, group_name):
            await ask_notification_details(update, context)
            
        elif text == 'üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º' and can_send_global_notifications(user_id):
            await ask_global_notification_details(update, context)
        
        elif text == 'üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é':
            await ask_suggestion_details(update, context)
        
        elif text == 'üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è':
            await ask_birthday_date(update, context)
        
        elif text == 'üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É':
            return await ask_user_group(update, context)
            
        elif text == 'üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await manage_user_rights_menu(update, context)

        else:
            await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ üëá")
    
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_simple_message: {e}")
        try:
            await update.message.reply_text(
                "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

# -------------------- SCHEDULE DISPLAY FUNCTIONS --------------------

async def show_schedule_periods(update: Update, user_id: int):
    """Shows the schedule period selection"""
    try:
        keyboard = [
            ['üìÖ –°–µ–≥–æ–¥–Ω—è', 'üìÖ –ó–∞–≤—Ç—Ä–∞'],
            ['üìÖ –ù–µ–¥–µ–ª—è', 'üìÖ –í—Å–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ'],
            ['üîô –ù–∞–∑–∞–¥']
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text("–í—ã–±–µ—Ä–∏ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è:", reply_markup=reply_markup)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_schedule_periods: {e}")

async def handle_schedule_period(update: Update, context: ContextTypes.DEFAULT_TYPE, group_name: str):
    """Handles the schedule period selection with error handling"""
    try:
        text = update.message.text
        await update.message.reply_text("‚è≥ –ó–∞–≥—Ä—É–∂–∞—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ...", reply_markup=ReplyKeyboardRemove())
        schedule = get_schedule(text, group_name)
        await update.message.reply_text(schedule, parse_mode='HTML')
        await show_main_menu(update, update.effective_user.id)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_schedule_period: {e}")
        await update.message.reply_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            parse_mode='HTML'
        )

# -------------------- MESSAGE SENDING FUNCTIONS --------------------

async def ask_homework_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for homework details to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_homework(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –î–ó.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'homework')
        
        await update.message.reply_text(
            "üìù <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –î–ó</b>\n\n"
            "–ù–∞–ø–∏—à–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "<b>–ü—Ä–µ–¥–º–µ—Ç</b>\n"
            "<b>–ó–∞–¥–∞–Ω–∏–µ</b>\n"
            "<b>–°—Ä–æ–∫ —Å–¥–∞—á–∏</b>\n\n"
            "–ü—Ä–∏–º–µ—Ä:\n"
            "–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞\n"
            "–†–µ—à–∏—Ç—å –∑–∞–¥–∞—á–∏ 1-10 –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 45\n"
            "–î–æ 15.09\n\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –î–ó.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_homework_details: {e}")
        return ConversationHandler.END

async def ask_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for information to send to everyone"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'notification')
        
        await update.message.reply_text(
            "üì¢ <b>–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤—Å–µ–º</b>\n\n"
            "–ù–∞–ø–∏—à–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º —É—á–µ–Ω–∏–∫–∞–º.\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_INFO
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_notification_details: {e}")
        return ConversationHandler.END

async def ask_sport_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a sport notification to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'sport')
        
        await update.message.reply_text(
            "üèÉ <b>–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è</b>\n\n"
            "–ù–∞–ø–∏—à–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º —É—á–µ–Ω–∏–∫–∞–º.\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_SPORT
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_sport_notification_details: {e}")
        return ConversationHandler.END

async def ask_suggestion_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a suggestion to improve the bot"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'suggestion')
        
        await update.message.reply_text(
            "üí° <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –±–æ—Ç–∞</b>\n\n"
            "–ù–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –±–æ—Ç–∞:\n\n"
            "–ß—Ç–æ –±—ã —Ç—ã —Ö–æ—Ç–µ–ª –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å?\n"
            "–ú–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é. –û—Ç–ø—Ä–∞–≤—å –≤—Å–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã, –∞ –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞'], ['‚úÖ –ì–æ—Ç–æ–≤–æ']], resize_keyboard=True)
        )
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ ask_suggestion_details: {e}")
        return ConversationHandler.END

# -------------------- MESSAGE HANDLING FUNCTIONS --------------------

async def handle_homework_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles homework input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_HOMEWORK
        
        if not can_send_homework(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'homework')
            homework_text = context.user_data.get('homework_text', '')
            
            if not homework_text and not media_collection:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ –î–ó –∏–ª–∏ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã.")
                return AWAITING_HOMEWORK
                
            if not homework_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ –î–ó.")
                return AWAITING_HOMEWORK
                
            lines = homework_text.strip().split('\n')
            if len(lines) >= 3:
                subject = lines[0].strip()
                task = lines[1].strip()
                deadline = lines[2].strip()
                
                homework_id = add_homework(subject, task, deadline, group_name, user_id)
                
                if homework_id:
                    for media_item in media_collection:
                        add_homework_media(homework_id, media_item['type'], media_item['id'], media_item.get('caption'))
                    
                    await update.message.reply_text("‚úÖ –î–ó –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
                    await send_homework_to_all(context.bot, homework_id, subject, task, deadline, group_name, user_id)
                    
                    clear_media_collection(user_id, 'homework')
                    context.user_data.pop('homework_text', None)
                else:
                    await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –î–ó.")
                
                await show_main_menu(update, user_id)
                return ConversationHandler.END
            else:
                await update.message.reply_text("‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ù—É–∂–Ω–æ 3 —Å—Ç—Ä–æ–∫–∏: –ø—Ä–µ–¥–º–µ—Ç, –∑–∞–¥–∞–Ω–∏–µ, —Å—Ä–æ–∫")
                return AWAITING_HOMEWORK
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'homework', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        elif update.message.video:
            add_to_media_collection(user_id, 'homework', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        elif update.message.document:
            add_to_media_collection(user_id, 'homework', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        
        if text and text.strip():
            context.user_data['homework_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç –î–ó —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_HOMEWORK
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å –æ–ø–∏—Å–∞–Ω–∏–µ –∫ –î–ó.")
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_homework_input: {e}")
        return AWAITING_HOMEWORK

async def handle_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_INFO
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'notification')
            notification_text = context.user_data.get('notification_text', '')
            
            if not notification_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
                return AWAITING_INFO

            notification_id = add_notification(notification_text, group_name, user_id)
            
            if notification_id:
                for media_item in media_collection:
                    add_notification_media(notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
                await send_notification_to_all(context.bot, notification_id, notification_text, group_name, user_id)
                
                clear_media_collection(user_id, 'notification')
                context.user_data.pop('notification_text', None)
            else:
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'notification', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        elif update.message.video:
            add_to_media_collection(user_id, 'notification', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        elif update.message.document:
            add_to_media_collection(user_id, 'notification', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        
        if text and text.strip():
            context.user_data['notification_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_INFO
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        return AWAITING_INFO
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_notification_input: {e}")
        return AWAITING_INFO

async def handle_sport_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles sport notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SPORT
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']

        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'sport')
            sport_text = context.user_data.get('sport_text', '')
            
            if not sport_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
                return AWAITING_SPORT
        
            sport_notification_id = add_sport_notification(sport_text, group_name, user_id)
            
            if sport_notification_id:
                for media_item in media_collection:
                    add_sport_notification_media(sport_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("‚úÖ –°–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...", reply_markup=ReplyKeyboardRemove())
                await send_sport_notification_to_all(context.bot, sport_notification_id, sport_text, group_name, user_id)
                
                clear_media_collection(user_id, 'sport')
                context.user_data.pop('sport_text', None)
            else:
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'sport', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        elif update.message.video:
            add_to_media_collection(user_id, 'sport', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        elif update.message.document:
            add_to_media_collection(user_id, 'sport', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        
        if text and text.strip():
            context.user_data['sport_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SPORT
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å —Ç–µ–∫—Å—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")
        return AWAITING_SPORT
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_sport_input: {e}")
        return AWAITING_SPORT

async def handle_suggestion_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles suggestion input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '‚úÖ –ì–æ—Ç–æ–≤–æ':
            media_collection = get_media_collection(user_id, 'suggestion')
            suggestion_text = context.user_data.get('suggestion_text', '')
            
            if not suggestion_text:
                await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
                return AWAITING_SUGGESTION

            suggestion_id = add_suggestion(user_id, suggestion_text)
            
            if suggestion_id:
                for media_item in media_collection:
                    add_suggestion_media(suggestion_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º —Å –ø—Ä–∞–≤–∞–º–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            special_users = [u for u in get_all_users() if can_delete_suggestions(u['user_id'])]
            
            for special_user in special_users:
                try:
                    if media_collection:
                        for media_item in media_collection:
                            if media_item['type'] == 'photo':
                                await context.bot.send_photo(
                                    chat_id=special_user['user_id'],
                                    photo=media_item['id'],
                                    caption=f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                            elif media_item['type'] == 'video':
                                await context.bot.send_video(
                                    chat_id=special_user['user_id'],
                                    video=media_item['id'],
                                    caption=f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                            elif media_item['type'] == 'document':
                                await context.bot.send_document(
                                    chat_id=special_user['user_id'],
                                    document=media_item['id'],
                                    caption=f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                    else:
                        await context.bot.send_message(
                            special_user['user_id'],
                            f"üí° –ù–æ–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                            reply_markup=InlineKeyboardMarkup([
                                [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{suggestion_id}")]
                            ])
                        )
                except Exception as e:
                    print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {special_user['user_id']}: {e}")
            
            await update.message.reply_text("‚úÖ –°–ø–∞—Å–∏–±–æ –∑–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ! –ú—ã –µ–≥–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º.", reply_markup=ReplyKeyboardRemove())
            
            clear_media_collection(user_id, 'suggestion')
            context.user_data.pop('suggestion_text', None)
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        elif update.message.video:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –í–∏–¥–µ–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        elif update.message.document:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("‚úÖ –î–æ–∫—É–º–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—â–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        
        if text and text.strip():
            context.user_data['suggestion_text'] = text
            await update.message.reply_text("‚úÖ –¢–µ–∫—Å—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–µ–¥–∏–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '‚úÖ –ì–æ—Ç–æ–≤–æ'.")
            return AWAITING_SUGGESTION
        
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.")
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_suggestion_input: {e}")
        return AWAITING_SUGGESTION

# -------------------- NOTIFICATION SENDING FUNCTIONS --------------------

async def send_homework_to_all(bot, homework_id, subject, task, deadline, group_name, added_by):
    """Sends homework to all users in a group"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    homework_text = (
        f"üìù <b>–ù–û–í–û–ï –î–û–ú–ê–®–ù–ï–ï –ó–ê–î–ê–ù–ò–ï</b>\n\n"
        f"üìö <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {subject}\n"
        f"üìã <b>–ó–∞–¥–∞–Ω–∏–µ:</b> {task}\n"
        f"‚è∞ <b>–°—Ä–æ–∫ —Å–¥–∞—á–∏:</b> {deadline}\n"
        f"üë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}\n"
        f"üë§ <b>–û—Ç:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (homework_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['new_homework']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=homework_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=homework_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=homework_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], homework_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_notification_to_all(bot, notification_id, message, group_name, added_by):
    """Sends a notification to all users in a group"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    notification_text = (
        f"üì¢ <b>–í–ê–ñ–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n"
        f"{message}\n\n"
        f"üë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}\n"
        f"üë§ <b>–û—Ç:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['important_notifications']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=notification_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=notification_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=notification_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

async def send_sport_notification_to_all(bot, sport_notification_id, message, group_name, added_by):
    """Sends a sport notification to all users in a group"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    sport_text = (
        f"üèÉ <b>–°–ü–û–†–¢–ò–í–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï</b>\n\n"
        f"{message}\n\n"
        f"üë• <b>–ì—Ä—É–ø–ø–∞:</b> {group_name}\n"
        f"üë§ <b>–û—Ç:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()

    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['sport_notifications']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=sport_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=sport_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=sport_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], sport_text, parse_mode='HTML')
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user['user_id']}: {e}")

# -------------------- INFO DISPLAY FUNCTIONS --------------------

async def show_homework(update: Update, group_name: str):
    """Shows all homework for a group"""
    try:
        homeworks = get_homeworks(group_name)
        if not homeworks:
            await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π")
            return
        
        for hw in homeworks:
            hw_text = (
                f"üìù <b>–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ</b>\n"
                f"üìö <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {hw['subject']}\n"
                f"üìã <b>–ó–∞–¥–∞–Ω–∏–µ:</b> {hw['task']}\n"
                f"‚è∞ <b>–°—Ä–æ–∫:</b> {hw['deadline']}\n"
                f"üë§ <b>–î–æ–±–∞–≤–∏–ª:</b> {hw['first_name']}\n"
                f"üìÖ <b>–î–∞—Ç–∞:</b> {datetime.fromisoformat(hw['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if hw['media']:
                if len(hw['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(hw['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = hw['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=hw_text, parse_mode='HTML')
            else:
                await update.message.reply_text(hw_text, parse_mode='HTML')
        
        await update.message.reply_text(f"üìä <b>–ü–æ–∫–∞–∑–∞–Ω–æ:</b> {len(homeworks)} –∑–∞–¥–∞–Ω–∏–π", parse_mode='HTML')
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_homework: {e}")

async def show_information(update: Update, group_name: str, role: str):
    """Shows information for the user"""
    try:
        user_count = get_total_user_count()
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã –¥–ª—è —Ç–µ–∫—É—â–µ–π –≥—Ä—É–ø–ø—ã
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        deputy = get_group_role(group_name, ROLE_DEPUTY_STAROSTA)
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        
        info_text = (
            f"üìä <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –±–æ—Ç–µ:</b> {user_count}\n\n"
            f"üë• <b>–ö–æ–Ω—Ç–∞–∫—Ç—ã –≥—Ä—É–ø–ø—ã {group_name}:</b>\n"
        )
        
        if starosta:
            username = f"@{starosta['username']}" if starosta['username'] else starosta['first_name']
            info_text += f"üëë <b>–°—Ç–∞—Ä–æ—Å—Ç–∞:</b> {username}\n"
        else:
            info_text += "üëë <b>–°—Ç–∞—Ä–æ—Å—Ç–∞:</b> –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω\n"
            
        if deputy:
            username = f"@{deputy['username']}" if deputy['username'] else deputy['first_name']
            info_text += f"üëë <b>–ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã:</b> {username}\n"
        else:
            info_text += "üëë <b>–ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã:</b> –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω\n"
            
        if fizorg:
            username = f"@{fizorg['username']}" if fizorg['username'] else fizorg['first_name']
            info_text += f"üèÉ <b>–§–∏–∑–æ—Ä–≥:</b> {username}\n"
        else:
            info_text += "üèÉ <b>–§–∏–∑–æ—Ä–≥:</b> –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω\n"
            
        info_text += "üë®‚Äçüíª <b>–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫:</b> @imya_polbzovatela\n\n"
        
        await update.message.reply_text(info_text, parse_mode='HTML')

        notifications = get_notifications(group_name)
        sport_notifications = get_sport_notifications(group_name)
        if not notifications and not sport_notifications:
            await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")
            return
        
        if notifications:
            await update.message.reply_text("üì¢ <b>–í–∞–∂–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:</b>", parse_mode='HTML')
            for notif in notifications[:2]:
                notif_text = f"{notif['message']}\n\nüë§ <b>–û—Ç:</b> {notif['first_name']} | üìÖ {datetime.fromisoformat(notif['created_at']).strftime('%d.%m.%Y')}"
                
                if notif['media']:
                    if len(notif['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(notif['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = notif['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=notif_text)
                else:
                    await update.message.reply_text(notif_text)
        
        if sport_notifications:
            await update.message.reply_text("üèÉ <b>–°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:</b>", parse_mode='HTML')
            for sport in sport_notifications[:2]:
                sport_text = f"{sport['message']}\n\nüë§ <b>–û—Ç:</b> {sport['first_name']} | üìÖ {datetime.fromisoformat(sport['created_at']).strftime('%d.%m.%Y')}"
                
                if sport['media']:
                    if len(sport['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(sport['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = sport['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=sport_text)
                else:
                    await update.message.reply_text(sport_text)
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_information: {e}")

async def show_suggestions(update: Update):
    """Shows suggestions from students"""
    try:
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("üì≠ –ü–æ–∫–∞ –Ω–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –æ—Ç —É—á–µ–Ω–∏–∫–æ–≤")
            return
        
        for s in suggestions[:5]:
            username = f"@{s['username']}" if s['username'] else s['first_name']
            suggestion_text = (
                f"üí° <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç {username}</b>\n\n"
                f"{s['message']}\n\n"
                f"üìÖ {datetime.fromisoformat(s['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if s['responses']:
                suggestion_text += "\n\n<b>–û—Ç–≤–µ—Ç—ã:</b>\n"
                for response in s['responses']:
                    responder_name = f"@{response['username']}" if response['username'] else response['first_name']
                    suggestion_text += f"üë§ {responder_name}: {response['message']}\n"
            
            if s['media']:
                if len(s['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(s['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = s['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
            else:
                await update.message.reply_text(suggestion_text, parse_mode='HTML')
                
            if not s['responses']:
                await update.message.reply_text(
                    "üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üí¨ –û—Ç–≤–µ—Ç–∏—Ç—å", callback_data=f"respond_{s['id']}")]
                    ])
                )
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_suggestions: {e}")

async def show_users_list(update: Update):
    """Shows a list of all users grouped by groups"""
    try:
        users = get_all_users()
        if not users:
            await update.message.reply_text("‚ùå –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            return
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –≥—Ä—É–ø–ø–∞–º
        groups_dict = {}
        for user in users:
            group_name = user['group_name'] if user['group_name'] else "–ë–µ–∑ –≥—Ä—É–ø–ø—ã"
            if group_name not in groups_dict:
                groups_dict[group_name] = []
            groups_dict[group_name].append(user)
        
        user_list_text = "üë• <b>–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –≥—Ä—É–ø–ø–∞–º</b>\n\n"
        
        for group_name, group_users in sorted(groups_dict.items()):
            user_list_text += f"<b>üìö –ì—Ä—É–ø–ø–∞: {group_name}</b> ({len(group_users)} —á–µ–ª.)\n"
            
            for user in group_users:
                username = user['username'] if user['username'] else "–ù–µ—Ç —é–∑–µ—Ä–Ω–µ–π–º–∞"
                role_display = get_user_role_display(user['user_id'])
                
                user_list_text += (
                    f"  üë§ <b>–ò–º—è:</b> {user['first_name']}\n"
                    f"  üÜî <b>ID:</b> <code>{user['user_id']}</code>\n"
                    f"  üë®‚Äçüíº <b>–†–æ–ª—å:</b> {role_display}\n"
                    f"  üì± <b>–Æ–∑–µ—Ä:</b> @{username}\n\n"
                )
            
            user_list_text += "\n"
        
        # –†–∞–∑–±–∏–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏ –µ—Å–ª–∏ –æ–Ω–æ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ
        if len(user_list_text) > 4000:
            parts = []
            current_part = ""
            sections = user_list_text.split('\n\n')
            
            for section in sections:
                if len(current_part + section + '\n\n') > 4000:
                    parts.append(current_part)
                    current_part = section + '\n\n'
                else:
                    current_part += section + '\n\n'
            
            if current_part:
                parts.append(current_part)
            
            for i, part in enumerate(parts):
                await update.message.reply_text(
                    f"{part}\n<b>–ß–∞—Å—Ç—å {i+1}/{len(parts)}</b>", 
                    parse_mode='HTML'
                )
        else:
            await update.message.reply_text(user_list_text, parse_mode='HTML')
            
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ show_users_list: {e}")
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")

# -------------------- DELETION FUNCTIONS --------------------

async def delete_homework_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows homework deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_homework(user_id, user_data['group_name']):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        homeworks = get_homeworks(user_data['group_name'])
        if not homeworks:
            await update.message.reply_text("üìù –ù–µ—Ç –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END
        
        keyboard = [[InlineKeyboardButton(f"‚ùå {hw['subject']} | {hw['deadline']}", callback_data=f"del_hw_{hw['id']}")] for hw in homeworks[:5]]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –î–ó –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_HOMEWORK_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_homework_menu: {e}")
        return ConversationHandler.END

async def delete_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_notifications(user_id, user_data['group_name']):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        user_data = get_user(user_id)
        notifications = get_notifications(user_data['group_name'])
        sport_notifications = get_sport_notifications(user_data['group_name'])
        
        if not notifications and not sport_notifications:
            await update.message.reply_text("üì¢ –ù–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END

        keyboard = []
        for n in notifications[:5]:
            button_text = f"üì¢ {n['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_notif_{n['id']}")])
        
        for s in sport_notifications[:5]:
            button_text = f"üèÉ {s['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{s['id']}")])

        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_INFO_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_notification_menu: {e}")
        return ConversationHandler.END

async def delete_sport_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows sport notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_sport_notifications(user_id, user_data['group_name']):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        if user_id == DEVELOPER_ID:
            sport_notifications = get_all_sport_notifications()
        else:
            sport_notifications = get_sport_notifications(user_data['group_name'])

        if not sport_notifications:
            await update.message.reply_text("üèÉ –ù–µ—Ç —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END

        keyboard = []
        for sport in sport_notifications[:10]:
            button_text = f"üèÉ {sport['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{sport['id']}")])

        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SPORT_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_sport_notification_menu: {e}")
        return ConversationHandler.END

async def delete_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows user deletion menu"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        users = [u for u in get_all_users() if u['user_id'] != DEVELOPER_ID]
        if not users:
            await update.message.reply_text("üë• –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END
            
        keyboard = [[InlineKeyboardButton(f"‚ùå {u['first_name']} (@{u['username']}) - –ì—Ä—É–ø–ø–∞: {u['group_name']} - ID: {u['user_id']}", callback_data=f"del_user_{u['user_id']}")] for u in users]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_USER_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_user_menu: {e}")
        return ConversationHandler.END

async def delete_suggestions_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows suggestions deletion menu"""
    try:
        user_id = update.effective_user.id
        if not can_delete_suggestions(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
            
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("üí° –ù–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
            return ConversationHandler.END
        
        keyboard = [[InlineKeyboardButton(f"‚ùå {s['message'][:20]}...", callback_data=f"del_sugg_{s['id']}")] for s in suggestions[:5]]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SUGGESTION_DELETE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ delete_suggestions_menu: {e}")
        return ConversationHandler.END

async def handle_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles deletion callbacks"""
    try:
        query = update.callback_query
        await query.answer()

        parts = query.data.split('_')
        data_type = parts[1]
        item_id = int(parts[2])
        
        message = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞."
        try:
            if data_type == 'hw':
                delete_homework(item_id)
                message = "‚úÖ –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            elif data_type == 'notif':
                delete_notification(item_id)
                message = "‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            elif data_type == 'sport':
                delete_sport_notification(item_id)
                message = "‚úÖ –°–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            elif data_type == 'user':
                delete_user(item_id)
                message = "‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω."
            elif data_type == 'sugg':
                delete_suggestion(item_id)
                message = "‚úÖ –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ."
            
            await query.edit_message_text(text=message)
        except Exception as e:
            await query.edit_message_text(text=f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: {e}")
        
        await show_main_menu(update, query.from_user.id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_delete_callback: {e}")
        return ConversationHandler.END

# -------------------- SUGGESTION RESPONSE FUNCTION --------------------

async def handle_suggestion_response_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response callback"""
    try:
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split('_')
        suggestion_id = int(parts[1])
        
        context.user_data['responding_to_suggestion'] = suggestion_id
        
        await query.edit_message_text(
            "üí¨ <b>–û—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ</b>\n\n–ù–∞–ø–∏—à–∏ —Å–≤–æ–π –æ—Ç–≤–µ—Ç:",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
        )
        
        return AWAITING_SUGGESTION_RESPONSE
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_suggestion_response_callback: {e}")
        return ConversationHandler.END

async def handle_suggestion_response_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION_RESPONSE
        
        text = update.message.text
        
        if text == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await cancel_conversation(update, context)
        
        if not text:
            await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ –æ—Ç–≤–µ—Ç.")
            return AWAITING_SUGGESTION_RESPONSE
        
        suggestion_id = context.user_data.get('responding_to_suggestion')
        
        if not suggestion_id:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            return await cancel_conversation(update, context)
        
        conn = get_db_connection()
        suggestion = conn.execute('SELECT * FROM suggestions WHERE id = ?', (suggestion_id,)).fetchone()
        conn.close()
        
        if not suggestion:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            return await cancel_conversation(update, context)
        
        add_suggestion_response(suggestion_id, user_id, text)
        
        try:
            responder_name = user_data['first_name']
            if user_data['username']:
                responder_name = f"@{user_data['username']}"
            
            response_text = (
                f"üí¨ <b>–û—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ</b>\n\n"
                f"üë§ <b>–û—Ç:</b> {responder_name}\n"
                f"üí° <b>–í–∞—à–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ:</b> {suggestion['message'][:100]}...\n\n"
                f"üìù <b>–û—Ç–≤–µ—Ç:</b> {text}"
            )
            
            await context.bot.send_message(
                chat_id=suggestion['user_id'],
                text=response_text,
                parse_mode='HTML'
            )
        except Exception as e:
            print(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç –∞–≤—Ç–æ—Ä—É –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: {e}")
        
        await update.message.reply_text("‚úÖ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_suggestion_response_input: {e}")
        return AWAITING_SUGGESTION_RESPONSE

# -------------------- ROLE ASSIGNMENT SYSTEM --------------------

async def start_role_assignment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Starts the role assignment process"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
        
        # Get all groups with users
        groups_with_users = {}
        all_users = get_all_users()
        
        for user in all_users:
            if user['group_name']:
                if user['group_name'] not in groups_with_users:
                    groups_with_users[user['group_name']] = []
                groups_with_users[user['group_name']].append(user)
        
        if not groups_with_users:
            await update.message.reply_text("‚ùå –ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –≥—Ä—É–ø–ø–∞–º–∏.")
            return ConversationHandler.END
        
        # Create keyboard with groups
        keyboard = []
        for group_name in sorted(groups_with_users.keys()):
            user_count = len(groups_with_users[group_name])
            keyboard.append([InlineKeyboardButton(f"{group_name} ({user_count} —á–µ–ª.)", callback_data=f"role_group_{group_name}")])
        
        keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="role_cancel")])
        
        await update.message.reply_text(
            "üëë <b>–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ä–æ–ª–µ–π –¥–ª—è –≥—Ä—É–ø–ø</b>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É –¥–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è —Ä–æ–ª–∏:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_ROLE_ASSIGNMENT
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ start_role_assignment: {e}")
        return ConversationHandler.END

async def handle_role_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles group selection for role assignment"""
    try:
        query = update.callback_query
        await query.answer()
        
        if query.data == "role_cancel":
            await query.edit_message_text("‚ùå –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ä–æ–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        group_name = query.data.replace('role_group_', '')
        context.user_data['role_assignment_group'] = group_name
        
        # Create role type selection keyboard
        keyboard = [
            [InlineKeyboardButton("üëë –°—Ç–∞—Ä–æ—Å—Ç–∞", callback_data="role_type_starosta")],
            [InlineKeyboardButton("üëë –ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã", callback_data="role_type_deputy_starosta")],
            [InlineKeyboardButton("üèÉ –§–∏–∑–æ—Ä–≥", callback_data="role_type_physical_organizer")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –≥—Ä—É–ø–ø–∞–º", callback_data="role_back_to_groups")],
            [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="role_cancel")]
        ]
        
        await query.edit_message_text(
            f"üëë <b>–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ä–æ–ª–∏ –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}</b>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ä–æ–ª–∏ –¥–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_ROLE_ASSIGNMENT
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_role_group_selection: {e}")
        return ConversationHandler.END

async def handle_role_type_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles role type selection"""
    try:
        query = update.callback_query
        await query.answer()
        
        if query.data == "role_cancel":
            await query.edit_message_text("‚ùå –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ä–æ–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        if query.data == "role_back_to_groups":
            return await start_role_assignment(update, context)
        
        role_type = query.data.replace('role_type_', '')
        group_name = context.user_data['role_assignment_group']
        
        # Get current role holder
        current_role = get_group_role(group_name, role_type)
        
        # Get users in selected group
        users_in_group = [user for user in get_all_users() if user['group_name'] == group_name]
        
        if not users_in_group:
            await query.edit_message_text(f"‚ùå –í –≥—Ä—É–ø–ø–µ {group_name} –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            return ConversationHandler.END
        
        # Create keyboard with users
        keyboard = []
        for user in users_in_group:
            username = f"@{user['username']}" if user['username'] else user['first_name']
            button_text = f"{user['first_name']} ({username})"
            if current_role and current_role['user_id'] == user['user_id']:
                button_text += " ‚úÖ"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"role_user_{user['user_id']}_{role_type}")])
        
        keyboard.append([InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ —Ä–æ–ª—è–º", callback_data=f"role_back_to_types_{group_name}")])
        keyboard.append([InlineKeyboardButton("‚ùå –°–Ω—è—Ç—å —Ä–æ–ª—å", callback_data=f"role_remove_{role_type}")])
        keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="role_cancel")])
        
        role_names = {
            'starosta': '–°—Ç–∞—Ä–æ—Å—Ç–∞',
            'deputy_starosta': '–ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã',
            'physical_organizer': '–§–∏–∑–æ—Ä–≥'
        }
        
        current_text = ""
        if current_role:
            current_text = f"\n\n<b>–¢–µ–∫—É—â–∏–π {role_names[role_type]}:</b> {current_role['first_name']} (@{current_role['username']})"
        
        await query.edit_message_text(
            f"üëë <b>–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ {role_names[role_type]} –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name}</b>\n\n"
            f"–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è:{current_text}",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_ROLE_ASSIGNMENT
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_role_type_selection: {e}")
        return ConversationHandler.END

async def handle_role_user_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user selection for role assignment"""
    try:
        query = update.callback_query
        await query.answer()
        
        if query.data.startswith("role_back_to_types_"):
            group_name = query.data.replace('role_back_to_types_', '')
            context.user_data['role_assignment_group'] = group_name
            return await handle_role_group_selection(update, context)
        
        if query.data.startswith("role_remove_"):
            role_type = query.data.replace('role_remove_', '')
            group_name = context.user_data['role_assignment_group']
            
            if remove_group_role(group_name, role_type):
                role_names = {
                    'starosta': '–°—Ç–∞—Ä–æ—Å—Ç–∞',
                    'deputy_starosta': '–ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã', 
                    'physical_organizer': '–§–∏–∑–æ—Ä–≥'
                }
                await query.edit_message_text(f"‚úÖ {role_names[role_type]} –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name} —Å–Ω—è—Ç!")
            else:
                await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–Ω—è—Ç–∏–∏ —Ä–æ–ª–∏.")
            
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        if query.data == "role_cancel":
            await query.edit_message_text("‚ùå –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ä–æ–ª–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        parts = query.data.split('_')
        user_id = int(parts[2])
        role_type = parts[3]
        
        group_name = context.user_data['role_assignment_group']
        user_data = get_user(user_id)
        
        if not user_data:
            await query.edit_message_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return ConversationHandler.END
        
        # Set the role
        if set_group_role(group_name, role_type, user_id, user_data['username'], user_data['first_name']):
            role_names = {
                'starosta': '–°—Ç–∞—Ä–æ—Å—Ç–∞',
                'deputy_starosta': '–ó–∞–º —Å—Ç–∞—Ä–æ—Å—Ç—ã',
                'physical_organizer': '–§–∏–∑–æ—Ä–≥'
            }
            
            await query.edit_message_text(
                f"‚úÖ {role_names[role_type]} –¥–ª—è –≥—Ä—É–ø–ø—ã {group_name} –Ω–∞–∑–Ω–∞—á–µ–Ω!\n\n"
                f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_data['first_name']} (@{user_data['username']})"
            )
        else:
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ —Ä–æ–ª–∏.")
        
        await show_main_menu(update, query.from_user.id)
        return ConversationHandler.END
            
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_role_user_selection: {e}")
        return ConversationHandler.END

# -------------------- USER RIGHTS MANAGEMENT FUNCTIONS --------------------

async def manage_user_rights_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows menu for managing user rights"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return ConversationHandler.END
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –≥—Ä—É–ø–ø–∞–º
        users = get_all_users()
        groups_dict = {}
        for user in users:
            if user['user_id'] == user_id:
                continue
                
            group_name = user['group_name'] if user['group_name'] else "–ë–µ–∑ –≥—Ä—É–ø–ø—ã"
            if group_name not in groups_dict:
                groups_dict[group_name] = []
            groups_dict[group_name].append(user)
        
        if not groups_dict:
            await update.message.reply_text("‚ùå –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            return ConversationHandler.END
        
        keyboard = []
        for group_name, group_users in sorted(groups_dict.items()):
            keyboard.append([InlineKeyboardButton(f"üìö {group_name} ({len(group_users)} —á–µ–ª.)", callback_data=f"rights_group_{group_name}")])
        
        await update.message.reply_text(
            "üë• <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–∞–≤–∞–º–∏:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ manage_user_rights_menu: {e}")
        return ConversationHandler.END

async def handle_user_rights_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles group selection for rights management"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await query.edit_message_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return
        
        group_name = query.data.replace('rights_group_', '')
        context.user_data['rights_management_group'] = group_name
        
        # Get users in selected group
        users_in_group = [user for user in get_all_users() if user['group_name'] == group_name and user['user_id'] != user_id]
        
        if not users_in_group:
            await query.edit_message_text(f"‚ùå –í –≥—Ä—É–ø–ø–µ {group_name} –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
            return
        
        keyboard = []
        for user in users_in_group:
            role_display = get_user_role_display(user['user_id'])
            button_text = f"{user['first_name']} (@{user['username']}) - {role_display}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"manage_rights_{user['user_id']}")])
        
        keyboard.append([InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –≥—Ä—É–ø–ø–∞–º", callback_data="rights_back_to_groups")])
        
        await query.edit_message_text(
            f"üë• <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏ –≥—Ä—É–ø–ø—ã {group_name}</b>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–∞–≤:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_user_rights_group_selection: {e}")
        return AWAITING_USER_RIGHTS

async def handle_user_rights_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user selection for rights management"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await query.edit_message_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return
        
        if query.data == "rights_back_to_groups":
            return await manage_user_rights_menu(update, context)
        
        parts = query.data.split('_')
        target_user_id = int(parts[2])
        
        if target_user_id == user_id:
            await query.edit_message_text("‚ùå –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω—è—Ç—å —Å–≤–æ–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∞!")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        
        context.user_data['managing_user_id'] = target_user_id
        
        # Create rights management keyboard
        keyboard = [
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_send_homework'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ –î–ó", callback_data=f"toggle_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_send_notifications'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_send_sport_notifications'] else '‚ùå'} –°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data=f"toggle_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_send_global_notifications'] else '‚ùå'} –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data=f"toggle_global_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_homework'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –î–ó", callback_data=f"toggle_del_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_del_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_sport_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö", callback_data=f"toggle_del_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_delete_suggestions'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π", callback_data=f"toggle_del_suggestions_{target_user_id}")],
            [InlineKeyboardButton(f"{'‚úÖ' if target_user['can_manage_users'] else '‚ùå'} –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏", callback_data=f"toggle_manage_users_{target_user_id}")],
            [InlineKeyboardButton("‚úèÔ∏è –°–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è —Ä–æ–ª—å", callback_data=f"custom_role_{target_user_id}")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data=f"rights_back_to_users_{context.user_data['rights_management_group']}")],
            [InlineKeyboardButton("‚ùå –°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –ø—Ä–∞–≤–∞", callback_data=f"reset_rights_{target_user_id}")],
            [InlineKeyboardButton("‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏", callback_data="save_rights")]
        ]
        
        role_display = get_user_role_display(target_user_id)
        
        await query.edit_message_text(
            f"üë§ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
            f"<b>–ò–º—è:</b> {target_user['first_name']}\n"
            f"<b>–Æ–∑–µ—Ä–Ω–µ–π–º:</b> @{target_user['username']}\n"
            f"<b>–ì—Ä—É–ø–ø–∞:</b> {target_user['group_name']}\n"
            f"<b>–†–æ–ª—å:</b> {role_display}\n"
            f"<b>ID:</b> <code>{target_user['user_id']}</code>\n\n"
            f"<b>–¢–µ–∫—É—â–∏–µ –ø—Ä–∞–≤–∞:</b>\n"
            f"–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—Ä–∞–≤–æ –¥–ª—è –µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_user_rights_selection: {e}")
        return AWAITING_USER_RIGHTS

async def handle_rights_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles rights toggling"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await query.edit_message_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return
        
        if query.data == "save_rights":
            await query.edit_message_text("‚úÖ –ü—Ä–∞–≤–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!")
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if query.data.startswith("rights_back_to_users_"):
            group_name = query.data.replace('rights_back_to_users_', '')
            context.user_data['rights_management_group'] = group_name
            return await handle_user_rights_group_selection(update, context)
        
        if query.data.startswith("custom_role_"):
            target_user_id = int(query.data.replace('custom_role_', ''))
            context.user_data['custom_role_user_id'] = target_user_id
            
            await query.edit_message_text(
                "‚úèÔ∏è <b>–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π —Ä–æ–ª–∏</b>\n\n"
                "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–æ–ª–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:",
                parse_mode='HTML',
                reply_markup=ReplyKeyboardMarkup([['‚ùå –û—Ç–º–µ–Ω–∞']], resize_keyboard=True)
            )
            return AWAITING_USER_RIGHTS
        
        parts = query.data.split('_')
        
        if len(parts) == 3:
            action = parts[1]
            target_user_id = int(parts[2])
        elif len(parts) == 4:
            action = parts[1]
            sub_action = parts[2]
            target_user_id = int(parts[3])
            
            if action == "del":
                action = f"del_{sub_action}"
            elif action == "manage" and sub_action == "users":
                action = "manage_users"
        else:
            await query.edit_message_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö.")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        
        # Update rights
        rights_data = {
            'can_send_homework': target_user['can_send_homework'],
            'can_send_notifications': target_user['can_send_notifications'],
            'can_send_sport_notifications': target_user['can_send_sport_notifications'],
            'can_send_global_notifications': target_user['can_send_global_notifications'],
            'can_delete_homework': target_user['can_delete_homework'],
            'can_delete_notifications': target_user['can_delete_notifications'],
            'can_delete_sport_notifications': target_user['can_delete_sport_notifications'],
            'can_delete_suggestions': target_user['can_delete_suggestions'],
            'can_manage_users': target_user['can_manage_users'],
            'role': target_user['role'],
            'custom_role_name': target_user['custom_role_name']
        }
        
        if action == "reset":
            # Reset all rights
            for key in rights_data:
                if key.startswith('can_'):
                    rights_data[key] = 0
            rights_data['role'] = ROLE_STUDENT
            rights_data['custom_role_name'] = None
        else:
            # Toggle specific right
            if action == "homework":
                rights_data['can_send_homework'] = 1 - rights_data['can_send_homework']
            elif action == "notifications":
                rights_data['can_send_notifications'] = 1 - rights_data['can_send_notifications']
            elif action == "sport":
                rights_data['can_send_sport_notifications'] = 1 - rights_data['can_send_sport_notifications']
            elif action == "global":
                rights_data['can_send_global_notifications'] = 1 - rights_data['can_send_global_notifications']
            elif action == "del_homework":
                rights_data['can_delete_homework'] = 1 - rights_data['can_delete_homework']
            elif action == "del_notifications":
                rights_data['can_delete_notifications'] = 1 - rights_data['can_delete_notifications']
            elif action == "del_sport":
                rights_data['can_delete_sport_notifications'] = 1 - rights_data['can_delete_sport_notifications']
            elif action == "del_suggestions":
                rights_data['can_delete_suggestions'] = 1 - rights_data['can_delete_suggestions']
            elif action == "manage_users":
                rights_data['can_manage_users'] = 1 - rights_data['can_manage_users']
        
        if update_user_rights(target_user_id, rights_data):
            # Update message with new rights
            updated_user = get_user(target_user_id)
            
            keyboard = [
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_send_homework'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ –î–ó", callback_data=f"toggle_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_send_notifications'] else '‚ùå'} –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_send_sport_notifications'] else '‚ùå'} –°–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data=f"toggle_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_send_global_notifications'] else '‚ùå'} –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", callback_data=f"toggle_global_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_homework'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –î–ó", callback_data=f"toggle_del_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π", callback_data=f"toggle_del_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_sport_notifications'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã—Ö", callback_data=f"toggle_del_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_delete_suggestions'] else '‚ùå'} –£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π", callback_data=f"toggle_del_suggestions_{target_user_id}")],
                [InlineKeyboardButton(f"{'‚úÖ' if updated_user['can_manage_users'] else '‚ùå'} –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏", callback_data=f"toggle_manage_users_{target_user_id}")],
                [InlineKeyboardButton("‚úèÔ∏è –°–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è —Ä–æ–ª—å", callback_data=f"custom_role_{target_user_id}")],
                [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data=f"rights_back_to_users_{context.user_data['rights_management_group']}")],
                [InlineKeyboardButton("‚ùå –°–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –ø—Ä–∞–≤–∞", callback_data=f"reset_rights_{target_user_id}")],
                [InlineKeyboardButton("‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏ –≤—ã–π—Ç–∏", callback_data="save_rights")]
            ]
            
            role_display = get_user_role_display(target_user_id)
            
            await query.edit_message_text(
                f"üë§ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
                f"<b>–ò–º—è:</b> {updated_user['first_name']}\n"
                f"<b>–Æ–∑–µ—Ä–Ω–µ–π–º:</b> @{updated_user['username']}\n"
                f"<b>–ì—Ä—É–ø–ø–∞:</b> {updated_user['group_name']}\n"
                f"<b>–†–æ–ª—å:</b> {role_display}\n"
                f"<b>ID:</b> <code>{updated_user['user_id']}</code>\n\n"
                f"<b>–¢–µ–∫—É—â–∏–µ –ø—Ä–∞–≤–∞:</b>\n"
                f"–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ø—Ä–∞–≤–æ –¥–ª—è –µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è:",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∞–≤.")
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_rights_toggle: {e}")
        await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–∞–≤.")

async def handle_custom_role_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles custom role name input"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
            return await cancel_conversation(update, context)
        
        custom_role_name = update.message.text.strip()
        
        if custom_role_name == '‚ùå –û—Ç–º–µ–Ω–∞':
            return await handle_user_rights_selection(update, context)
        
        target_user_id = context.user_data['custom_role_user_id']
        target_user = get_user(target_user_id)
        
        if not target_user:
            await update.message.reply_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return ConversationHandler.END
        
        # Update user with custom role
        rights_data = {
            'role': ROLE_CUSTOM,
            'custom_role_name': custom_role_name,
            'can_send_homework': target_user['can_send_homework'],
            'can_send_notifications': target_user['can_send_notifications'],
            'can_send_sport_notifications': target_user['can_send_sport_notifications'],
            'can_send_global_notifications': target_user['can_send_global_notifications'],
            'can_delete_homework': target_user['can_delete_homework'],
            'can_delete_notifications': target_user['can_delete_notifications'],
            'can_delete_sport_notifications': target_user['can_delete_sport_notifications'],
            'can_delete_suggestions': target_user['can_delete_suggestions'],
            'can_manage_users': target_user['can_manage_users']
        }
        
        if update_user_rights(target_user_id, rights_data):
            await update.message.reply_text(
                f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {target_user['first_name']} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —Ä–æ–ª—å: {custom_role_name}!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text(
                "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ —Ä–æ–ª–∏.",
                reply_markup=ReplyKeyboardRemove()
            )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –≤ handle_custom_role_input: {e}")
        return AWAITING_USER_RIGHTS

# -------------------- JOB QUEUE FUNCTIONS --------------------

async def init_schedule_cache(application):
    """Initializes the schedule cache and groups list"""
    try:
        global schedule_cache, last_schedule_check
        schedule_data = fetch_schedule_data()
        if schedule_data:
            schedule_cache = schedule_data
            last_schedule_check = datetime.now(YEKATERINBURG_TZ)
            print("–õ–û–ì: –ö—ç—à —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        
        # Initialize groups list
        fetch_groups_list()
        print("–õ–û–ì: –°–ø–∏—Å–æ–∫ –≥—Ä—É–ø–ø –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    except Exception as e:
        print(f"–û–®–ò–ë–ö–ê: –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫—ç—à–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")

# -------------------- MAIN FUNCTION --------------------

def main():
    """Main function to run the bot"""
    try:
        init_db()
        
        app = Application.builder().token(BOT_TOKEN).post_init(init_schedule_cache).build()
        
        job_queue = app.job_queue
        job_queue.run_repeating(check_schedule_changes, interval=3600, first=10)
        job_queue.run_repeating(check_lesson_notifications, interval=60, first=10)
        job_queue.run_daily(send_daily_schedule, time=time(hour=19, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(send_morning_schedule, time=time(hour=7, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(check_birthdays, time=time(hour=0, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        
        conv_handler = ConversationHandler(
            entry_points=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –î–ó$'), ask_homework_details),
                MessageHandler(filters.Regex('^üì¢ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), ask_notification_details),
                MessageHandler(filters.Regex('^üèÉ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), ask_sport_notification_details),
                MessageHandler(filters.Regex('^üí° –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é$'), ask_suggestion_details),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –î–ó$'), delete_homework_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ$'), delete_notification_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å —Å–ø–æ—Ä—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è$'), delete_sport_notification_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è$'), delete_suggestions_menu),
                MessageHandler(filters.Regex('^–£–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è$'), delete_user_menu),
                MessageHandler(filters.Regex('^üéì –°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É$'), ask_user_group),
                MessageHandler(filters.Regex('^üéÇ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è$'), ask_birthday_date),
                MessageHandler(filters.Regex('^üåç –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤—Å–µ–º –≥—Ä—É–ø–ø–∞–º$'), ask_global_notification_details),
                MessageHandler(filters.Regex('^üëë –ù–∞–∑–Ω–∞—á–∏—Ç—å —Ä–æ–ª—å$'), start_role_assignment),
                MessageHandler(filters.Regex('^üîß –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤–∞–º–∏$'), manage_user_rights_menu),
                MessageHandler(filters.Regex('^üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π$'), show_notification_settings),
            ],
            states={
                AWAITING_GROUP: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_group_selection),
                ],
                AWAITING_HOMEWORK: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_homework_input)],
                AWAITING_INFO: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_notification_input)],
                AWAITING_SPORT: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_sport_input)],
                AWAITING_SUGGESTION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_suggestion_input)],
                AWAITING_SUGGESTION_RESPONSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_suggestion_response_input)],
                AWAITING_BIRTHDAY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_birthday_input)],
                AWAITING_GLOBAL_NOTIFICATION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_global_notification_input)],
                AWAITING_ROLE_ASSIGNMENT: [
                    CallbackQueryHandler(handle_role_group_selection, pattern='^role_group_'),
                    CallbackQueryHandler(handle_role_type_selection, pattern='^role_type_'),
                    CallbackQueryHandler(handle_role_user_selection, pattern='^role_user_'),
                    CallbackQueryHandler(handle_role_type_selection, pattern='^role_back_to_types_'),
                    CallbackQueryHandler(handle_role_group_selection, pattern='^role_back_to_groups'),
                    CallbackQueryHandler(handle_role_user_selection, pattern='^role_remove_'),
                    CallbackQueryHandler(start_role_assignment, pattern='^role_cancel$'),
                ],
                AWAITING_USER_RIGHTS: [
                    CallbackQueryHandler(handle_user_rights_group_selection, pattern='^rights_group_'),
                    CallbackQueryHandler(handle_user_rights_selection, pattern='^manage_rights_'),
                    CallbackQueryHandler(handle_rights_toggle, pattern='^(toggle_|reset_|rights_back_|save_)'),
                    CallbackQueryHandler(handle_user_rights_group_selection, pattern='^rights_back_to_users_'),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_custom_role_input)
                ],
                AWAITING_NOTIFICATION_SETTINGS: [
                    CallbackQueryHandler(handle_notification_settings_callback, pattern='^(toggle_|done_)')
                ],
                AWAITING_HOMEWORK_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_hw_')],
                AWAITING_INFO_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_notif_')],
                AWAITING_SPORT_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sport_')],
                AWAITING_USER_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_user_')],
                AWAITING_SUGGESTION_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sugg_')]
            },
            fallbacks=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^‚ùå –û—Ç–º–µ–Ω–∞$'), cancel_conversation),
                CallbackQueryHandler(cancel_conversation, pattern='^role_cancel$')
            ],
            allow_reentry=True
        )
        
        app.add_handler(conv_handler)
        app.add_handler(CallbackQueryHandler(handle_suggestion_response_callback, pattern='^respond_'))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_simple_message))
        
        print("–õ–û–ì: –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
        app.run_polling()
        
    except Exception as e:
        print(f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}")

if __name__ == "__main__":
    main()
