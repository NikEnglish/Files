import sqlite3
import re
import json
import asyncio
import requests
import os
from datetime import datetime, timedelta, timezone, time
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo, InputMediaDocument
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler, PollHandler
from telegram.constants import ParseMode

# -------------------- CONSTANTS AND SETTINGS --------------------
BOT_TOKEN = "7405848829:AAHxDv0DP_Co512vOvGw_PDsXYDjE4fgOJ0"
YEKATERINBURG_TZ = timezone(timedelta(hours=5))
DEFAULT_GROUP = None

# States for ConversationHandler
AWAITING_HOMEWORK, AWAITING_INFO, AWAITING_SPORT, AWAITING_SUGGESTION, AWAITING_HOMEWORK_DELETE, AWAITING_INFO_DELETE, AWAITING_SPORT_DELETE, AWAITING_USER_DELETE, AWAITING_SUGGESTION_DELETE, AWAITING_GROUP, AWAITING_POLL, AWAITING_SUGGESTION_RESPONSE, AWAITING_BIRTHDAY, AWAITING_GLOBAL_NOTIFICATION, AWAITING_ADD_SPECIAL_USER, AWAITING_USER_RIGHTS = range(16)

# User Roles
ROLE_STUDENT = 'student'
ROLE_PHYSICAL_ORGANIZER = 'physical_organizer'
ROLE_IT_SPECIALIST = 'it_specialist'
ROLE_CUSTOM = 'custom'

# Special Users (ID and username)
DEVELOPER_ID = 1775957387
SPECIAL_USERS = {
    5013216284: {'role': ROLE_IT_SPECIALIST, 'username': '@kimertuzz3', 'name': 'Староста'},
    DEVELOPER_ID: {'role': ROLE_IT_SPECIALIST, 'username': '@imya_polbzovatela', 'name': 'Зам Старосты (Разработчик)'},
    1610410800: {'role': ROLE_PHYSICAL_ORGANIZER, 'username': '@Dashulyabed', 'name': 'Физ. орг.'}
}

# Dynamic list of groups (will be populated from API)
ALL_GROUPS = []

# Schedule cache
schedule_cache = {}
last_schedule_check = None
groups_cache = []
last_groups_check = None

# Spam protection
user_message_times = {}
user_warnings = {}
user_blocks = {}
SPAM_THRESHOLD = 10
SPAM_WINDOW = 5
BLOCK_DURATIONS = [600, 1800, 3600, 7200, 36000, 180000]

# Media collection for multiple media support
user_media_collections = {}

# -------------------- DATABASE FUNCTIONS --------------------

def init_db():
    """Initializes the database with proper error handling"""
    conn = None
    try:
        # Удаляем старую базу данных если есть проблемы
        if os.path.exists('bot_data.db'):
            try:
                conn = sqlite3.connect('bot_data.db')
                cur = conn.cursor()
                # Проверяем наличие колонки custom_role_name
                cur.execute("PRAGMA table_info(users)")
                columns = [column[1] for column in cur.fetchall()]
                if 'custom_role_name' not in columns:
                    print("ЛОГ: Обнаружена устаревшая структура базы, пересоздаем...")
                    conn.close()
                    os.remove('bot_data.db')
                    conn = sqlite3.connect('bot_data.db')
                    cur = conn.cursor()
            except Exception as e:
                print(f"ЛОГ: Ошибка проверки базы: {e}")
                if conn:
                    conn.close()
                os.remove('bot_data.db')
                conn = sqlite3.connect('bot_data.db')
                cur = conn.cursor()
        else:
            conn = sqlite3.connect('bot_data.db')
            cur = conn.cursor()
        
        # Users table with all required columns
        cur.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            group_name TEXT,
            role TEXT DEFAULT 'student',
            custom_role_name TEXT,
            can_send_homework BOOLEAN DEFAULT 0,
            can_send_notifications BOOLEAN DEFAULT 0,
            can_send_sport_notifications BOOLEAN DEFAULT 0,
            can_delete_homework BOOLEAN DEFAULT 0,
            can_delete_notifications BOOLEAN DEFAULT 0,
            can_delete_sport_notifications BOOLEAN DEFAULT 0,
            can_delete_suggestions BOOLEAN DEFAULT 0,
            can_create_polls BOOLEAN DEFAULT 0,
            can_manage_users BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        # Homeworks table
        cur.execute('''CREATE TABLE IF NOT EXISTS homeworks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            subject TEXT,
            task TEXT,
            deadline TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Homework media table
        cur.execute('''CREATE TABLE IF NOT EXISTS homework_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            homework_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (homework_id) REFERENCES homeworks (id) ON DELETE CASCADE
        )''')
        
        # Notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (notification_id) REFERENCES notifications (id) ON DELETE CASCADE
        )''')
        
        # Sport notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Sport notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sport_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (sport_notification_id) REFERENCES sport_notifications (id) ON DELETE CASCADE
        )''')
        
        # Suggestions table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )''')
        
        # Suggestion media table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id) ON DELETE CASCADE
        )''')
        
        # Suggestion responses table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_responses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            responder_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id),
            FOREIGN KEY (responder_id) REFERENCES users (user_id)
        )''')
        
        # Polls table
        cur.execute('''CREATE TABLE IF NOT EXISTS polls (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            question TEXT,
            options TEXT,
            group_name TEXT,
            added_by INTEGER,
            message_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Birthdays table
        cur.execute('''CREATE TABLE IF NOT EXISTS birthdays (
            user_id INTEGER PRIMARY KEY,
            birthday_date TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE
        )''')
        
        # Global notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Global notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            global_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (global_notification_id) REFERENCES global_notifications (id) ON DELETE CASCADE
        )''')
        
        conn.commit()
        print("ЛОГ: База данных инициализирована.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при инициализации: {e}")
    finally:
        if conn:
            conn.close()

def get_db_connection():
    """Creates a connection to the database"""
    try:
        conn = sqlite3.connect('bot_data.db')
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при подключении: {e}")
        return None

def get_user(user_id):
    """Gets user information"""
    conn = get_db_connection()
    if not conn: return None
    try:
        user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        return user
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении пользователя: {e}")
        return None
    finally:
        conn.close()

def get_all_users():
    """Gets a list of all users"""
    conn = get_db_connection()
    if not conn: return []
    try:
        users = conn.execute('SELECT user_id, first_name, username, group_name, role, custom_role_name FROM users').fetchall()
        return users
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении списка пользователей: {e}")
        return []
    finally:
        conn.close()

def add_user(user_id, username, first_name, last_name):
    """Adds a new user to the database or updates existing user"""
    conn = get_db_connection()
    if not conn: return
    try:
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        role = ROLE_STUDENT
        custom_role_name = None
        
        # Проверяем специальных пользователей
        if user_id in SPECIAL_USERS:
            role = SPECIAL_USERS[user_id]['role']
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, role, custom_role_name)
                         VALUES (?, ?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, role, custom_role_name))
            print(f"ЛОГ: Добавлен новый пользователь: {first_name} (ID: {user_id}) с ролью {role}")
        else:
            conn.execute('''UPDATE users 
                         SET username = ?, first_name = ?, last_name = ?, role = ?, custom_role_name = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, role, custom_role_name, user_id))
            print(f"ЛОГ: Обновлен пользователь: {first_name} (ID: {user_id}), роль: {role}")
        
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении пользователя: {e}")
    finally:
        conn.close()

def update_user_rights(user_id, rights_data):
    """Updates user rights in the database"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''UPDATE users SET
                     can_send_homework = ?,
                     can_send_notifications = ?,
                     can_send_sport_notifications = ?,
                     can_delete_homework = ?,
                     can_delete_notifications = ?,
                     can_delete_sport_notifications = ?,
                     can_delete_suggestions = ?,
                     can_create_polls = ?,
                     can_manage_users = ?,
                     role = ?,
                     custom_role_name = ?
                     WHERE user_id = ?''',
                     (rights_data.get('can_send_homework', 0),
                      rights_data.get('can_send_notifications', 0),
                      rights_data.get('can_send_sport_notifications', 0),
                      rights_data.get('can_delete_homework', 0),
                      rights_data.get('can_delete_notifications', 0),
                      rights_data.get('can_delete_sport_notifications', 0),
                      rights_data.get('can_delete_suggestions', 0),
                      rights_data.get('can_create_polls', 0),
                      rights_data.get('can_manage_users', 0),
                      rights_data.get('role', ROLE_STUDENT),
                      rights_data.get('custom_role_name', None),
                      user_id))
        conn.commit()
        print(f"ЛОГ: Обновлены права пользователя {user_id}")
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при обновлении прав: {e}")
        return False
    finally:
        conn.close()

def add_special_user(user_id, username, first_name, last_name, group_name, role_type, custom_name=None):
    """Adds a special user with specific rights"""
    conn = get_db_connection()
    if not conn: return False
    try:
        rights_data = {
            'role': ROLE_CUSTOM,
            'custom_role_name': custom_name
        }
        
        # Устанавливаем права в зависимости от типа роли
        if role_type == 'starosta':
            rights_data.update({
                'can_send_homework': 1,
                'can_send_notifications': 1,
                'can_delete_homework': 1,
                'can_delete_notifications': 1,
                'can_delete_suggestions': 1,
                'can_create_polls': 1,
                'custom_role_name': 'Староста'
            })
        elif role_type == 'deputy_starosta':
            rights_data.update({
                'can_send_homework': 1,
                'can_send_notifications': 1,
                'can_delete_homework': 1,
                'can_delete_notifications': 1,
                'can_delete_suggestions': 1,
                'can_create_polls': 1,
                'custom_role_name': 'Зам Старосты'
            })
        elif role_type == 'physical_organizer':
            rights_data.update({
                'can_send_sport_notifications': 1,
                'can_delete_sport_notifications': 1,
                'can_create_polls': 1,
                'custom_role_name': 'Физ. орг.'
            })
        elif role_type == 'custom':
            rights_data.update({
                'can_send_homework': 1,
                'can_send_notifications': 1,
                'can_send_sport_notifications': 1,
                'can_delete_homework': 1,
                'can_delete_notifications': 1,
                'can_delete_sport_notifications': 1,
                'can_delete_suggestions': 1,
                'can_create_polls': 1,
                'can_manage_users': 1,
                'custom_role_name': custom_name
            })
        
        # Добавляем/обновляем пользователя
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, group_name, role, custom_role_name,
                         can_send_homework, can_send_notifications, can_send_sport_notifications,
                         can_delete_homework, can_delete_notifications, can_delete_sport_notifications,
                         can_delete_suggestions, can_create_polls, can_manage_users)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, group_name,
                          rights_data['role'], rights_data['custom_role_name'],
                          rights_data.get('can_send_homework', 0),
                          rights_data.get('can_send_notifications', 0),
                          rights_data.get('can_send_sport_notifications', 0),
                          rights_data.get('can_delete_homework', 0),
                          rights_data.get('can_delete_notifications', 0),
                          rights_data.get('can_delete_sport_notifications', 0),
                          rights_data.get('can_delete_suggestions', 0),
                          rights_data.get('can_create_polls', 0),
                          rights_data.get('can_manage_users', 0)))
        else:
            conn.execute('''UPDATE users SET
                         username = ?, first_name = ?, last_name = ?, group_name = ?, role = ?, custom_role_name = ?,
                         can_send_homework = ?, can_send_notifications = ?, can_send_sport_notifications = ?,
                         can_delete_homework = ?, can_delete_notifications = ?, can_delete_sport_notifications = ?,
                         can_delete_suggestions = ?, can_create_polls = ?, can_manage_users = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, group_name,
                          rights_data['role'], rights_data['custom_role_name'],
                          rights_data.get('can_send_homework', 0),
                          rights_data.get('can_send_notifications', 0),
                          rights_data.get('can_send_sport_notifications', 0),
                          rights_data.get('can_delete_homework', 0),
                          rights_data.get('can_delete_notifications', 0),
                          rights_data.get('can_delete_sport_notifications', 0),
                          rights_data.get('can_delete_suggestions', 0),
                          rights_data.get('can_create_polls', 0),
                          rights_data.get('can_manage_users', 0),
                          user_id))
        
        conn.commit()
        print(f"ЛОГ: Добавлен/обновлен специальный пользователь: {first_name} (ID: {user_id}) с ролью {rights_data['custom_role_name']}")
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении специального пользователя: {e}")
        return False
    finally:
        conn.close()

def update_user_group(user_id, group_name):
    """Updates the user's group"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('UPDATE users SET group_name = ? WHERE user_id = ?', (group_name, user_id))
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} сменил группу на {group_name}")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при обновлении группы: {e}")
    finally:
        conn.close()

def set_user_birthday(user_id, birthday_date):
    """Sets or updates user's birthday"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''INSERT OR REPLACE INTO birthdays (user_id, birthday_date)
                     VALUES (?, ?)''', (user_id, birthday_date))
        conn.commit()
        print(f"ЛОГ: Установлен день рождения для пользователя {user_id}: {birthday_date}")
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при установке дня рождения: {e}")
        return False
    finally:
        conn.close()

def get_user_birthday(user_id):
    """Gets user's birthday"""
    conn = get_db_connection()
    if not conn: return None
    try:
        result = conn.execute('SELECT birthday_date FROM birthdays WHERE user_id = ?', (user_id,)).fetchone()
        return result['birthday_date'] if result else None
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении дня рождения: {e}")
        return None
    finally:
        conn.close()

def get_today_birthdays():
    """Gets all users who have birthday today"""
    conn = get_db_connection()
    if not conn: return []
    try:
        today = datetime.now().strftime('%d.%m')
        birthdays = conn.execute('''SELECT u.user_id, u.first_name, u.username, u.group_name, b.birthday_date 
                                 FROM users u JOIN birthdays b ON u.user_id = b.user_id 
                                 WHERE b.birthday_date LIKE ? AND u.group_name IS NOT NULL''', (f'{today}%',)).fetchall()
        return birthdays
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении дней рождений: {e}")
        return []
    finally:
        conn.close()

def get_total_user_count():
    """Gets the total number of users in the database"""
    conn = get_db_connection()
    if not conn: return 0
    try:
        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        return count
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при подсчете пользователей: {e}")
        return 0
    finally:
        conn.close()

def delete_homework(hw_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM homeworks WHERE id = ?', (hw_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении ДЗ: {e}")
    finally:
        conn.close()

def delete_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении уведомления: {e}")
    finally:
        conn.close()

def delete_sport_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM sport_notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении спортивного уведомления: {e}")
    finally:
        conn.close()

def delete_user(user_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} удален из базы данных.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении пользователя: {e}")
    finally:
        conn.close()

def delete_suggestion(suggestion_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM suggestions WHERE id = ?', (suggestion_id,))
        conn.commit()
        print(f"ЛОГ: Предложение {suggestion_id} удалено из базы данных.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении предложения: {e}")
    finally:
        conn.close()

def get_all_sport_notifications():
    """Gets all sport notifications"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     ORDER BY s.created_at DESC''').fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении спортивных уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_homework(subject, task, deadline, group_name, added_by):
    """Adds homework to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO homeworks (subject, task, deadline, group_name, added_by)
                     VALUES (?, ?, ?, ?, ?)''', (subject, task, deadline, group_name, added_by))
        homework_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено ДЗ для группы {group_name}.")
        return homework_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении ДЗ: {e}")
        return None
    finally:
        conn.close()

def add_homework_media(homework_id, media_type, media_id, caption=None):
    """Adds media to homework"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO homework_media (homework_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (homework_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к ДЗ: {e}")
    finally:
        conn.close()

def get_homeworks(group_name):
    """Gets homework for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        homeworks = conn.execute('''SELECT h.*, u.first_name 
                                 FROM homeworks h JOIN users u ON h.added_by = u.user_id 
                                 WHERE h.group_name = ? ORDER BY h.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for hw in homeworks:
            hw_dict = dict(hw)
            media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (hw_dict['id'],)).fetchall()
            hw_dict['media'] = [dict(m) for m in media]
            result.append(hw_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении ДЗ: {e}")
        return []
    finally:
        conn.close()

def add_notification(message, group_name, added_by):
    """Adds a notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        notification_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено уведомление для группы {group_name}.")
        return notification_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении уведомления: {e}")
        return None
    finally:
        conn.close()

def add_notification_media(notification_id, media_type, media_id, caption=None):
    """Adds media to notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO notification_media (notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к уведомлению: {e}")
    finally:
        conn.close()

def get_notifications(group_name):
    """Gets notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT n.*, u.first_name 
                                     FROM notifications n JOIN users u ON n.added_by = u.user_id 
                                     WHERE n.group_name = ? ORDER BY n.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for notif in notifications:
            notif_dict = dict(notif)
            media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notif_dict['id'],)).fetchall()
            notif_dict['media'] = [dict(m) for m in media]
            result.append(notif_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_sport_notification(message, group_name, added_by):
    """Adds a sport notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO sport_notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        sport_notification_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено спортивное уведомление для группы {group_name}.")
        return sport_notification_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении спортивного уведомления: {e}")
        return None
    finally:
        conn.close()

def add_sport_notification_media(sport_notification_id, media_type, media_id, caption=None):
    """Adds media to sport notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO sport_notification_media (sport_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (sport_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к спортивному уведомлению: {e}")
    finally:
        conn.close()

def get_sport_notifications(group_name):
    """Gets sport notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     WHERE s.group_name = ? ORDER BY s.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for sport in notifications:
            sport_dict = dict(sport)
            media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_dict['id'],)).fetchall()
            sport_dict['media'] = [dict(m) for m in media]
            result.append(sport_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении спортивных уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_suggestion(user_id, message):
    """Adds a suggestion to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO suggestions (user_id, message) VALUES (?, ?)', (user_id, message))
        suggestion_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} отправил предложение.")
        return suggestion_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении предложения: {e}")
        return None
    finally:
        conn.close()

def add_suggestion_media(suggestion_id, media_type, media_id, caption=None):
    """Adds media to suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_media (suggestion_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (suggestion_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к предложению: {e}")
    finally:
        conn.close()

def add_suggestion_response(suggestion_id, responder_id, message):
    """Adds a response to a suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_responses (suggestion_id, responder_id, message)
                     VALUES (?, ?, ?)''', (suggestion_id, responder_id, message))
        conn.commit()
        print(f"ЛОГ: Добавлен ответ на предложение {suggestion_id}.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении ответа на предложение: {e}")
    finally:
        conn.close()

def get_suggestions():
    """Gets all suggestions"""
    conn = get_db_connection()
    if not conn: return []
    try:
        suggestions = conn.execute('''SELECT s.*, u.first_name, u.username 
                                   FROM suggestions s JOIN users u ON s.user_id = u.user_id 
                                   ORDER BY s.created_at DESC''').fetchall()
        
        result = []
        for s in suggestions:
            s_dict = dict(s)
            media = conn.execute('SELECT * FROM suggestion_media WHERE suggestion_id = ?', (s_dict['id'],)).fetchall()
            s_dict['media'] = [dict(m) for m in media]
            
            responses = conn.execute('''SELECT sr.*, u.first_name, u.username 
                                    FROM suggestion_responses sr JOIN users u ON sr.responder_id = u.user_id 
                                    WHERE sr.suggestion_id = ? ORDER BY sr.created_at''', (s_dict['id'],)).fetchall()
            s_dict['responses'] = [dict(r) for r in responses]
            
            result.append(s_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении предложений: {e}")
        return []
    finally:
        conn.close()

def add_poll(question, options, group_name, added_by, message_id):
    """Adds a poll to the database"""
    conn = get_db_connection()
    if not conn: return
    try:
        options_json = json.dumps(options)
        conn.execute('''INSERT INTO polls (question, options, group_name, added_by, message_id)
                     VALUES (?, ?, ?, ?, ?)''', (question, options_json, group_name, added_by, message_id))
        conn.commit()
        print(f"ЛОГ: Добавлен опрос для группы {group_name}.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении опроса: {e}")
    finally:
        conn.close()

def add_global_notification(message, added_by):
    """Adds a global notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO global_notifications (message, added_by) VALUES (?, ?)', (message, added_by))
        global_notification_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено глобальное уведомление.")
        return global_notification_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении глобального уведомления: {e}")
        return None
    finally:
        conn.close()

def add_global_notification_media(global_notification_id, media_type, media_id, caption=None):
    """Adds media to global notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO global_notification_media (global_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (global_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к глобальному уведомлению: {e}")
    finally:
        conn.close()

# -------------------- SPAM PROTECTION --------------------

def check_spam(user_id):
    """Checks if user is spamming"""
    now = datetime.now().timestamp()
    
    if user_id in user_blocks and now < user_blocks[user_id]:
        return True, user_blocks[user_id] - now
    
    if user_id not in user_message_times:
        user_message_times[user_id] = []
        user_warnings[user_id] = 0
    
    user_message_times[user_id].append(now)
    user_message_times[user_id] = [t for t in user_message_times[user_id] if now - t < SPAM_WINDOW]
    
    if len(user_message_times[user_id]) >= SPAM_THRESHOLD:
        user_warnings[user_id] += 1
        warning_count = user_warnings[user_id]
        
        if warning_count - 1 < len(BLOCK_DURATIONS):
            block_duration = BLOCK_DURATIONS[warning_count - 1]
        else:
            block_duration = BLOCK_DURATIONS[-1]
        
        user_blocks[user_id] = now + block_duration
        user_message_times[user_id] = []
        return True, block_duration
    
    return False, 0

async def warn_user(update: Update, block_duration: int):
    """Warns user about spam"""
    minutes = block_duration // 60
    await update.message.reply_text(
        f"⚠️ Не спамьте! Подождите немного перед следующим сообщением.\n"
        f"Вы заблокированы на {minutes} минут."
    )

# -------------------- MEDIA COLLECTION FUNCTIONS --------------------

def init_user_media_collection(user_id):
    """Initializes media collection for a user"""
    if user_id not in user_media_collections:
        user_media_collections[user_id] = {
            'homework': [],
            'notification': [],
            'sport': [],
            'suggestion': [],
            'global_notification': []
        }

def add_to_media_collection(user_id, media_type, media_data):
    """Adds media to user's collection"""
    init_user_media_collection(user_id)
    user_media_collections[user_id][media_type].append(media_data)

def clear_media_collection(user_id, media_type):
    """Clears user's media collection"""
    if user_id in user_media_collections:
        user_media_collections[user_id][media_type] = []

def get_media_collection(user_id, media_type):
    """Gets user's media collection"""
    init_user_media_collection(user_id)
    return user_media_collections[user_id][media_type]

# -------------------- USER RIGHTS CHECK FUNCTIONS --------------------

def can_send_homework(user_id):
    """Checks if user can send homework"""
    user = get_user(user_id)
    if not user: return False
    return user['can_send_homework'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_send_notifications(user_id):
    """Checks if user can send notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_send_notifications'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_send_sport_notifications(user_id):
    """Checks if user can send sport notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_send_sport_notifications'] == 1 or user['role'] == ROLE_PHYSICAL_ORGANIZER or user_id == DEVELOPER_ID

def can_delete_homework(user_id):
    """Checks if user can delete homework"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_homework'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_delete_notifications(user_id):
    """Checks if user can delete notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_notifications'] == 1 or user['role'] == ROLE_IT_SPECIALIST or user_id == DEVELOPER_ID

def can_delete_sport_notifications(user_id):
    """Checks if user can delete sport notifications"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_sport_notifications'] == 1 or user['role'] == ROLE_PHYSICAL_ORGANIZER or user_id == DEVELOPER_ID

def can_delete_suggestions(user_id):
    """Checks if user can delete suggestions"""
    user = get_user(user_id)
    if not user: return False
    return user['can_delete_suggestions'] == 1 or user['role'] in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER] or user_id == DEVELOPER_ID

def can_create_polls(user_id):
    """Checks if user can create polls"""
    user = get_user(user_id)
    if not user: return False
    return user['can_create_polls'] == 1 or user['role'] in [ROLE_IT_SPECIALIST, ROLE_PHYSICAL_ORGANIZER] or user_id == DEVELOPER_ID

def can_manage_users(user_id):
    """Checks if user can manage users"""
    user = get_user(user_id)
    if not user: return False
    return user['can_manage_users'] == 1 or user_id == DEVELOPER_ID

# -------------------- UPDATED SCHEDULE FUNCTIONS --------------------

def fetch_schedule_data():
    """Fetches schedule data from the new API endpoint"""
    try:
        url = "https://ops.pmk-online.ru/schedule/request.php?token=Uf40-ZZkp-t5Nv-ZD5v"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        print("ЛОГ: Загрузка расписания с API...")
        resp = requests.get(url, headers=headers, timeout=15)
        resp.raise_for_status()
        data = resp.json()

        print(f"ЛОГ: Успешно загружено расписание. Занятий: {len(data)}")
        return data
    except requests.exceptions.RequestException as e:
        print(f"ОШИБКА: Ошибка сети при загрузке расписания: {e}")
        return None
    except Exception as e:
        print(f"ОШИБКА: Неизвестная ошибка при загрузке расписания: {e}")
        return None

def fetch_groups_list():
    """Fetches and updates the list of groups from schedule data"""
    global ALL_GROUPS, groups_cache, last_groups_check
    
    try:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return ALL_GROUPS
        
        # Extract unique groups from schedule data
        groups = set()
        for lesson in schedule_data:
            if 'group' in lesson:
                groups.add(lesson['group'])
        
        # Sort groups by course and number
        def group_sort_key(group_name):
            try:
                # Extract course number (first digit after dash)
                parts = group_name.split('-')
                if len(parts) > 1:
                    number_part = parts[1]
                    # Find first digit in number part
                    for char in number_part:
                        if char.isdigit():
                            course = int(char)
                            return (course, group_name)
            except:
                pass
            return (0, group_name)
        
        sorted_groups = sorted(groups, key=group_sort_key)
        ALL_GROUPS = sorted_groups
        groups_cache = sorted_groups
        last_groups_check = datetime.now(YEKATERINBURG_TZ)
        
        print(f"ЛОГ: Обновлен список групп. Всего групп: {len(ALL_GROUPS)}")
        return ALL_GROUPS
    except Exception as e:
        print(f"ОШИБКА: Ошибка при обновлении списка групп: {e}")
        return ALL_GROUPS

def parse_lesson_data(lesson):
    """Parses lesson data from the new API format"""
    try:
        if not isinstance(lesson, dict):
            return None
            
        lesson_data = {}
        
        # Basic lesson information
        lesson_data['group'] = lesson.get('group', 'Не указана')
        lesson_data['number'] = lesson.get('number', 0)
        lesson_data['type'] = lesson.get('type', 'Занятие')
        lesson_data['subject'] = lesson.get('subject', 'Не указано')
        lesson_data['campus'] = lesson.get('campus', 'Не указан')
        lesson_data['room'] = lesson.get('room', 'Не указана')
        lesson_data['teacher'] = lesson.get('teacher', 'Не указан')
        
        # Parse dates and convert to Yekaterinburg timezone
        start_time_str = lesson.get('startTime', '')
        end_time_str = lesson.get('endTime', '')
        
        if start_time_str:
            try:
                start_time_utc = datetime.fromisoformat(start_time_str.replace('Z', '+00:00'))
                start_time_yekat = start_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['date'] = start_time_yekat.strftime('%Y-%m-%d')
                lesson_data['start_time'] = start_time_yekat.strftime('%H:%M')
                lesson_data['datetime'] = start_time_yekat
            except:
                lesson_data['date'] = 'Не указана'
                lesson_data['start_time'] = 'Не указано'
        
        if end_time_str:
            try:
                end_time_utc = datetime.fromisoformat(end_time_str.replace('Z', '+00:00'))
                end_time_yekat = end_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['end_time'] = end_time_yekat.strftime('%H:%M')
            except:
                lesson_data['end_time'] = 'Не указано'
        
        return lesson_data
    except Exception as e:
        print(f"ОШИБКА: Не удалось распарсить данные занятия: {e}")
        return None

def filter_lessons_by_date(lessons, target_date):
    """Filters lessons for a specific date"""
    try:
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if lesson_date == target_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"ОШИБКА: Ошибка при фильтрации занятий: {e}")
        return []

def filter_lessons_by_week(lessons, start_date):
    """Filters lessons for a week starting from start_date"""
    try:
        end_date = start_date + timedelta(days=7)
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if start_date <= lesson_date <= end_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"ОШИБКА: Ошибка при фильтрации занятий на неделю: {e}")
        return []

def get_type_emoji(lesson_type):
    """Returns emoji for lesson type"""
    emoji_map = {
        'Занятие': '📚',
        'Практика': '🔬', 
        'Лекция': '📖',
        'Экзамен': '📝',
        'Консультация': '💬',
        'Лабораторная работа': '⚗️',
        'Семинар': '💡',
        'Зачет': '✅'
    }
    return emoji_map.get(lesson_type, '📚')

def format_schedule(lessons, title):
    """Formats schedule for display with the new format"""
    try:
        if not lessons:
            return f"✅ Нет занятий для {title.split('(')[-1].split(')')[0]}"
        
        # Sort lessons by date and time
        lessons.sort(key=lambda x: (x.get('datetime', datetime.min), x.get('number', 0)))
        
        result = [f"<b>{title}</b>\n"]
        current_date = None
        
        for lesson in lessons:
            try:
                if 'datetime' in lesson:
                    date_str = lesson['datetime'].strftime('%d.%m.%Y')
                    day_names = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье']
                    day_of_week = day_names[lesson['datetime'].weekday()]
                    
                    if date_str != current_date:
                        current_date = date_str
                        result.append(f"\n📅 <b>{date_str} ({day_of_week})</b>")
                    
                    type_emoji = get_type_emoji(lesson['type'])
                    start_time = lesson.get('start_time', '❓')
                    end_time = lesson.get('end_time', '❓')
                    
                    lesson_text = (
                        f"    {type_emoji} {lesson['type']}\n"
                        f"    ⏰ {start_time}-{end_time} | {lesson['number']} пара\n"
                        f"    📚 {lesson['subject']}\n"
                        f"    👨‍🏫 {lesson['teacher']}\n"
                        f"    🚪 {lesson['room']}({lesson['campus']})\n"
                    )
                    result.append(lesson_text)
            except Exception as e:
                print(f"ОШИБКА: Не удалось отформатировать пару: {e}")
                continue
        
        result.append(f"\n📊 <b>Всего занятий:</b> {len(lessons)}")
        return "\n".join(result)
    except Exception as e:
        print(f"ОШИБКА: Ошибка при форматировании расписания: {e}")
        return f"❌ Ошибка при формировании расписания: {str(e)}"

def get_schedule(period, group_name):
    """Gets and formats the schedule with the new API"""
    try:
        global schedule_cache, last_schedule_check
        
        # Check cache
        now = datetime.now(YEKATERINBURG_TZ)
        if last_schedule_check is None or (now - last_schedule_check).total_seconds() > 3600:
            print(f"ЛОГ: Обновляем кэш расписания для группы {group_name}")
            schedule_data = fetch_schedule_data()
            if schedule_data:
                schedule_cache = schedule_data
                last_schedule_check = now
                print("ЛОГ: Расписание обновлено из API")
            else:
                print("ЛОГ: Не удалось обновить расписание, используем кэш если есть")
        else:
            schedule_data = schedule_cache
            print("ЛОГ: Используем кэшированное расписание")
        
        if not schedule_data:
            return "❌ Не удалось загрузить расписание. Попробуйте позже."
        
        # Filter lessons for the specific group
        group_lessons = [lesson for lesson in schedule_data if lesson.get('group') == group_name]
        
        if not group_lessons:
            return f"❌ Нет расписания для группы {group_name}"
        
        # Filter lessons by period
        today_yekat = datetime.now(YEKATERINBURG_TZ).date()
        
        if period == '📅 Сегодня':
            filtered_lessons = filter_lessons_by_date(group_lessons, today_yekat)
            title = f"📅 Расписание на сегодня ({group_name})"
        elif period == '📅 Завтра':
            tomorrow_yekat = today_yekat + timedelta(days=1)
            filtered_lessons = filter_lessons_by_date(group_lessons, tomorrow_yekat)
            title = f"📅 Расписание на завтра ({group_name})"
        elif period == '📅 Неделя':
            filtered_lessons = filter_lessons_by_week(group_lessons, today_yekat)
            title = f"📅 Расписание на неделю ({group_name})"
        else:
            # For "Все расписание" parse all lessons
            filtered_lessons = []
            for lesson in group_lessons:
                parsed = parse_lesson_data(lesson)
                if parsed:
                    filtered_lessons.append(parsed)
            title = f"📅 Все расписание ({group_name})"
        
        return format_schedule(filtered_lessons, title)
        
    except Exception as e:
        print(f"ОШИБКА: Произошла ошибка при получении расписания: {str(e)}")
        return f"❌ Произошла ошибка при загрузке расписания: {str(e)}"

async def check_schedule_changes(context: ContextTypes.DEFAULT_TYPE):
    """Checks for schedule changes with the new API"""
    global schedule_cache, last_schedule_check
    
    print("ЛОГ: Проверка изменений в расписании...")
    new_schedule = fetch_schedule_data()
    
    if not new_schedule:
        print("ЛОГ: Не удалось проверить изменения расписания")
        return

    # Extract groups from new schedule
    new_groups = set()
    for lesson in new_schedule:
        if 'group' in lesson:
            new_groups.add(lesson['group'])
    
    # Compare with old groups
    old_groups = set()
    for lesson in schedule_cache:
        if 'group' in lesson:
            old_groups.add(lesson['group'])
    
    # Check for new or removed groups
    added_groups = new_groups - old_groups
    removed_groups = old_groups - new_groups
    
    if added_groups or removed_groups:
        print(f"ЛОГ: Обнаружены изменения в группах")
        
        for group_name in added_groups:
            change_message = f"🔄 <b>Добавлена новая группа: {group_name}</b>\n\nИспользуйте команду '🎓 Сменить группу' для выбора этой группы."
            
            # Notify special users about new group
            special_users = [u for u in get_all_users() if u['user_id'] in SPECIAL_USERS or u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")
        
        for group_name in removed_groups:
            change_message = f"🔄 <b>Группа {group_name} удалена из расписания</b>\n\nУченики этой группы могут выбрать другую группу."
            
            # Notify special users about removed group
            special_users = [u for u in get_all_users() if u['user_id'] in SPECIAL_USERS or u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")

    schedule_cache = new_schedule
    last_schedule_check = datetime.now(YEKATERINBURG_TZ)

async def send_daily_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends daily schedule at 19:00 with the new API"""
    print("ЛОГ: Отправка ежедневного расписания...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        tomorrow_yekat = (datetime.now(YEKATERINBURG_TZ) + timedelta(days=1)).date()
        tomorrow_lessons = filter_lessons_by_date(lessons, tomorrow_yekat)
        
        if tomorrow_lessons:
            schedule_text = format_schedule(tomorrow_lessons, f"📅 Расписание на завтра ({group_name})")
            
            homeworks = get_homeworks(group_name)
            if homeworks:
                homework_text = "\n\n📝 <b>Домашние задания:</b>\n"
                for hw in homeworks[:3]:
                    homework_text += f"• {hw['subject']}: {hw['task']} (до {hw['deadline']})\n"
                schedule_text += homework_text
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить расписание пользователю {user['user_id']}: {e}")

async def send_morning_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends morning schedule at 07:00 with the new API"""
    print("ЛОГ: Отправка утреннего расписания...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        today_lessons = filter_lessons_by_date(lessons, datetime.now(YEKATERINBURG_TZ).date())
        
        if today_lessons:
            schedule_text = format_schedule(today_lessons, f"📅 Расписание на сегодня ({group_name})")
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить расписание пользователю {user['user_id']}: {e}")

# -------------------- BIRTHDAY FUNCTIONS --------------------

async def ask_birthday_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks user to input birthday date"""
    user_id = update.effective_user.id
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    user_data = get_user(user_id)
    if not user_data or not user_data['group_name']:
        await update.message.reply_text("❌ Сначала выберите свою группу!")
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    await update.message.reply_text(
        "🎂 <b>Установка дня рождения</b>\n\n"
        "Введите дату своего рождения в формате <b>ДД.ММ</b>\n"
        "Например: 15.09 (для 15 сентября)\n\n"
        "Бот будет поздравлять вас в ваш день рождения и уведомлять вашу группу!",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
    )
    return AWAITING_BIRTHDAY

async def handle_birthday_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles birthday date input"""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    if text == '❌ Отмена':
        return await cancel_conversation(update, context)
    
    try:
        if not re.match(r'^\d{1,2}\.\d{1,2}$', text):
            raise ValueError("Неверный формат")
        
        day, month = text.split('.')
        day = int(day)
        month = int(month)
        
        if month < 1 or month > 12:
            raise ValueError("Месяц должен быть от 1 до 12")
        if day < 1 or day > 31:
            raise ValueError("День должен быть от 1 до 31")
        
        if month == 2 and day > 29:
            raise ValueError("В феврале не может быть больше 29 дней")
        elif month in [4, 6, 9, 11] and day > 30:
            raise ValueError("В этом месяце не может быть больше 30 дней")
            
        birthday_date = f"{day:02d}.{month:02d}"
        
        if set_user_birthday(user_id, birthday_date):
            await update.message.reply_text(
                f"✅ Дата рождения установлена: {birthday_date}\n"
                f"Теперь бот будет поздравлять вас каждый год!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text("❌ Ошибка при сохранении даты рождения")
            
    except ValueError as e:
        await update.message.reply_text(
            f"❌ {str(e)}. Введите дату в формате <b>ДД.ММ</b>\n"
            "Пример: 15.09 (для 15 сентября)",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    except Exception as e:
        await update.message.reply_text(
            "❌ Произошла ошибка. Попробуйте еще раз.",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def check_birthdays(context: ContextTypes.DEFAULT_TYPE):
    """Checks for birthdays and sends notifications"""
    print("ЛОГ: Проверка дней рождений...")
    
    today_birthdays = get_today_birthdays()
    
    for birthday_user in today_birthdays:
        user_id = birthday_user['user_id']
        user_name = birthday_user['first_name']
        username = f"@{birthday_user['username']}" if birthday_user['username'] else user_name
        group_name = birthday_user['group_name']
        
        try:
            await context.bot.send_message(
                user_id,
                f"🎂 <b>С ДНЕМ РОЖДЕНИЯ, {user_name}!</b>\n\n"
                f"Желаем вам всего самого лучшего! 🎉",
                parse_mode='HTML'
            )
            print(f"ЛОГ: Отправлено поздравление пользователю {user_id}")
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить поздравление пользователю {user_id}: {e}")
        
        users_in_group = get_db_connection().execute(
            'SELECT user_id FROM users WHERE group_name = ? AND user_id != ?', 
            (group_name, user_id)
        ).fetchall()
        
        for group_user in users_in_group:
            try:
                await context.bot.send_message(
                    group_user['user_id'],
                    f"🎉 У {user_name} ({username}) сегодня день рождения!\n\n"
                    f"Не забудьте поздравить! 😊",
                    parse_mode='HTML'
                )
            except Exception as e:
                print(f"ОШИБКА: Не удалось отправить уведомление пользователю {group_user['user_id']}: {e}")
    
    if today_birthdays:
        print(f"ЛОГ: Обработано {len(today_birthdays)} дней рождений")

# -------------------- GLOBAL NOTIFICATION FUNCTIONS --------------------

async def ask_global_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for global notification details (only for developer)"""
    user_id = update.effective_user.id
    
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("❌ У вас нет прав для этого действия.")
        return ConversationHandler.END
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    clear_media_collection(user_id, 'global_notification')
    
    await update.message.reply_text(
        "🌍 <b>Отправка глобального уведомления всем группам</b>\n\n"
        "Напиши важное уведомление, которое нужно отправить ВСЕМ ученикам ВСЕХ групп.\n"
        "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст уведомления.",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
    )
    return AWAITING_GLOBAL_NOTIFICATION

async def handle_global_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles global notification input"""
    user_id = update.effective_user.id
    
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("❌ У вас нет прав для этого действия.")
        return await cancel_conversation(update, context)
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return AWAITING_GLOBAL_NOTIFICATION
    
    text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
    
    if text and text.strip() == '❌ Отмена':
        return await cancel_conversation(update, context)
    
    if text and text.strip() == '✅ Готово':
        media_collection = get_media_collection(user_id, 'global_notification')
        notification_text = context.user_data.get('global_notification_text', '')
        
        if not notification_text:
            await update.message.reply_text("❌ Пожалуйста, добавь текст глобального уведомления.")
            return AWAITING_GLOBAL_NOTIFICATION

        global_notification_id = add_global_notification(notification_text, user_id)
        
        if global_notification_id:
            for media_item in media_collection:
                add_global_notification_media(global_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            await update.message.reply_text("✅ Глобальное уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
            await send_global_notification_to_all(context.bot, global_notification_id, notification_text, user_id)
            
            clear_media_collection(user_id, 'global_notification')
            context.user_data.pop('global_notification_text', None)
        else:
            await update.message.reply_text("❌ Ошибка при добавлении глобального уведомления.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    if update.message.photo:
        photo = update.message.photo[-1]
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'photo',
            'id': photo.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.video:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'video',
            'id': update.message.video.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.document:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'document',
            'id': update.message.document.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    if text and text.strip():
        context.user_data['global_notification_text'] = text
        await update.message.reply_text("✅ Текст глобального уведомления сохранен. Отправьте медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    await update.message.reply_text("❌ Пожалуйста, добавь текст глобального уведомления.")
    return AWAITING_GLOBAL_NOTIFICATION

async def send_global_notification_to_all(bot, global_notification_id, message, added_by):
    """Sends a global notification to all users"""
    global_text = (
        f"🌍 <b>ВАЖНОЕ УВЕДОМЛЕНИЕ ОТ РАЗРАБОТЧИКА</b>\n\n"
        f"{message}\n\n"
        f"👤 <b>От:</b> Зам Старосты (Разработчик)"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM global_notification_media WHERE global_notification_id = ?', (global_notification_id,)).fetchall()
    conn.close()
    
    users = get_all_users()
    
    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=global_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=global_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=global_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=global_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=global_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=global_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], global_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить глобальное уведомление пользователю {user['user_id']}: {e}")

# -------------------- CORE BOT FUNCTIONS --------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for the /start command with dynamic groups"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        add_user(user_id, user.username, user.first_name, user.last_name)
        user_data = get_user(user_id)
        
        # Update groups list
        fetch_groups_list()
        
        if not user_data or not user_data['group_name'] or user_data['group_name'] not in ALL_GROUPS:
            print(f"ЛОГ: Пользователь {user.first_name} (ID: {user_id}) не имеет группы, запрашиваем выбор группы.")
            return await ask_user_group(update, context)

        print(f"ЛОГ: Пользователь {user.first_name} (ID: {user.id}) вернулся в главное меню.")
        
        if user_id in SPECIAL_USERS and user_data['role'] != SPECIAL_USERS[user_id]['role']:
            keyboard = [[InlineKeyboardButton("🔄 Принудительно исправить роль", callback_data=f"fix_role_{user_id}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(
                "⚠️ Обнаружено несоответствие роли. Нажмите кнопку ниже, чтобы исправить:",
                reply_markup=reply_markup
            )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в start_command: {e}")
        try:
            await update.message.reply_text(
                "Произошла ошибка при запуске бота. Попробуйте еще раз.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def ask_user_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks the user to select their group with dynamic list"""
    try:
        # Update groups list from API
        groups = fetch_groups_list()
        if not groups:
            await update.message.reply_text(
                "❌ Не удалось загрузить список групп. Попробуйте позже.",
                reply_markup=ReplyKeyboardRemove()
            )
            return ConversationHandler.END
        
        # Create keyboard with groups
        keyboard = [groups[i:i+3] for i in range(0, len(groups), 3)]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
        
        message_source = update.callback_query.message if update.callback_query else update.message
        await message_source.reply_text(
            "👋 Выбери свою группу:",
            reply_markup=reply_markup
        )
        
        return AWAITING_GROUP
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_user_group: {e}")
        return ConversationHandler.END

async def handle_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the user's group selection with dynamic list"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_GROUP
        
        group_name = update.message.text
        
        # Update groups list to ensure we have the latest
        current_groups = fetch_groups_list()
        
        if group_name not in current_groups:
            await update.message.reply_text(
                "❌ Пожалуйста, выбери группу из списка:",
                reply_markup=ReplyKeyboardMarkup([current_groups[i:i+3] for i in range(0, len(current_groups), 3)], 
                                               resize_keyboard=True, one_time_keyboard=True)
            )
            return AWAITING_GROUP
        
        update_user_group(user_id, group_name)
        
        await update.message.reply_text(
            f"✅ Группа {group_name} сохранена!",
            reply_markup=ReplyKeyboardRemove()
        )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_group_selection: {e}")
        return ConversationHandler.END

async def show_main_menu(update: Update, user_id: int):
    """Displays the main menu based on user rights with error handling"""
    try:
        user_data = get_user(user_id)
        if not user_data:
            await update.message.reply_text("Произошла ошибка, попробуйте /start еще раз.")
            return

        role = user_data['role']
        custom_role = user_data['custom_role_name']
        
        welcome_text = "👋 Добро пожаловать!"
        
        if custom_role:
            welcome_text = f"👑 Добро пожаловать, {custom_role}!"
        elif user_id in SPECIAL_USERS:
            welcome_text = f"👑 Добро пожаловать, {SPECIAL_USERS[user_id]['name']}!"
        elif role == ROLE_IT_SPECIALIST:
            welcome_text = "👑 Добро пожаловать, Айтишник!"
        elif role == ROLE_PHYSICAL_ORGANIZER:
            welcome_text = "🏃 Добро пожаловать, Физ. орг.!"

        # Создаем клавиатуру в зависимости от прав
        if user_id == DEVELOPER_ID:
            keyboard = [
                ['📅 Расписание', '📝 ДЗ'],
                ['ℹ️ Информация', '💡 Предложения', '💡 Предложить идею'],
                ['📢 Отправить ДЗ', '📢 Отправить уведомление', '🌍 Отправить всем группам'],
                ['Удалить ДЗ', 'Удалить уведомление', 'Удалить предложения'],
                ['Удалить пользователя', 'Удалить спортивные уведомления', 'Список пользователей'],
                ['💰 Дать денюжку', '🔔 Расписание звонков', '📊 Создать опрос'],
                ['🎂 Установить день рождения', '🎓 Сменить группу'],
                ['👑 Добавить спец пользователя', '🔧 Управление правами']
            ]
        elif can_manage_users(user_id):
            keyboard = [
                ['📅 Расписание', '📝 ДЗ'],
                ['ℹ️ Информация', '💡 Предложения', '💡 Предложить идею'],
                ['📢 Отправить ДЗ', '📢 Отправить уведомление'],
                ['Удалить ДЗ', 'Удалить уведомление', 'Удалить предложения'],
                ['Удалить спортивные уведомления', 'Список пользователей'],
                ['💰 Дать денюжку', '🔔 Расписание звонков', '📊 Создать опрос'],
                ['🎂 Установить день рождения', '🎓 Сменить группу'],
                ['🔧 Управление правами']
            ]
        elif can_send_homework(user_id) and can_send_notifications(user_id):
            keyboard = [
                ['📅 Расписание', '📝 ДЗ'],
                ['ℹ️ Информация', '💡 Предложения', '💡 Предложить идею'],
                ['📢 Отправить ДЗ', '📢 Отправить уведомление'],
                ['Удалить ДЗ', 'Удалить уведомление', 'Удалить предложения'],
                ['💰 Дать денюжку', '🔔 Расписание звонков', '📊 Создать опрос'],
                ['🎂 Установить день рождения', '🎓 Сменить группу']
            ]
        elif can_send_sport_notifications(user_id):
            keyboard = [
                ['📅 Расписание', '📝 ДЗ'],
                ['ℹ️ Информация', '💡 Предложения', '💡 Предложить идею'],
                ['🏃 Отправить спортивное уведомление', 'Удалить спортивные уведомления'],
                ['💰 Дать денюжку', '🔔 Расписание звонков', '📊 Создать опрос'],
                ['🎂 Установить день рождения', '🎓 Сменить группу']
            ]
        else:
            keyboard = [
                ['📅 Расписание', '📝 ДЗ'],
                ['ℹ️ Информация', '💡 Предложить идею'],
                ['💰 Дать денюжку', '🔔 Расписание звонков'],
                ['📞 Связаться со старостой', '📞 Связаться с замом старосты'],
                ['📞 Связаться с физоргом'],
                ['🎂 Установить день рождения', '🎓 Сменить группу']
            ]
        
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        
        message_source = update.callback_query.message if update.callback_query else update.message
        await message_source.reply_text(welcome_text, reply_markup=reply_markup)
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_main_menu: {e}")
        try:
            await update.message.reply_text(
                "Произошла ошибка при загрузке меню. Попробуйте команду /start",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels the current conversation"""
    try:
        user = update.effective_user
        user_id = user.id
        
        await update.message.reply_text("Действие отменено.", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в cancel_conversation: {e}")
        return ConversationHandler.END

async def handle_simple_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for simple text messages with error handling"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        text = update.message.text
        user_data = get_user(user_id)
        
        print(f"ЛОГ: Пользователь {user.first_name} (ID: {user_id}) отправил сообщение: '{text}'")
        
        if not user_data or not user_data['group_name'] or user_data['group_name'] not in ALL_GROUPS:
            add_user(user_id, user.username, user.first_name, user.last_name)
            return await ask_user_group(update, context)

        role = user_data['role']
        group_name = user_data['group_name']
        
        if text == '📅 Расписание':
            await show_schedule_periods(update, user_id)
        
        elif text == '📝 ДЗ':
            await show_homework(update, group_name)
        
        elif text == 'ℹ️ Информация':
            await show_information(update, group_name, role)

        elif text == '💡 Предложения' and can_delete_suggestions(user_id):
            await show_suggestions(update)
        
        elif text == 'Список пользователей' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await show_users_list(update)

        elif text == '💰 Дать денюжку':
            donate_text = "Если не жалко, можешь дать разрабу бота денюжку на дальнейшее развитие бота и на покушать😊"
            keyboard = [[InlineKeyboardButton("💸 Поддержать автора", url="https://www.donationalerts.com/r/ax_hikitka")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(donate_text, reply_markup=reply_markup)

        elif text == '🔔 Расписание звонков':
            await show_call_schedule(update)
        
        elif text == '📞 Связаться с физоргом':
            await contact_physical_organizer(update)
        
        elif text == '📞 Связаться со старостой':
            await contact_starosta(update)

        elif text == '📞 Связаться с замом старосты':
            await contact_deputy_starosta(update)
        
        elif text in ['📅 Сегодня', '📅 Завтра', '📅 Неделя', '📅 Все расписание']:
            await handle_schedule_period(update, context, group_name)
    
        elif text == '🔙 Назад':
            await show_main_menu(update, user_id)

        elif text == 'Удалить пользователя' and user_id == DEVELOPER_ID:
            await delete_user_menu(update, context)

        elif text == 'Удалить спортивные уведомления' and can_delete_sport_notifications(user_id):
            await delete_sport_notification_menu(update, context)
            
        elif text == 'Удалить предложения' and can_delete_suggestions(user_id):
            await delete_suggestions_menu(update, context)
            
        elif text == 'Удалить ДЗ' and can_delete_homework(user_id):
            await delete_homework_menu(update, context)

        elif text == 'Удалить уведомление' and can_delete_notifications(user_id):
            await delete_notification_menu(update, context)
            
        elif text == '📊 Создать опрос' and can_create_polls(user_id):
            await ask_poll_details(update, context)
        
        elif text == '📢 Отправить ДЗ' and can_send_homework(user_id):
            await ask_homework_details(update, context)
        
        elif text == '📢 Отправить уведомление' and can_send_notifications(user_id):
            await ask_notification_details(update, context)
            
        elif text == '🌍 Отправить всем группам' and user_id == DEVELOPER_ID:
            await ask_global_notification_details(update, context)
        
        elif text == '💡 Предложить идею':
            await ask_suggestion_details(update, context)
        
        elif text == '🎂 Установить день рождения':
            await ask_birthday_date(update, context)
        
        elif text == '🎓 Сменить группу':
            return await ask_user_group(update, context)
            
        elif text == '👑 Добавить спец пользователя' and user_id == DEVELOPER_ID:
            await add_special_user_menu(update, context)
            
        elif text == '🔧 Управление правами' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await manage_user_rights_menu(update, context)

        else:
            await update.message.reply_text("Используй кнопки для навигации 👇")
    
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_simple_message: {e}")
        try:
            await update.message.reply_text(
                "Произошла ошибка при обработке сообщения. Попробуйте еще раз.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

# -------------------- SCHEDULE DISPLAY FUNCTIONS --------------------

async def show_schedule_periods(update: Update, user_id: int):
    """Shows the schedule period selection"""
    try:
        keyboard = [
            ['📅 Сегодня', '📅 Завтра'],
            ['📅 Неделя', '📅 Все расписание'],
            ['🔙 Назад']
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text("Выбери период для просмотра расписания:", reply_markup=reply_markup)
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_schedule_periods: {e}")

async def handle_schedule_period(update: Update, context: ContextTypes.DEFAULT_TYPE, group_name: str):
    """Handles the schedule period selection with error handling"""
    try:
        text = update.message.text
        await update.message.reply_text("⏳ Загружаю расписание...", reply_markup=ReplyKeyboardRemove())
        schedule = get_schedule(text, group_name)
        await update.message.reply_text(schedule, parse_mode='HTML')
        await show_main_menu(update, update.effective_user.id)
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_schedule_period: {e}")
        await update.message.reply_text(
            "❌ Произошла ошибка при загрузке расписания. Попробуйте позже.",
            parse_mode='HTML'
        )

# -------------------- MESSAGE SENDING FUNCTIONS --------------------

async def ask_homework_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for homework details to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_homework(user_id):
            await update.message.reply_text("❌ У вас нет прав для отправки ДЗ.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'homework')
        
        await update.message.reply_text(
            "📝 <b>Добавление нового ДЗ</b>\n\n"
            "Напиши в формате:\n"
            "<b>Предмет</b>\n"
            "<b>Задание</b>\n"
            "<b>Срок сдачи</b>\n\n"
            "Пример:\n"
            "Математика\n"
            "Решить задачи 1-10 на странице 45\n"
            "До 15.09\n\n"
            "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст с описанием ДЗ.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_homework_details: {e}")
        return ConversationHandler.END

async def ask_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for information to send to everyone"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для отправки уведомлений.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'notification')
        
        await update.message.reply_text(
            "📢 <b>Отправка уведомления всем</b>\n\n"
            "Напиши уведомление, которое нужно отправить всем ученикам.\n"
            "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст уведомления.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_INFO
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_notification_details: {e}")
        return ConversationHandler.END

async def ask_sport_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a sport notification to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для отправки спортивных уведомлений.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'sport')
        
        await update.message.reply_text(
            "🏃 <b>Отправка спортивного уведомления</b>\n\n"
            "Напиши спортивное уведомление, которое нужно отправить всем ученикам.\n"
            "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст уведомления.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_SPORT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_sport_notification_details: {e}")
        return ConversationHandler.END

async def ask_suggestion_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a suggestion to improve the bot"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'suggestion')
        
        await update.message.reply_text(
            "💡 <b>Предложение по улучшению бота</b>\n\n"
            "Напиши свое предложение по улучшению бота:\n\n"
            "Что бы ты хотел добавить или изменить?\n"
            "Можно прикрепить фото/видео к сообщению. Отправь все медиафайлы, а затем текст предложения.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_suggestion_details: {e}")
        return ConversationHandler.END

async def ask_poll_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for poll details to create"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_create_polls(user_id):
            await update.message.reply_text("❌ У вас нет прав для создания опросов.")
            return ConversationHandler.END
        
        await update.message.reply_text(
            "📊 <b>Создание опроса</b>\n\n"
            "Напиши вопрос и варианты ответов в формате:\n"
            "<b>Вопрос</b>\n"
            "<b>Вариант 1</b>\n"
            "<b>Вариант 2</b>\n"
            "<b>Вариант 3</b>\n\n"
            "Пример:\n"
            "Какой предмет самый интересный?\n"
            "Математика\n"
            "Физика\n"
            "Информатика\n"
            "История",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
        )
        return AWAITING_POLL
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_poll_details: {e}")
        return ConversationHandler.END

# -------------------- MESSAGE HANDLING FUNCTIONS --------------------

async def handle_homework_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles homework input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_HOMEWORK
        
        if not can_send_homework(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'homework')
            homework_text = context.user_data.get('homework_text', '')
            
            if not homework_text and not media_collection:
                await update.message.reply_text("❌ Пожалуйста, добавь описание к ДЗ или медиафайлы.")
                return AWAITING_HOMEWORK
                
            if not homework_text:
                await update.message.reply_text("❌ Пожалуйста, добавь описание к ДЗ.")
                return AWAITING_HOMEWORK
                
            lines = homework_text.strip().split('\n')
            if len(lines) >= 3:
                subject = lines[0].strip()
                task = lines[1].strip()
                deadline = lines[2].strip()
                
                homework_id = add_homework(subject, task, deadline, group_name, user_id)
                
                if homework_id:
                    for media_item in media_collection:
                        add_homework_media(homework_id, media_item['type'], media_item['id'], media_item.get('caption'))
                    
                    await update.message.reply_text("✅ ДЗ добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                    await send_homework_to_all(context.bot, homework_id, subject, task, deadline, group_name, user_id)
                    
                    clear_media_collection(user_id, 'homework')
                    context.user_data.pop('homework_text', None)
                else:
                    await update.message.reply_text("❌ Ошибка при добавлении ДЗ.")
                
                await show_main_menu(update, user_id)
                return ConversationHandler.END
            else:
                await update.message.reply_text("❌ Неправильный формат. Нужно 3 строки: предмет, задание, срок")
                return AWAITING_HOMEWORK
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'homework', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        elif update.message.video:
            add_to_media_collection(user_id, 'homework', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        elif update.message.document:
            add_to_media_collection(user_id, 'homework', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        
        if text and text.strip():
            context.user_data['homework_text'] = text
            await update.message.reply_text("✅ Текст ДЗ сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        
        await update.message.reply_text("❌ Пожалуйста, добавь описание к ДЗ.")
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_homework_input: {e}")
        return AWAITING_HOMEWORK

async def handle_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_INFO
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'notification')
            notification_text = context.user_data.get('notification_text', '')
            
            if not notification_text:
                await update.message.reply_text("❌ Пожалуйста, добавь текст уведомления.")
                return AWAITING_INFO

            notification_id = add_notification(notification_text, group_name, user_id)
            
            if notification_id:
                for media_item in media_collection:
                    add_notification_media(notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("✅ Уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                await send_notification_to_all(context.bot, notification_id, notification_text, group_name, user_id)
                
                clear_media_collection(user_id, 'notification')
                context.user_data.pop('notification_text', None)
            else:
                await update.message.reply_text("❌ Ошибка при добавлении уведомления.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'notification', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        elif update.message.video:
            add_to_media_collection(user_id, 'notification', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        elif update.message.document:
            add_to_media_collection(user_id, 'notification', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        
        if text and text.strip():
            context.user_data['notification_text'] = text
            await update.message.reply_text("✅ Текст уведомления сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        
        await update.message.reply_text("❌ Пожалуйста, добавь текст уведомления.")
        return AWAITING_INFO
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_notification_input: {e}")
        return AWAITING_INFO

async def handle_sport_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles sport notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SPORT
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']

        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'sport')
            sport_text = context.user_data.get('sport_text', '')
            
            if not sport_text:
                await update.message.reply_text("❌ Пожалуйста, добавь текст спортивного уведомления.")
                return AWAITING_SPORT
        
            sport_notification_id = add_sport_notification(sport_text, group_name, user_id)
            
            if sport_notification_id:
                for media_item in media_collection:
                    add_sport_notification_media(sport_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("✅ Спортивное уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                await send_sport_notification_to_all(context.bot, sport_notification_id, sport_text, group_name, user_id)
                
                clear_media_collection(user_id, 'sport')
                context.user_data.pop('sport_text', None)
            else:
                await update.message.reply_text("❌ Ошибка при добавлении спортивного уведомления.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'sport', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        elif update.message.video:
            add_to_media_collection(user_id, 'sport', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        elif update.message.document:
            add_to_media_collection(user_id, 'sport', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        
        if text and text.strip():
            context.user_data['sport_text'] = text
            await update.message.reply_text("✅ Текст спортивного уведомления сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        
        await update.message.reply_text("❌ Пожалуйста, добавь текст спортивного уведомления.")
        return AWAITING_SPORT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_sport_input: {e}")
        return AWAITING_SPORT

async def handle_suggestion_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles suggestion input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'suggestion')
            suggestion_text = context.user_data.get('suggestion_text', '')
            
            if not suggestion_text:
                await update.message.reply_text("❌ Пожалуйста, напиши свое предложение.")
                return AWAITING_SUGGESTION

            suggestion_id = add_suggestion(user_id, suggestion_text)
            
            if suggestion_id:
                for media_item in media_collection:
                    add_suggestion_media(suggestion_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            # Отправляем уведомление пользователям с правами управления
            special_users = [u for u in get_all_users() if can_delete_suggestions(u['user_id'])]
            
            for special_user in special_users:
                try:
                    if media_collection:
                        for media_item in media_collection:
                            if media_item['type'] == 'photo':
                                await context.bot.send_photo(
                                    chat_id=special_user['user_id'],
                                    photo=media_item['id'],
                                    caption=f"💡 Новое предложение от {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                            elif media_item['type'] == 'video':
                                await context.bot.send_video(
                                    chat_id=special_user['user_id'],
                                    video=media_item['id'],
                                    caption=f"💡 Новое предложение от {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                            elif media_item['type'] == 'document':
                                await context.bot.send_document(
                                    chat_id=special_user['user_id'],
                                    document=media_item['id'],
                                    caption=f"💡 Новое предложение от {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                                    ])
                                )
                    else:
                        await context.bot.send_message(
                            special_user['user_id'],
                            f"💡 Новое предложение от {user_data['first_name']} (@{user_data['username']}):\n\n{suggestion_text}",
                            reply_markup=InlineKeyboardMarkup([
                                [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                            ])
                        )
                except Exception as e:
                    print(f"Не удалось отправить предложение пользователю {special_user['user_id']}: {e}")
            
            await update.message.reply_text("✅ Спасибо за предложение! Мы его рассмотрим.", reply_markup=ReplyKeyboardRemove())
            
            clear_media_collection(user_id, 'suggestion')
            context.user_data.pop('suggestion_text', None)
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        elif update.message.video:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        elif update.message.document:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        
        if text and text.strip():
            context.user_data['suggestion_text'] = text
            await update.message.reply_text("✅ Текст предложения сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        
        await update.message.reply_text("❌ Пожалуйста, напиши свое предложение.")
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_suggestion_input: {e}")
        return AWAITING_SUGGESTION

async def handle_poll_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles poll input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_POLL
        
        if not can_create_polls(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        text = update.message.text

        if text == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if not text:
            await update.message.reply_text("❌ Пожалуйста, напиши вопрос и варианты ответов.")
            return AWAITING_POLL

        lines = text.strip().split('\n')
        if len(lines) < 3:
            await update.message.reply_text("❌ Нужно как минимум: вопрос и 2 варианта ответа.")
            return AWAITING_POLL
        
        question = lines[0].strip()
        options = [line.strip() for line in lines[1:] if line.strip()]
        
        users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
        
        for user in users:
            try:
                message = await context.bot.send_poll(
                    chat_id=user['user_id'],
                    question=question,
                    options=options,
                    is_anonymous=False,
                    allows_multiple_answers=False
                )
                add_poll(question, options, group_name, user_id, message.message_id)
            except Exception as e:
                print(f"ОШИБКА: Не удалось отправить опрос пользователю {user['user_id']}: {e}")
        
        await update.message.reply_text("✅ Опрос создан и отправлен!", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_poll_input: {e}")
        return AWAITING_POLL

# -------------------- NOTIFICATION SENDING FUNCTIONS --------------------

async def send_homework_to_all(bot, homework_id, subject, task, deadline, group_name, added_by):
    """Sends homework to all users in a group"""
    homework_text = (
        f"📝 <b>НОВОЕ ДОМАШНЕЕ ЗАДАНИЕ</b>\n\n"
        f"📚 <b>Предмет:</b> {subject}\n"
        f"📋 <b>Задание:</b> {task}\n"
        f"⏰ <b>Срок сдачи:</b> {deadline}\n"
        f"👥 <b>Группа:</b> {group_name}\n"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (homework_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=homework_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=homework_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=homework_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=homework_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], homework_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить ДЗ пользователю {user['user_id']}: {e}")

async def send_notification_to_all(bot, notification_id, message, group_name, added_by):
    """Sends a notification to all users in a group"""
    notification_text = (f"📢 <b>ВАЖНОЕ УВЕДОМЛЕНИЕ</b>\n\n{message}\n\n👥 <b>Группа:</b> {group_name}")
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=notification_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=notification_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=notification_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=notification_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")

async def send_sport_notification_to_all(bot, sport_notification_id, message, group_name, added_by):
    """Sends a sport notification to all users in a group"""
    sport_text = (f"🏃 <b>СПОРТИВНОЕ УВЕДОМЛЕНИЕ</b>\n\n{message}\n\n👥 <b>Группа:</b> {group_name}")
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()

    for user in users:
        try:
            if media:
                if len(media) > 1:
                    media_group = []
                    for i, media_item in enumerate(media):
                        media_dict = dict(media_item)
                        if media_dict['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_dict['media_id'],
                                caption=sport_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_dict['media_id'],
                                caption=sport_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_dict['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_dict['media_id'],
                                caption=sport_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                else:
                    media_item = dict(media[0])
                    if media_item['media_type'] == 'photo':
                        await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=sport_text, parse_mode='HTML')
            else:
                await bot.send_message(user['user_id'], sport_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить спортивное уведомление пользователю {user['user_id']}: {e}")

# -------------------- INFO DISPLAY FUNCTIONS --------------------

async def show_homework(update: Update, group_name: str):
    """Shows all homework for a group"""
    try:
        homeworks = get_homeworks(group_name)
        if not homeworks:
            await update.message.reply_text("📭 Пока нет домашних заданий")
            return
        
        for hw in homeworks:
            hw_text = (
                f"📝 <b>Домашнее задание</b>\n"
                f"📚 <b>Предмет:</b> {hw['subject']}\n"
                f"📋 <b>Задание:</b> {hw['task']}\n"
                f"⏰ <b>Срок:</b> {hw['deadline']}\n"
                f"👤 <b>Добавил:</b> {hw['first_name']}\n"
                f"📅 <b>Дата:</b> {datetime.fromisoformat(hw['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if hw['media']:
                if len(hw['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(hw['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = hw['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=hw_text, parse_mode='HTML')
            else:
                await update.message.reply_text(hw_text, parse_mode='HTML')
        
        await update.message.reply_text(f"📊 <b>Показано:</b> {len(homeworks)} заданий", parse_mode='HTML')
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_homework: {e}")

async def show_information(update: Update, group_name: str, role: str):
    """Shows information for the user"""
    try:
        user_count = get_total_user_count()
        info_text = f"📊 <b>Пользователей в боте:</b> {user_count}\n\n<b>Контакты:</b>\n"
        for data in SPECIAL_USERS.values():
            info_text += f"- <b>{data['name']}</b>: {data['username']}\n"
        await update.message.reply_text(info_text, parse_mode='HTML')

        notifications = get_notifications(group_name)
        sport_notifications = get_sport_notifications(group_name)
        if not notifications and not sport_notifications:
            await update.message.reply_text("📭 Пока нет уведомлений")
            return
        
        if notifications:
            await update.message.reply_text("📢 <b>Важные уведомления:</b>", parse_mode='HTML')
            for notif in notifications[:2]:
                notif_text = f"{notif['message']}\n\n👤 <b>От:</b> {notif['first_name']} | 📅 {datetime.fromisoformat(notif['created_at']).strftime('%d.%m.%Y')}"
                
                if notif['media']:
                    if len(notif['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(notif['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = notif['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=notif_text)
                else:
                    await update.message.reply_text(notif_text)
        
        if sport_notifications:
            await update.message.reply_text("🏃 <b>Спортивные уведомления:</b>", parse_mode='HTML')
            for sport in sport_notifications[:2]:
                sport_text = f"{sport['message']}\n\n👤 <b>От:</b> {sport['first_name']} | 📅 {datetime.fromisoformat(sport['created_at']).strftime('%d.%m.%Y')}"
                
                if sport['media']:
                    if len(sport['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(sport['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = sport['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=sport_text)
                else:
                    await update.message.reply_text(sport_text)
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_information: {e}")

async def show_suggestions(update: Update):
    """Shows suggestions from students"""
    try:
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("📭 Пока нет предложений от учеников")
            return
        
        for s in suggestions[:5]:
            username = f"@{s['username']}" if s['username'] else s['first_name']
            suggestion_text = (
                f"💡 <b>Предложение от {username}</b>\n\n"
                f"{s['message']}\n\n"
                f"📅 {datetime.fromisoformat(s['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if s['responses']:
                suggestion_text += "\n\n<b>Ответы:</b>\n"
                for response in s['responses']:
                    responder_name = f"@{response['username']}" if response['username'] else response['first_name']
                    suggestion_text += f"👤 {responder_name}: {response['message']}\n"
            
            if s['media']:
                if len(s['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(s['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = s['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
            else:
                await update.message.reply_text(suggestion_text, parse_mode='HTML')
                
            if not s['responses']:
                await update.message.reply_text(
                    "💬 Ответить на предложение:",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{s['id']}")]
                    ])
                )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_suggestions: {e}")

async def show_users_list(update: Update):
    """Shows a list of all users for the developer"""
    try:
        users = get_all_users()
        if not users:
            await update.message.reply_text("❌ В базе данных нет пользователей.")
            return
        
        user_list_text = "👥 <b>Список пользователей</b>\n\n"
        
        for user in users:
            username = user['username'] if user['username'] else "Нет юзернейма"
            role_display = user['custom_role_name'] if user['custom_role_name'] else user['role']
            group_display = user['group_name'] if user['group_name'] else "Не указана"
            
            user_list_text += (
                f"<b>Имя:</b> {user['first_name']}\n"
                f"<b>Группа:</b> {group_display}\n"
                f"<b>Роль:</b> {role_display}\n"
                f"<b>Юзер:</b> @{username}\n"
                f"<b>ID:</b> <code>{user['user_id']}</code>\n\n"
            )
        
        # Разбиваем сообщение на части если оно слишком длинное
        if len(user_list_text) > 4000:
            parts = []
            current_part = ""
            lines = user_list_text.split('\n\n')
            
            for line in lines:
                if len(current_part + line + '\n\n') > 4000:
                    parts.append(current_part)
                    current_part = line + '\n\n'
                else:
                    current_part += line + '\n\n'
            
            if current_part:
                parts.append(current_part)
            
            for i, part in enumerate(parts):
                await update.message.reply_text(
                    f"{part}\n<b>Часть {i+1}/{len(parts)}</b>", 
                    parse_mode='HTML'
                )
        else:
            await update.message.reply_text(user_list_text, parse_mode='HTML')
            
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_users_list: {e}")
        await update.message.reply_text("❌ Произошла ошибка при загрузке списка пользователей.")

async def show_call_schedule(update: Update):
    """Shows the call schedule"""
    try:
        now = datetime.now(YEKATERINBURG_TZ)
        day_of_week = now.weekday()
        
        if day_of_week == 5:
            schedule_text = (
                "🔔 **Расписание звонков на субботу**\n\n"
                "1 пара: **8:30 - 9:45**\n"
                "Перемена: 10 минут\n"
                "2 пара: **9:55 - 11:10**\n"
                "Перемена: 10 минут\n"
                "3 пара: **11:20 - 12:40**\n"
                "Перемена: 40 минут - ОБЕД\n"
                "4 пара: **13:20 - 14:35**\n"
                "Перемена: 10 минут\n"
                "5 пара: **14:45 - 16:00**\n"
                "Перемена: 10 минут\n"
                "6 пара: **16:10 - 17:25**\n"
            )
        else:
            schedule_text = (
                "🔔 **Расписание звонков (понедельник-пятница)**\n\n"
                "1 пара: **8:30 - 10:05**\n"
                "Перемена: 10 минут\n"
                "2 пара: **10:15 - 11:50**\n"
                "Перемена: 10 минут\n"
                "3 пара: **12:40 - 14:15**\n"
                "Перемена: 40 минут - ОБЕД\n"
                "4 пара: **14:25 - 16:00**\n"
                "Перемена: 10 минут\n"
                "5 пара: **16:10 - 17:45**\n"
                "Перемена: 10 минут\n"
                "6 пара: **17:55 - 19:30**\n"
            )
        
        await update.message.reply_text(schedule_text, parse_mode='Markdown')
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_call_schedule: {e}")

async def contact_physical_organizer(update: Update):
    """Contact the physical organizer"""
    try:
        username = next((data['username'] for data in SPECIAL_USERS.values() if data['role'] == ROLE_PHYSICAL_ORGANIZER), None)
        if username:
            await update.message.reply_text(f"🏃 <b>Связь с Физ. оргом</b>\n\n📞 Telegram: {username}", parse_mode='HTML')
        else:
            await update.message.reply_text("❌ Физ. орг. не найден")
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_physical_organizer: {e}")

async def contact_starosta(update: Update):
    """Contact the староста"""
    try:
        username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == 'Староста'), None)
        if username:
            await update.message.reply_text(f"👑 <b>Связь со старостой</b>\n\n📞 Telegram: {username}", parse_mode='HTML')
        else:
            await update.message.reply_text("❌ Староста не найден")
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_starosta: {e}")

async def contact_deputy_starosta(update: Update):
    """Contact the зам старосты"""
    try:
        username = next((data['username'] for data in SPECIAL_USERS.values() if data['name'] == 'Зам Старосты (Разработчик)'), None)
        if username:
            await update.message.reply_text(f"👑 <b>Связь с замом старосты (разработчиком)</b>\n\n📞 Telegram: {username}", parse_mode='HTML')
        else:
            await update.message.reply_text("❌ Зам старосты не найден")
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_deputy_starosta: {e}")

# -------------------- DELETION FUNCTIONS --------------------

async def delete_homework_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows homework deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_homework(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        homeworks = get_homeworks(user_data['group_name'])
        if not homeworks:
            await update.message.reply_text("📝 Нет домашних заданий для удаления.")
            return ConversationHandler.END
        
        keyboard = [[InlineKeyboardButton(f"❌ {hw['subject']} | {hw['deadline']}", callback_data=f"del_hw_{hw['id']}")] for hw in homeworks[:5]]
        await update.message.reply_text("Выберите ДЗ для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_HOMEWORK_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_homework_menu: {e}")
        return ConversationHandler.END

async def delete_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        user_data = get_user(user_id)
        notifications = get_notifications(user_data['group_name'])
        sport_notifications = get_sport_notifications(user_data['group_name'])
        
        if not notifications and not sport_notifications:
            await update.message.reply_text("📢 Нет уведомлений для удаления.")
            return ConversationHandler.END

        keyboard = []
        for n in notifications[:5]:
            button_text = f"📢 {n['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_notif_{n['id']}")])
        
        for s in sport_notifications[:5]:
            button_text = f"🏃 {s['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{s['id']}")])

        await update.message.reply_text("Выберите уведомление для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_INFO_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_notification_menu: {e}")
        return ConversationHandler.END

async def delete_sport_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows sport notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_sport_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        if user_id == DEVELOPER_ID:
            sport_notifications = get_all_sport_notifications()
        else:
            sport_notifications = get_sport_notifications(user_data['group_name'])

        if not sport_notifications:
            await update.message.reply_text("🏃 Нет спортивных уведомлений для удаления.")
            return ConversationHandler.END

        keyboard = []
        for sport in sport_notifications[:10]:
            button_text = f"🏃 {sport['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{sport['id']}")])

        await update.message.reply_text("Выберите спортивное уведомление для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SPORT_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_sport_notification_menu: {e}")
        return ConversationHandler.END

async def delete_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows user deletion menu"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        users = [u for u in get_all_users() if u['user_id'] not in SPECIAL_USERS]
        if not users:
            await update.message.reply_text("👥 Нет пользователей для удаления.")
            return ConversationHandler.END
            
        keyboard = [[InlineKeyboardButton(f"❌ {u['first_name']} (@{u['username']}) - Группа: {u['group_name']} - ID: {u['user_id']}", callback_data=f"del_user_{u['user_id']}")] for u in users]
        await update.message.reply_text("Выберите пользователя для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_USER_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_user_menu: {e}")
        return ConversationHandler.END

async def delete_suggestions_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows suggestions deletion menu"""
    try:
        user_id = update.effective_user.id
        if not can_delete_suggestions(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("💡 Нет предложений для удаления.")
            return ConversationHandler.END
        
        keyboard = [[InlineKeyboardButton(f"❌ {s['message'][:20]}...", callback_data=f"del_sugg_{s['id']}")] for s in suggestions[:5]]
        await update.message.reply_text("Выберите предложение для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SUGGESTION_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_suggestions_menu: {e}")
        return ConversationHandler.END

async def handle_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles deletion callbacks"""
    try:
        query = update.callback_query
        await query.answer()

        parts = query.data.split('_')
        data_type = parts[1]
        item_id = int(parts[2])
        
        message = "❌ Произошла ошибка."
        try:
            if data_type == 'hw':
                delete_homework(item_id)
                message = "✅ Домашнее задание успешно удалено."
            elif data_type == 'notif':
                delete_notification(item_id)
                message = "✅ Уведомление успешно удалено."
            elif data_type == 'sport':
                delete_sport_notification(item_id)
                message = "✅ Спортивное уведомление успешно удалено."
            elif data_type == 'user':
                delete_user(item_id)
                message = "✅ Пользователь успешно удален."
            elif data_type == 'sugg':
                delete_suggestion(item_id)
                message = "✅ Предложение успешно удалено."
            
            await query.edit_message_text(text=message)
        except Exception as e:
            await query.edit_message_text(text=f"❌ Ошибка при удалении: {e}")
        
        await show_main_menu(update, query.from_user.id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_delete_callback: {e}")
        return ConversationHandler.END

# -------------------- SUGGESTION RESPONSE FUNCTION --------------------

async def handle_suggestion_response_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response callback"""
    try:
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split('_')
        suggestion_id = int(parts[1])
        
        context.user_data['responding_to_suggestion'] = suggestion_id
        
        await query.edit_message_text(
            "💬 <b>Ответ на предложение</b>\n\nНапиши свой ответ:",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
        )
        
        return AWAITING_SUGGESTION_RESPONSE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_suggestion_response_callback: {e}")
        return ConversationHandler.END

async def handle_suggestion_response_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION_RESPONSE
        
        text = update.message.text
        
        if text == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if not text:
            await update.message.reply_text("❌ Пожалуйста, напиши ответ.")
            return AWAITING_SUGGESTION_RESPONSE
        
        suggestion_id = context.user_data.get('responding_to_suggestion')
        
        if not suggestion_id:
            await update.message.reply_text("❌ Ошибка: предложение не найдено.")
            return await cancel_conversation(update, context)
        
        conn = get_db_connection()
        suggestion = conn.execute('SELECT * FROM suggestions WHERE id = ?', (suggestion_id,)).fetchone()
        conn.close()
        
        if not suggestion:
            await update.message.reply_text("❌ Ошибка: предложение не найдено.")
            return await cancel_conversation(update, context)
        
        add_suggestion_response(suggestion_id, user_id, text)
        
        try:
            responder_name = user_data['first_name']
            if user_data['username']:
                responder_name = f"@{user_data['username']}"
            
            response_text = (
                f"💬 <b>Ответ на ваше предложение</b>\n\n"
                f"👤 <b>От:</b> {responder_name}\n"
                f"💡 <b>Ваше предложение:</b> {suggestion['message'][:100]}...\n\n"
                f"📝 <b>Ответ:</b> {text}"
            )
            
            await context.bot.send_message(
                chat_id=suggestion['user_id'],
                text=response_text,
                parse_mode='HTML'
            )
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить ответ автору предложения: {e}")
        
        await update.message.reply_text("✅ Ответ отправлен!", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_suggestion_response_input: {e}")
        return AWAITING_SUGGESTION_RESPONSE

# -------------------- POLL HANDLER --------------------

async def handle_poll_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles poll answers"""
    pass

# -------------------- ROLE FIX FUNCTION --------------------

async def handle_role_fix_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the role fix callback"""
    try:
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split('_')
        user_id = int(parts[2])
        
        if query.from_user.id != user_id:
            await query.edit_message_text("❌ Вы не можете исправить роль другого пользователя.")
            return
        
        user = query.from_user
        add_user(user_id, user.username, user.first_name, user.last_name)
        
        await query.edit_message_text("✅ Ваша роль была обновлена! Теперь у вас должны быть все права.")
        await show_main_menu(update, user_id)
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_role_fix_callback: {e}")

# -------------------- SPECIAL USER MANAGEMENT FUNCTIONS --------------------

async def add_special_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows menu for adding special users"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
        
        await update.message.reply_text(
            "👑 <b>Добавление специального пользователя</b>\n\n"
            "Введите ID пользователя, которого хотите добавить:",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
        )
        return AWAITING_ADD_SPECIAL_USER
    except Exception as e:
        print(f"ОШИБКА: Ошибка в add_special_user_menu: {e}")
        return ConversationHandler.END

async def handle_special_user_id_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles special user ID input"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)
        
        text = update.message.text.strip()
        
        if text == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        try:
            target_user_id = int(text)
            
            if target_user_id == user_id:
                await update.message.reply_text("❌ Нельзя изменять свои собственные права!")
                return await cancel_conversation(update, context)
            
            # Проверяем, существует ли пользователь
            try:
                user = await context.bot.get_chat(target_user_id)
                context.user_data['special_user_data'] = {
                    'user_id': target_user_id,
                    'username': user.username,
                    'first_name': user.first_name,
                    'last_name': user.last_name
                }
                
                # Выбор группы
                keyboard = [ALL_GROUPS[i:i+3] for i in range(0, len(ALL_GROUPS), 3)]
                keyboard.append(['❌ Отмена'])
                await update.message.reply_text(
                    f"👤 Пользователь: {user.first_name} (@{user.username})\n\n"
                    "Выберите группу для пользователя:",
                    reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
                )
                return AWAITING_GROUP
            except Exception as e:
                await update.message.reply_text("❌ Пользователь с таким ID не найден или бот не может получить информацию о нем.")
                return await cancel_conversation(update, context)
                
        except ValueError:
            await update.message.reply_text("❌ Неверный формат ID. Введите числовой ID пользователя.")
            return AWAITING_ADD_SPECIAL_USER
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_special_user_id_input: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def handle_special_user_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles group selection for special user"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)
        
        group_name = update.message.text
        
        if group_name == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if group_name not in ALL_GROUPS:
            await update.message.reply_text("❌ Пожалуйста, выберите группу из списка.")
            return AWAITING_GROUP
        
        context.user_data['special_user_data']['group_name'] = group_name
        
        # Выбор типа роли
        keyboard = [
            ['👑 Староста', '👑 Зам старосты'],
            ['🏃 Физ. орг.', '🔧 Другое'],
            ['❌ Отмена']
        ]
        await update.message.reply_text(
            "Выберите тип роли для пользователя:",
            reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        )
        return AWAITING_ADD_SPECIAL_USER
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_special_user_group_selection: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def handle_special_user_role_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles role selection for special user"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)
        
        role_type = update.message.text
        
        if role_type == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        user_data = context.user_data['special_user_data']
        
        if role_type == '👑 Староста':
            role_key = 'starosta'
            custom_name = 'Староста'
        elif role_type == '👑 Зам старосты':
            role_key = 'deputy_starosta'
            custom_name = 'Зам Старосты'
        elif role_type == '🏃 Физ. орг.':
            role_key = 'physical_organizer'
            custom_name = 'Физ. орг.'
        elif role_type == '🔧 Другое':
            await update.message.reply_text(
                "Введите название пользовательской роли:",
                reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
            )
            return AWAITING_ADD_SPECIAL_USER
        else:
            await update.message.reply_text("❌ Пожалуйста, выберите тип роли из списка.")
            return AWAITING_ADD_SPECIAL_USER
        
        # Добавляем пользователя
        if add_special_user(
            user_data['user_id'],
            user_data['username'],
            user_data['first_name'],
            user_data['last_name'],
            user_data['group_name'],
            role_key,
            custom_name
        ):
            await update.message.reply_text(
                f"✅ Пользователь {user_data['first_name']} успешно добавлен как {custom_name} в группу {user_data['group_name']}!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text(
                "❌ Ошибка при добавлении пользователя.",
                reply_markup=ReplyKeyboardRemove()
            )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_special_user_role_selection: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def handle_custom_role_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles custom role name input"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)
        
        custom_name = update.message.text.strip()
        
        if custom_name == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        user_data = context.user_data['special_user_data']
        
        # Добавляем пользователя с кастомной ролью
        if add_special_user(
            user_data['user_id'],
            user_data['username'],
            user_data['first_name'],
            user_data['last_name'],
            user_data['group_name'],
            'custom',
            custom_name
        ):
            await update.message.reply_text(
                f"✅ Пользователь {user_data['first_name']} успешно добавлен как {custom_name} в группу {user_data['group_name']}!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text(
                "❌ Ошибка при добавлении пользователя.",
                reply_markup=ReplyKeyboardRemove()
            )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_custom_role_name: {e}")
        return AWAITING_ADD_SPECIAL_USER

async def manage_user_rights_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows menu for managing user rights"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
        
        users = get_all_users()
        if not users:
            await update.message.reply_text("❌ В базе данных нет пользователей.")
            return ConversationHandler.END
        
        keyboard = []
        for user in users:
            if user['user_id'] == user_id:
                continue
                
            role_display = user['custom_role_name'] if user['custom_role_name'] else user['role']
            button_text = f"{user['first_name']} (@{user['username']}) - {role_display}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"manage_rights_{user['user_id']}")])
        
        await update.message.reply_text(
            "👥 <b>Управление правами пользователей</b>\n\n"
            "Выберите пользователя для изменения прав:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"ОШИБКА: Ошибка в manage_user_rights_menu: {e}")
        return ConversationHandler.END

async def handle_user_rights_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user selection for rights management"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID:
            await query.edit_message_text("❌ У вас нет прав для этого действия.")
            return
        
        parts = query.data.split('_')
        target_user_id = int(parts[2])
        
        if target_user_id == user_id:
            await query.edit_message_text("❌ Нельзя изменять свои собственные права!")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("❌ Пользователь не найден.")
            return
        
        context.user_data['managing_user_id'] = target_user_id
        
        # Создаем клавиатуру с текущими правами
        keyboard = [
            [InlineKeyboardButton(f"{'✅' if target_user['can_send_homework'] else '❌'} Отправка ДЗ", callback_data=f"toggle_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_send_notifications'] else '❌'} Отправка уведомлений", callback_data=f"toggle_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_send_sport_notifications'] else '❌'} Спортивные уведомления", callback_data=f"toggle_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_homework'] else '❌'} Удаление ДЗ", callback_data=f"toggle_del_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_notifications'] else '❌'} Удаление уведомлений", callback_data=f"toggle_del_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_sport_notifications'] else '❌'} Удаление спортивных", callback_data=f"toggle_del_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_suggestions'] else '❌'} Удаление предложений", callback_data=f"toggle_del_suggestions_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_create_polls'] else '❌'} Создание опросов", callback_data=f"toggle_polls_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_manage_users'] else '❌'} Управление пользователями", callback_data=f"toggle_manage_users_{target_user_id}")],
            [InlineKeyboardButton("🔙 Назад к списку", callback_data="back_to_users_list")],
            [InlineKeyboardButton("❌ Сбросить все права", callback_data=f"reset_rights_{target_user_id}")],
            [InlineKeyboardButton("✅ Сохранить и выйти", callback_data="save_rights")]
        ]
        
        role_display = target_user['custom_role_name'] if target_user['custom_role_name'] else target_user['role']
        
        await query.edit_message_text(
            f"👤 <b>Управление правами пользователя</b>\n\n"
            f"<b>Имя:</b> {target_user['first_name']}\n"
            f"<b>Юзернейм:</b> @{target_user['username']}\n"
            f"<b>Группа:</b> {target_user['group_name']}\n"
            f"<b>Роль:</b> {role_display}\n\n"
            f"<b>Текущие права:</b>\n"
            f"Нажмите на право для его изменения:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_user_rights_selection: {e}")
        return AWAITING_USER_RIGHTS

async def handle_rights_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles rights toggling"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID:
            await query.edit_message_text("❌ У вас нет прав для этого действия.")
            return
        
        if query.data == "back_to_users_list":
            return await manage_user_rights_menu(update, context)
        
        if query.data == "save_rights":
            await query.edit_message_text("✅ Права сохранены!")
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        parts = query.data.split('_')
        
        # Обработка разных форматов callback_data
        if len(parts) == 3:
            # Старый формат: toggle_action_targetUserId
            action = parts[1]
            target_user_id = int(parts[2])
        elif len(parts) == 4:
            # Новый формат: toggle_del_type_targetUserId
            action = parts[1]
            sub_action = parts[2]
            target_user_id = int(parts[3])
            
            # Объединяем action и sub_action для обработки
            if action == "del":
                action = f"del_{sub_action}"
            elif action == "manage" and sub_action == "users":
                action = "manage_users"
        else:
            await query.edit_message_text("❌ Неверный формат данных.")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("❌ Пользователь не найден.")
            return
        
        # Обновляем права
        rights_data = {
            'can_send_homework': target_user['can_send_homework'],
            'can_send_notifications': target_user['can_send_notifications'],
            'can_send_sport_notifications': target_user['can_send_sport_notifications'],
            'can_delete_homework': target_user['can_delete_homework'],
            'can_delete_notifications': target_user['can_delete_notifications'],
            'can_delete_sport_notifications': target_user['can_delete_sport_notifications'],
            'can_delete_suggestions': target_user['can_delete_suggestions'],
            'can_create_polls': target_user['can_create_polls'],
            'can_manage_users': target_user['can_manage_users'],
            'role': target_user['role'],
            'custom_role_name': target_user['custom_role_name']
        }
        
        if action == "reset":
            # Сброс всех прав
            for key in rights_data:
                if key.startswith('can_'):
                    rights_data[key] = 0
            rights_data['role'] = ROLE_STUDENT
            rights_data['custom_role_name'] = None
        else:
            # Переключаем конкретное право
            if action == "homework":
                rights_data['can_send_homework'] = 1 - rights_data['can_send_homework']
            elif action == "notifications":
                rights_data['can_send_notifications'] = 1 - rights_data['can_send_notifications']
            elif action == "sport":
                rights_data['can_send_sport_notifications'] = 1 - rights_data['can_send_sport_notifications']
            elif action == "del_homework":
                rights_data['can_delete_homework'] = 1 - rights_data['can_delete_homework']
            elif action == "del_notifications":
                rights_data['can_delete_notifications'] = 1 - rights_data['can_delete_notifications']
            elif action == "del_sport":
                rights_data['can_delete_sport_notifications'] = 1 - rights_data['can_delete_sport_notifications']
            elif action == "del_suggestions":
                rights_data['can_delete_suggestions'] = 1 - rights_data['can_delete_suggestions']
            elif action == "polls":
                rights_data['can_create_polls'] = 1 - rights_data['can_create_polls']
            elif action == "manage_users":
                rights_data['can_manage_users'] = 1 - rights_data['can_manage_users']
        
        if update_user_rights(target_user_id, rights_data):
            # Обновляем сообщение с новыми правами
            updated_user = get_user(target_user_id)
            
            keyboard = [
                [InlineKeyboardButton(f"{'✅' if updated_user['can_send_homework'] else '❌'} Отправка ДЗ", callback_data=f"toggle_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_send_notifications'] else '❌'} Отправка уведомлений", callback_data=f"toggle_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_send_sport_notifications'] else '❌'} Спортивные уведомления", callback_data=f"toggle_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_homework'] else '❌'} Удаление ДЗ", callback_data=f"toggle_del_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_notifications'] else '❌'} Удаление уведомлений", callback_data=f"toggle_del_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_sport_notifications'] else '❌'} Удаление спортивных", callback_data=f"toggle_del_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_suggestions'] else '❌'} Удаление предложений", callback_data=f"toggle_del_suggestions_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_create_polls'] else '❌'} Создание опросов", callback_data=f"toggle_polls_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_manage_users'] else '❌'} Управление пользователями", callback_data=f"toggle_manage_users_{target_user_id}")],
                [InlineKeyboardButton("🔙 Назад к списку", callback_data="back_to_users_list")],
                [InlineKeyboardButton("❌ Сбросить все права", callback_data=f"reset_rights_{target_user_id}")],
                [InlineKeyboardButton("✅ Сохранить и выйти", callback_data="save_rights")]
            ]
            
            role_display = updated_user['custom_role_name'] if updated_user['custom_role_name'] else updated_user['role']
            
            await query.edit_message_text(
                f"👤 <b>Управление правами пользователя</b>\n\n"
                f"<b>Имя:</b> {updated_user['first_name']}\n"
                f"<b>Юзернейм:</b> @{updated_user['username']}\n"
                f"<b>Группа:</b> {updated_user['group_name']}\n"
                f"<b>Роль:</b> {role_display}\n"
                f"<b>ID:</b> <code>{updated_user['user_id']}</code>\n\n"
                f"<b>Текущие права:</b>\n"
                f"Нажмите на право для его изменения:",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await query.edit_message_text("❌ Ошибка при обновлении прав.")
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_rights_toggle: {e}")
        await query.edit_message_text("❌ Произошла ошибка при обновлении прав.")

# -------------------- JOB QUEUE FUNCTIONS --------------------

async def init_schedule_cache(application):
    """Initializes the schedule cache and groups list"""
    try:
        global schedule_cache, last_schedule_check
        schedule_data = fetch_schedule_data()
        if schedule_data:
            schedule_cache = schedule_data
            last_schedule_check = datetime.now(YEKATERINBURG_TZ)
            print("ЛОГ: Кэш расписания инициализирован")
        
        # Initialize groups list
        fetch_groups_list()
        print("ЛОГ: Список групп инициализирован")
    except Exception as e:
        print(f"ОШИБКА: Ошибка при инициализации кэша расписания: {e}")

# -------------------- MAIN FUNCTION --------------------

def main():
    """Main function to run the bot"""
    try:
        init_db()
        
        app = Application.builder().token(BOT_TOKEN).post_init(init_schedule_cache).build()
        
        job_queue = app.job_queue
        job_queue.run_repeating(check_schedule_changes, interval=3600, first=10)
        job_queue.run_daily(send_daily_schedule, time=time(hour=19, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(send_morning_schedule, time=time(hour=7, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(check_birthdays, time=time(hour=0, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        
        conv_handler = ConversationHandler(
            entry_points=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^📢 Отправить ДЗ$'), ask_homework_details),
                MessageHandler(filters.Regex('^📢 Отправить уведомление$'), ask_notification_details),
                MessageHandler(filters.Regex('^🏃 Отправить спортивное уведомление$'), ask_sport_notification_details),
                MessageHandler(filters.Regex('^💡 Предложить идею$'), ask_suggestion_details),
                MessageHandler(filters.Regex('^Удалить ДЗ$'), delete_homework_menu),
                MessageHandler(filters.Regex('^Удалить уведомление$'), delete_notification_menu),
                MessageHandler(filters.Regex('^Удалить спортивные уведомления$'), delete_sport_notification_menu),
                MessageHandler(filters.Regex('^Удалить предложения$'), delete_suggestions_menu),
                MessageHandler(filters.Regex('^Удалить пользователя$'), delete_user_menu),
                MessageHandler(filters.Regex('^🎓 Сменить группу$'), ask_user_group),
                MessageHandler(filters.Regex('^📊 Создать опрос$'), ask_poll_details),
                MessageHandler(filters.Regex('^🎂 Установить день рождения$'), ask_birthday_date),
                MessageHandler(filters.Regex('^🌍 Отправить всем группам$'), ask_global_notification_details),
                MessageHandler(filters.Regex('^👑 Добавить спец пользователя$'), add_special_user_menu),
                MessageHandler(filters.Regex('^🔧 Управление правами$'), manage_user_rights_menu),
            ],
            states={
                AWAITING_GROUP: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_group_selection),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_special_user_group_selection)
                ],
                AWAITING_HOMEWORK: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_homework_input)],
                AWAITING_INFO: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_notification_input)],
                AWAITING_SPORT: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_sport_input)],
                AWAITING_SUGGESTION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_suggestion_input)],
                AWAITING_POLL: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_poll_input)],
                AWAITING_SUGGESTION_RESPONSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_suggestion_response_input)],
                AWAITING_BIRTHDAY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_birthday_input)],
                AWAITING_GLOBAL_NOTIFICATION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_global_notification_input)],
                AWAITING_ADD_SPECIAL_USER: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_special_user_id_input),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_special_user_role_selection),
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_custom_role_name)
                ],
                AWAITING_USER_RIGHTS: [CallbackQueryHandler(handle_user_rights_selection, pattern='^manage_rights_')],
                AWAITING_HOMEWORK_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_hw_')],
                AWAITING_INFO_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_notif_')],
                AWAITING_SPORT_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sport_')],
                AWAITING_USER_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_user_')],
                AWAITING_SUGGESTION_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sugg_')]
            },
            fallbacks=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^❌ Отмена$'), cancel_conversation)
            ],
            allow_reentry=True
        )
        
        app.add_handler(conv_handler)
        app.add_handler(CallbackQueryHandler(handle_role_fix_callback, pattern='^fix_role_'))
        app.add_handler(CallbackQueryHandler(handle_suggestion_response_callback, pattern='^respond_'))
        app.add_handler(CallbackQueryHandler(handle_rights_toggle, pattern='^(toggle_|reset_|back_|save_)'))
        app.add_handler(PollHandler(handle_poll_answer))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_simple_message))
        
        print("ЛОГ: Бот запущен!")
        app.run_polling()
        
    except Exception as e:
        print(f"КРИТИЧЕСКАЯ ОШИБКА: {e}")

if __name__ == "__main__":
    main()
