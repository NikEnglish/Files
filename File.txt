import sqlite3
import re
import json
import asyncio
import requests
import os
import io
import csv
from datetime import datetime, timedelta, timezone, time
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto, InputMediaVideo, InputMediaDocument
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler
from telegram.constants import ParseMode

# -------------------- CONSTANTS AND SETTINGS --------------------
BOT_TOKEN = "7405848829:AAHxDv0DP_Co512vOvGw_PDsXYDjE4fgOJ0"
YEKATERINBURG_TZ = timezone(timedelta(hours=5))
DEFAULT_GROUP = None

# States for ConversationHandler - УВЕЛИЧИВАЕМ КОЛИЧЕСТВО СОСТОЯНИЙ
AWAITING_HOMEWORK, AWAITING_INFO, AWAITING_SPORT, AWAITING_SUGGESTION, AWAITING_HOMEWORK_DELETE, AWAITING_INFO_DELETE, AWAITING_SPORT_DELETE, AWAITING_USER_DELETE, AWAITING_SUGGESTION_DELETE, AWAITING_GROUP, AWAITING_SUGGESTION_RESPONSE, AWAITING_BIRTHDAY, AWAITING_GLOBAL_NOTIFICATION, AWAITING_ADD_SPECIAL_USER, AWAITING_USER_RIGHTS, AWAITING_ROLE_ASSIGNMENT, AWAITING_NOTIFICATION_SETTINGS, AWAITING_CUSTOM_ROLE, AWAITING_EVENT, AWAITING_EVENT_BUTTONS = range(20)

# User Roles
ROLE_STUDENT = 'student'
ROLE_STAROSTA = 'starosta'
ROLE_DEPUTY_STAROSTA = 'deputy_starosta'
ROLE_PHYSICAL_ORGANIZER = 'physical_organizer'
ROLE_DEPUTY_PHYSICAL_ORGANIZER = 'deputy_physical_organizer'
ROLE_DEVELOPER = 'developer'
ROLE_CUSTOM = 'custom'

# Special Users (только разработчик)
DEVELOPER_ID = 1775957387

# Dynamic list of groups (will be populated from API)
ALL_GROUPS = []

# Schedule cache
schedule_cache = {}
last_schedule_check = None
groups_cache = []
last_groups_check = None

# Spam protection
user_message_times = {}
user_warnings = {}
user_blocks = {}
SPAM_THRESHOLD = 10
SPAM_WINDOW = 5
BLOCK_DURATIONS = [600, 1800, 3600, 7200, 36000, 180000]

# Media collection for multiple media support
user_media_collections = {}

# -------------------- UPDATED CALL SCHEDULES --------------------

# Regular schedule (Monday-Friday)
REGULAR_CALL_SCHEDULE = [
    {"type": "lesson", "number": 1, "part": 1, "start": "8:30", "end": "9:15"},
    {"type": "break", "start": "9:15", "end": "9:20", "duration": 5},
    {"type": "lesson", "number": 1, "part": 2, "start": "9:20", "end": "10:05"},
    {"type": "break", "start": "10:05", "end": "10:15", "duration": 10},
    {"type": "lesson", "number": 2, "part": 1, "start": "10:15", "end": "11:00"},
    {"type": "break", "start": "11:00", "end": "11:05", "duration": 5},
    {"type": "lesson", "number": 2, "part": 2, "start": "11:05", "end": "11:50"},
    {"type": "break", "start": "11:50", "end": "12:40", "duration": 50},
    {"type": "lesson", "number": 3, "part": 1, "start": "12:40", "end": "13:25"},
    {"type": "break", "start": "13:25", "end": "13:30", "duration": 5},
    {"type": "lesson", "number": 3, "part": 2, "start": "13:30", "end": "14:15"},
    {"type": "break", "start": "14:15", "end": "14:25", "duration": 10},
    {"type": "lesson", "number": 4, "part": 1, "start": "14:25", "end": "15:10"},
    {"type": "break", "start": "15:10", "end": "15:15", "duration": 5},
    {"type": "lesson", "number": 4, "part": 2, "start": "15:15", "end": "16:00"},
    {"type": "break", "start": "16:00", "end": "16:10", "duration": 10},
    {"type": "lesson", "number": 5, "part": 1, "start": "16:10", "end": "16:55"},
    {"type": "break", "start": "16:55", "end": "17:00", "duration": 5},
    {"type": "lesson", "number": 5, "part": 2, "start": "17:00", "end": "17:45"},
    {"type": "break", "start": "17:45", "end": "17:55", "duration": 10},
    {"type": "lesson", "number": 6, "part": 1, "start": "17:55", "end": "18:40"},
    {"type": "break", "start": "18:40", "end": "18:45", "duration": 5},
    {"type": "lesson", "number": 6, "part": 2, "start": "18:45", "end": "19:30"}
]

# Saturday schedule
SATURDAY_CALL_SCHEDULE = {
    1: {"start": "8:30", "end": "9:45"},
    "break1": {"start": "9:45", "end": "9:55", "duration": 10},
    2: {"start": "9:55", "end": "11:10"},
    "break2": {"start": "11:10", "end": "11:20", "duration": 10},
    3: {"start": "11:20", "end": "12:40"},
    "break3": {"start": "12:40", "end": "13:20", "duration": 40},
    4: {"start": "13:20", "end": "14:35"},
    "break4": {"start": "14:35", "end": "14:45", "duration": 10},
    5: {"start": "14:45", "end": "16:00"},
    "break5": {"start": "16:00", "end": "16:10", "duration": 10},
    6: {"start": "16:10", "end": "17:25"}
}

# Short day schedule
SHORT_DAY_CALL_SCHEDULE = {
    1: {"start": "8:30", "end": "9:30"},
    "break1": {"start": "9:30", "end": "9:40", "duration": 10},
    2: {"start": "9:40", "end": "10:40"},
    "break2": {"start": "10:40", "end": "10:50", "duration": 10},
    3: {"start": "10:50", "end": "11:50"},
    "break3": {"start": "11:50", "end": "12:30", "duration": 40},
    4: {"start": "12:30", "end": "13:30"},
    "break4": {"start": "13:30", "end": "13:40", "duration": 10},
    5: {"start": "13:40", "end": "14:40"},
    "break5": {"start": "14:40", "end": "14:50", "duration": 10},
    6: {"start": "14:50", "end": "15:50"}
}

# -------------------- DATABASE FUNCTIONS --------------------

def init_db():
    """Initializes the database with proper error handling"""
    conn = None
    try:
        conn = sqlite3.connect('bot_data.db')
        cur = conn.cursor()
        
        # Users table with all required columns
        cur.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            group_name TEXT,
            role TEXT DEFAULT 'student',
            custom_role_name TEXT,
            can_send_homework BOOLEAN DEFAULT 0,
            can_send_notifications BOOLEAN DEFAULT 0,
            can_send_sport_notifications BOOLEAN DEFAULT 0,
            can_send_global_notifications BOOLEAN DEFAULT 0,
            can_delete_homework BOOLEAN DEFAULT 0,
            can_delete_notifications BOOLEAN DEFAULT 0,
            can_delete_sport_notifications BOOLEAN DEFAULT 0,
            can_delete_suggestions BOOLEAN DEFAULT 0,
            can_manage_users BOOLEAN DEFAULT 0,
            can_create_events BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )''')
        
        # Group roles table - роли для каждой группы
        cur.execute('''CREATE TABLE IF NOT EXISTS group_roles (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            group_name TEXT NOT NULL,
            role_type TEXT NOT NULL,
            user_id INTEGER,
            username TEXT,
            first_name TEXT,
            assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(group_name, role_type),
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE SET NULL
        )''')
        
        # User notification settings table
        cur.execute('''CREATE TABLE IF NOT EXISTS user_notification_settings (
            user_id INTEGER PRIMARY KEY,
            lesson_start BOOLEAN DEFAULT 1,
            new_homework BOOLEAN DEFAULT 1,
            important_notifications BOOLEAN DEFAULT 1,
            sport_notifications BOOLEAN DEFAULT 1,
            tomorrow_schedule BOOLEAN DEFAULT 1,
            today_schedule BOOLEAN DEFAULT 1,
            birthday_notifications BOOLEAN DEFAULT 1,
            own_birthday_notifications BOOLEAN DEFAULT 1,
            event_notifications BOOLEAN DEFAULT 1,
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE
        )''')
        
        # Homeworks table
        cur.execute('''CREATE TABLE IF NOT EXISTS homeworks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            subject TEXT,
            task TEXT,
            deadline TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Homework media table
        cur.execute('''CREATE TABLE IF NOT EXISTS homework_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            homework_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (homework_id) REFERENCES homeworks (id) ON DELETE CASCADE
        )''')
        
        # Notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (notification_id) REFERENCES notifications (id) ON DELETE CASCADE
        )''')
        
        # Sport notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            group_name TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Sport notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS sport_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sport_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (sport_notification_id) REFERENCES sport_notifications (id) ON DELETE CASCADE
        )''')
        
        # Suggestions table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id)
        )''')
        
        # Suggestion media table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id) ON DELETE CASCADE
        )''')
        
        # Suggestion responses table
        cur.execute('''CREATE TABLE IF NOT EXISTS suggestion_responses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            suggestion_id INTEGER,
            responder_id INTEGER,
            message TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (suggestion_id) REFERENCES suggestions (id),
            FOREIGN KEY (responder_id) REFERENCES users (user_id)
        )''')
        
        # Birthdays table
        cur.execute('''CREATE TABLE IF NOT EXISTS birthdays (
            user_id INTEGER PRIMARY KEY,
            birthday_date TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE
        )''')
        
        # Global notifications table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notifications (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            message TEXT,
            added_by INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Global notification media table
        cur.execute('''CREATE TABLE IF NOT EXISTS global_notification_media (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            global_notification_id INTEGER,
            media_type TEXT,
            media_id TEXT,
            caption TEXT,
            FOREIGN KEY (global_notification_id) REFERENCES global_notifications (id) ON DELETE CASCADE
        )''')
        
        # Events table
        cur.execute('''CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_name TEXT,
            event_date TEXT,
            event_description TEXT,
            group_name TEXT,
            added_by INTEGER,
            has_buttons BOOLEAN DEFAULT 0,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (added_by) REFERENCES users (user_id)
        )''')
        
        # Event buttons table
        cur.execute('''CREATE TABLE IF NOT EXISTS event_buttons (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_id INTEGER,
            button_text TEXT,
            FOREIGN KEY (event_id) REFERENCES events (id) ON DELETE CASCADE
        )''')
        
        # Event responses table
        cur.execute('''CREATE TABLE IF NOT EXISTS event_responses (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            event_id INTEGER,
            user_id INTEGER,
            button_id INTEGER,
            response_text TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (event_id) REFERENCES events (id),
            FOREIGN KEY (user_id) REFERENCES users (user_id),
            FOREIGN KEY (button_id) REFERENCES event_buttons (id)
        )''')
        
        conn.commit()
        print("ЛОГ: База данных инициализирована.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при инициализации: {e}")
    finally:
        if conn:
            conn.close()

def get_db_connection():
    """Creates a connection to the database"""
    try:
        conn = sqlite3.connect('bot_data.db')
        conn.row_factory = sqlite3.Row
        return conn
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при подключении: {e}")
        return None

def get_user(user_id):
    """Gets user information"""
    conn = get_db_connection()
    if not conn: return None
    try:
        user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        return user
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения пользователя: {e}")
        return None
    finally:
        conn.close()

def get_user_notification_settings(user_id):
    """Gets user notification settings"""
    conn = get_db_connection()
    if not conn: return None
    try:
        settings = conn.execute('SELECT * FROM user_notification_settings WHERE user_id = ?', (user_id,)).fetchone()
        if not settings:
            # Create default settings if not exist
            conn.execute('''INSERT INTO user_notification_settings 
                         (user_id, lesson_start, new_homework, important_notifications, sport_notifications, 
                         tomorrow_schedule, today_schedule, birthday_notifications, own_birthday_notifications, event_notifications) 
                         VALUES (?, 1, 1, 1, 1, 1, 1, 1, 1, 1)''', (user_id,))
            conn.commit()
            settings = conn.execute('SELECT * FROM user_notification_settings WHERE user_id = ?', (user_id,)).fetchone()
        
        # Преобразуем Row в словарь для безопасного доступа
        if settings:
            return dict(settings)
        return None
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения настроек уведомлений: {e}")
        return None
    finally:
        conn.close()

def update_user_notification_settings(user_id, setting_name, value):
    """Updates user notification settings"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute(f'UPDATE user_notification_settings SET {setting_name} = ? WHERE user_id = ?', (value, user_id))
        conn.commit()
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при обновлении настроек уведомлений: {e}")
        return False
    finally:
        conn.close()

def get_all_users():
    """Gets a list of all users"""
    conn = get_db_connection()
    if not conn: return []
    try:
        users = conn.execute('SELECT user_id, first_name, username, group_name, role, custom_role_name FROM users').fetchall()
        return users
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения списка пользователей: {e}")
        return []
    finally:
        conn.close()

def add_user(user_id, username, first_name, last_name):
    """Adds a new user to the database or updates existing user"""
    conn = get_db_connection()
    if not conn: return
    try:
        existing_user = conn.execute('SELECT * FROM users WHERE user_id = ?', (user_id,)).fetchone()
        
        role = ROLE_STUDENT
        
        # Проверяем разработчика
        if user_id == DEVELOPER_ID:
            role = ROLE_DEVELOPER
        
        if not existing_user:
            conn.execute('''INSERT INTO users (user_id, username, first_name, last_name, role)
                         VALUES (?, ?, ?, ?, ?)''',
                         (user_id, username, first_name, last_name, role))
            # Add default notification settings
            conn.execute('''INSERT INTO user_notification_settings 
                         (user_id, lesson_start, new_homework, important_notifications, sport_notifications, 
                         tomorrow_schedule, today_schedule, birthday_notifications, own_birthday_notifications, event_notifications) 
                         VALUES (?, 1, 1, 1, 1, 1, 1, 1, 1, 1)''', (user_id,))
            print(f"ЛОГ: Добавлен новый пользователь: {first_name} (ID: {user_id}) с ролью {role}")
        else:
            conn.execute('''UPDATE users 
                         SET username = ?, first_name = ?, last_name = ?
                         WHERE user_id = ?''',
                         (username, first_name, last_name, user_id))
            print(f"ЛОГ: Обновлен пользователь: {first_name} (ID: {user_id})")
        
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении пользователя: {e}")
    finally:
        conn.close()

def update_user_rights(user_id, rights_data):
    """Updates user rights in the database"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''UPDATE users SET
                     can_send_homework = ?,
                     can_send_notifications = ?,
                     can_send_sport_notifications = ?,
                     can_send_global_notifications = ?,
                     can_delete_homework = ?,
                     can_delete_notifications = ?,
                     can_delete_sport_notifications = ?,
                     can_delete_suggestions = ?,
                     can_manage_users = ?,
                     can_create_events = ?,
                     role = ?,
                     custom_role_name = ?
                     WHERE user_id = ?''',
                     (rights_data.get('can_send_homework', 0),
                      rights_data.get('can_send_notifications', 0),
                      rights_data.get('can_send_sport_notifications', 0),
                      rights_data.get('can_send_global_notifications', 0),
                      rights_data.get('can_delete_homework', 0),
                      rights_data.get('can_delete_notifications', 0),
                      rights_data.get('can_delete_sport_notifications', 0),
                      rights_data.get('can_delete_suggestions', 0),
                      rights_data.get('can_manage_users', 0),
                      rights_data.get('can_create_events', 0),
                      rights_data.get('role', ROLE_STUDENT),
                      rights_data.get('custom_role_name', None),
                      user_id))
        conn.commit()
        print(f"ЛОГ: Обновлены права пользователя {user_id}")
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при обновлении прав: {e}")
        return False
    finally:
        conn.close()

def update_user_group(user_id, group_name):
    """Updates the user's group"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('UPDATE users SET group_name = ? WHERE user_id = ?', (group_name, user_id))
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} сменил группу на {group_name}")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при обновлении группы: {e}")
    finally:
        conn.close()

def set_user_birthday(user_id, birthday_date):
    """Sets or updates user's birthday"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('''INSERT OR REPLACE INTO birthdays (user_id, birthday_date)
                     VALUES (?, ?)''', (user_id, birthday_date))
        conn.commit()
        print(f"ЛОГ: Установлен день рождения для пользователя {user_id}: {birthday_date}")
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при установке дня рождения: {e}")
        return False
    finally:
        conn.close()

def get_user_birthday(user_id):
    """Gets user's birthday"""
    conn = get_db_connection()
    if not conn: return None
    try:
        result = conn.execute('SELECT birthday_date FROM birthdays WHERE user_id = ?', (user_id,)).fetchone()
        return result['birthday_date'] if result else None
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения дня рождения: {e}")
        return None
    finally:
        conn.close()

def get_today_birthdays():
    """Gets all users who have birthday today"""
    conn = get_db_connection()
    if not conn: return []
    try:
        today = datetime.now().strftime('%d.%m')
        birthdays = conn.execute('''SELECT u.user_id, u.first_name, u.username, u.group_name, b.birthday_date 
                                 FROM users u JOIN birthdays b ON u.user_id = b.user_id 
                                 WHERE b.birthday_date LIKE ? AND u.group_name IS NOT NULL''', (f'{today}%',)).fetchall()
        return birthdays
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения дней рождений: {e}")
        return []
    finally:
        conn.close()

def get_total_user_count():
    """Gets the total number of users in the database"""
    conn = get_db_connection()
    if not conn: return 0
    try:
        count = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
        return count
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при подсчете пользователей: {e}")
        return 0
    finally:
        conn.close()

def delete_homework(hw_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM homeworks WHERE id = ?', (hw_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении ДЗ: {e}")
    finally:
        conn.close()

def delete_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении уведомления: {e}")
    finally:
        conn.close()

def delete_sport_notification(notif_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM sport_notifications WHERE id = ?', (notif_id,))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении спортивного уведомления: {e}")
    finally:
        conn.close()

def delete_user(user_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} удален из базы данных.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении пользователя: {e}")
    finally:
        conn.close()

def delete_suggestion(suggestion_id):
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('DELETE FROM suggestions WHERE id = ?', (suggestion_id,))
        conn.commit()
        print(f"ЛОГ: Предложение {suggestion_id} удалено из базы данных.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении предложения: {e}")
    finally:
        conn.close()

def get_all_sport_notifications():
    """Gets all sport notifications"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     ORDER BY s.created_at DESC''').fetchall()
        return notifications
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения спортивных уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_homework(subject, task, deadline, group_name, added_by):
    """Adds homework to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO homeworks (subject, task, deadline, group_name, added_by)
                     VALUES (?, ?, ?, ?, ?)''', (subject, task, deadline, group_name, added_by))
        homework_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено ДЗ для группы {group_name}.")
        return homework_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении ДЗ: {e}")
        return None
    finally:
        conn.close()

def add_homework_media(homework_id, media_type, media_id, caption=None):
    """Adds media to homework"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO homework_media (homework_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (homework_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к ДЗ: {e}")
    finally:
        conn.close()

def get_homeworks(group_name):
    """Gets homework for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        homeworks = conn.execute('''SELECT h.*, u.first_name 
                                 FROM homeworks h JOIN users u ON h.added_by = u.user_id 
                                 WHERE h.group_name = ? ORDER BY h.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for hw in homeworks:
            hw_dict = dict(hw)
            media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (hw_dict['id'],)).fetchall()
            hw_dict['media'] = [dict(m) for m in media]
            result.append(hw_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения ДЗ: {e}")
        return []
    finally:
        conn.close()

def add_notification(message, group_name, added_by):
    """Adds a notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        notification_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено уведомление для группы {group_name}.")
        return notification_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении уведомления: {e}")
        return None
    finally:
        conn.close()

def add_notification_media(notification_id, media_type, media_id, caption=None):
    """Adds media to notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO notification_media (notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к уведомлению: {e}")
    finally:
        conn.close()

def get_notifications(group_name):
    """Gets notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT n.*, u.first_name 
                                     FROM notifications n JOIN users u ON n.added_by = u.user_id 
                                     WHERE n.group_name = ? ORDER BY n.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for notif in notifications:
            notif_dict = dict(notif)
            media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notif_dict['id'],)).fetchall()
            notif_dict['media'] = [dict(m) for m in media]
            result.append(notif_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_sport_notification(message, group_name, added_by):
    """Adds a sport notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO sport_notifications (message, group_name, added_by)
                     VALUES (?, ?, ?)''', (message, group_name, added_by))
        sport_notification_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено спортивное уведомление для группы {group_name}.")
        return sport_notification_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении спортивного уведомления: {e}")
        return None
    finally:
        conn.close()

def add_sport_notification_media(sport_notification_id, media_type, media_id, caption=None):
    """Adds media to sport notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO sport_notification_media (sport_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (sport_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к спортивному уведомлению: {e}")
    finally:
        conn.close()

def get_sport_notifications(group_name):
    """Gets sport notifications for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        notifications = conn.execute('''SELECT s.*, u.first_name 
                                     FROM sport_notifications s JOIN users u ON s.added_by = u.user_id 
                                     WHERE s.group_name = ? ORDER BY s.created_at DESC''', (group_name,)).fetchall()
        
        result = []
        for sport in notifications:
            sport_dict = dict(sport)
            media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_dict['id'],)).fetchall()
            sport_dict['media'] = [dict(m) for m in media]
            result.append(sport_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения спортивных уведомлений: {e}")
        return []
    finally:
        conn.close()

def add_suggestion(user_id, message):
    """Adds a suggestion to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO suggestions (user_id, message) VALUES (?, ?)', (user_id, message))
        suggestion_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Пользователь {user_id} отправил предложение.")
        return suggestion_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении предложения: {e}")
        return None
    finally:
        conn.close()

def add_suggestion_media(suggestion_id, media_type, media_id, caption=None):
    """Adds media to suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_media (suggestion_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (suggestion_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к предложению: {e}")
    finally:
        conn.close()

def add_suggestion_response(suggestion_id, responder_id, message):
    """Adds a response to a suggestion"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO suggestion_responses (suggestion_id, responder_id, message)
                     VALUES (?, ?, ?)''', (suggestion_id, responder_id, message))
        conn.commit()
        print(f"ЛОГ: Добавлен ответ на предложение {suggestion_id}.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении ответа на предложение: {e}")
    finally:
        conn.close()

def get_suggestions():
    """Gets all suggestions"""
    conn = get_db_connection()
    if not conn: return []
    try:
        suggestions = conn.execute('''SELECT s.*, u.first_name, u.username 
                                   FROM suggestions s JOIN users u ON s.user_id = u.user_id 
                                   ORDER BY s.created_at DESC''').fetchall()
        
        result = []
        for s in suggestions:
            s_dict = dict(s)
            media = conn.execute('SELECT * FROM suggestion_media WHERE suggestion_id = ?', (s_dict['id'],)).fetchall()
            s_dict['media'] = [dict(m) for m in media]
            
            responses = conn.execute('''SELECT sr.*, u.first_name, u.username 
                                    FROM suggestion_responses sr JOIN users u ON sr.responder_id = u.user_id 
                                    WHERE sr.suggestion_id = ? ORDER BY sr.created_at''', (s_dict['id'],)).fetchall()
            s_dict['responses'] = [dict(r) for r in responses]
            
            result.append(s_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения предложений: {e}")
        return []
    finally:
        conn.close()

def add_global_notification(message, added_by):
    """Adds a global notification to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO global_notifications (message, added_by) VALUES (?, ?)', (message, added_by))
        global_notification_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено глобальное уведомление.")
        return global_notification_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении глобального уведомления: {e}")
        return None
    finally:
        conn.close()

def add_global_notification_media(global_notification_id, media_type, media_id, caption=None):
    """Adds media to global notification"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO global_notification_media (global_notification_id, media_type, media_id, caption)
                     VALUES (?, ?, ?, ?)''', (global_notification_id, media_type, media_id, caption))
        conn.commit()
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении медиа к глобальному уведомлению: {e}")
    finally:
        conn.close()

# -------------------- EVENT FUNCTIONS --------------------

def add_event(event_name, event_date, event_description, group_name, added_by, has_buttons=False):
    """Adds an event to the database"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('''INSERT INTO events (event_name, event_date, event_description, group_name, added_by, has_buttons)
                     VALUES (?, ?, ?, ?, ?, ?)''', (event_name, event_date, event_description, group_name, added_by, has_buttons))
        event_id = cursor.lastrowid
        conn.commit()
        print(f"ЛОГ: Добавлено событие для группы {group_name}.")
        return event_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении события: {e}")
        return None
    finally:
        conn.close()

def add_event_button(event_id, button_text):
    """Adds a button to an event"""
    conn = get_db_connection()
    if not conn: return None
    try:
        cursor = conn.execute('INSERT INTO event_buttons (event_id, button_text) VALUES (?, ?)', (event_id, button_text))
        button_id = cursor.lastrowid
        conn.commit()
        return button_id
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении кнопки события: {e}")
        return None
    finally:
        conn.close()

def add_event_response(event_id, user_id, button_id, response_text):
    """Adds a response to an event"""
    conn = get_db_connection()
    if not conn: return
    try:
        conn.execute('''INSERT INTO event_responses (event_id, user_id, button_id, response_text)
                     VALUES (?, ?, ?, ?)''', (event_id, user_id, button_id, response_text))
        conn.commit()
        print(f"ЛОГ: Добавлен ответ на событие {event_id}.")
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при добавлении ответа на событие: {e}")
    finally:
        conn.close()

def get_event_buttons(event_id):
    """Gets buttons for an event"""
    conn = get_db_connection()
    if not conn: return []
    try:
        buttons = conn.execute('SELECT * FROM event_buttons WHERE event_id = ?', (event_id,)).fetchall()
        return buttons
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения кнопок события: {e}")
        return []
    finally:
        conn.close()

def get_events(group_name):
    """Gets events for a group"""
    conn = get_db_connection()
    if not conn: return []
    try:
        events = conn.execute('''SELECT e.*, u.first_name 
                              FROM events e JOIN users u ON e.added_by = u.user_id 
                              WHERE e.group_name = ? ORDER BY e.event_date ASC''', (group_name,)).fetchall()
        
        result = []
        for event in events:
            event_dict = dict(event)
            buttons = get_event_buttons(event_dict['id'])
            event_dict['buttons'] = [dict(b) for b in buttons]
            result.append(event_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения событий: {e}")
        return []
    finally:
        conn.close()

def get_all_events():
    """Gets all events"""
    conn = get_db_connection()
    if not conn: return []
    try:
        events = conn.execute('''SELECT e.*, u.first_name 
                              FROM events e JOIN users u ON e.added_by = u.user_id 
                              ORDER BY e.event_date ASC''').fetchall()
        
        result = []
        for event in events:
            event_dict = dict(event)
            buttons = get_event_buttons(event_dict['id'])
            event_dict['buttons'] = [dict(b) for b in buttons]
            result.append(event_dict)
        
        return result
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения всех событий: {e}")
        return []
    finally:
        conn.close()

def get_event_responses(event_id):
    """Gets responses for an event"""
    conn = get_db_connection()
    if not conn: return []
    try:
        responses = conn.execute('''SELECT er.*, u.first_name, u.username, eb.button_text
                                 FROM event_responses er 
                                 JOIN users u ON er.user_id = u.user_id 
                                 JOIN event_buttons eb ON er.button_id = eb.id
                                 WHERE er.event_id = ?''', (event_id,)).fetchall()
        return responses
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получения ответов события: {e}")
        return []
    finally:
        conn.close()

# -------------------- GROUP ROLE FUNCTIONS --------------------

def get_group_role(group_name, role_type):
    """Gets the user with a specific role in a group"""
    conn = get_db_connection()
    if not conn: return None
    try:
        role = conn.execute('SELECT * FROM group_roles WHERE group_name = ? AND role_type = ?', (group_name, role_type)).fetchone()
        return role
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при получении роли группы: {e}")
        return None
    finally:
        conn.close()

def set_group_role(group_name, role_type, user_id, username, first_name):
    """Sets a role for a user in a group"""
    conn = get_db_connection()
    if not conn: return False
    try:
        # Удаляем существующую роль этого типа в группе
        conn.execute('DELETE FROM group_roles WHERE group_name = ? AND role_type = ?', (group_name, role_type))
        # Добавляем новую роль
        conn.execute('INSERT INTO group_roles (group_name, role_type, user_id, username, first_name) VALUES (?, ?, ?, ?, ?)',
                    (group_name, role_type, user_id, username, first_name))
        conn.commit()
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при установке роли группы: {e}")
        return False
    finally:
        conn.close()

def remove_group_role(group_name, role_type):
    """Removes a role from a group"""
    conn = get_db_connection()
    if not conn: return False
    try:
        conn.execute('DELETE FROM group_roles WHERE group_name = ? AND role_type = ?', (group_name, role_type))
        conn.commit()
        return True
    except sqlite3.Error as e:
        print(f"ОШИБКА: Ошибка базы данных при удалении роли группы: {e}")
        return False
    finally:
        conn.close()

# -------------------- SPAM PROTECTION --------------------

def check_spam(user_id):
    """Checks if user is spamming"""
    now = datetime.now().timestamp()
    
    if user_id in user_blocks and now < user_blocks[user_id]:
        return True, user_blocks[user_id] - now
    
    if user_id not in user_message_times:
        user_message_times[user_id] = []
        user_warnings[user_id] = 0
    
    user_message_times[user_id].append(now)
    user_message_times[user_id] = [t for t in user_message_times[user_id] if now - t < SPAM_WINDOW]
    
    if len(user_message_times[user_id]) >= SPAM_THRESHOLD:
        user_warnings[user_id] += 1
        warning_count = user_warnings[user_id]
        
        if warning_count - 1 < len(BLOCK_DURATIONS):
            block_duration = BLOCK_DURATIONS[warning_count - 1]
        else:
            block_duration = BLOCK_DURATIONS[-1]
        
        user_blocks[user_id] = now + block_duration
        user_message_times[user_id] = []
        return True, block_duration
    
    return False, 0

async def warn_user(update: Update, block_duration: int):
    """Warns user about spam"""
    minutes = block_duration // 60
    await update.message.reply_text(
        f"⚠️ Не спамьте! Подождите немного перед следующим сообщением.\n"
        f"Вы заблокированы на {minutes} минут."
    )

# -------------------- MEDIA COLLECTION FUNCTIONS --------------------

def init_user_media_collection(user_id):
    """Initializes media collection for a user"""
    if user_id not in user_media_collections:
        user_media_collections[user_id] = {
            'homework': [],
            'notification': [],
            'sport': [],
            'suggestion': [],
            'global_notification': [],
            'event': []
        }

def add_to_media_collection(user_id, media_type, media_data):
    """Adds media to user's collection"""
    init_user_media_collection(user_id)
    user_media_collections[user_id][media_type].append(media_data)

def clear_media_collection(user_id, media_type):
    """Clears user's media collection"""
    if user_id in user_media_collections:
        user_media_collections[user_id][media_type] = []

def get_media_collection(user_id, media_type):
    """Gets user's media collection"""
    init_user_media_collection(user_id)
    return user_media_collections[user_id][media_type]

# -------------------- USER RIGHTS CHECK FUNCTIONS --------------------

def can_send_homework(user_id, group_name=None):
    """Checks if user can send homework"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    if user['can_send_homework'] == 1:
        return True
    
    # Проверяем, является ли пользователь старостой своей группы
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_send_notifications(user_id, group_name=None):
    """Checks if user can send notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    if user['can_send_notifications'] == 1:
        return True
    
    # Проверяем, является ли пользователь старостой своей группы
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_send_sport_notifications(user_id, group_name=None):
    """Checks if user can send sport notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    if user['can_send_sport_notifications'] == 1:
        return True
    
    # Проверяем, является ли пользователь физоргом или замом физорга своей группы
    if group_name and user['group_name'] == group_name:
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        deputy_fizorg = get_group_role(group_name, ROLE_DEPUTY_PHYSICAL_ORGANIZER)
        if (fizorg and fizorg['user_id'] == user_id) or (deputy_fizorg and deputy_fizorg['user_id'] == user_id):
            return True
    
    return False

def can_send_global_notifications(user_id):
    """Checks if user can send global notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    return user['can_send_global_notifications'] == 1

def can_delete_homework(user_id, group_name=None):
    """Checks if user can delete homework"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    if user['can_delete_homework'] == 1:
        return True
    
    # Проверяем, является ли пользователь старостой своей группы
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_delete_notifications(user_id, group_name=None):
    """Checks if user can delete notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    if user['can_delete_notifications'] == 1:
        return True
    
    # Проверяем, является ли пользователь старостой своей группы
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return True
    
    return False

def can_delete_sport_notifications(user_id, group_name=None):
    """Checks if user can delete sport notifications"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    if user['can_delete_sport_notifications'] == 1:
        return True
    
    # Проверяем, является ли пользователь физоргом или замом физорга своей группы
    if group_name and user['group_name'] == group_name:
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        deputy_fizorg = get_group_role(group_name, ROLE_DEPUTY_PHYSICAL_ORGANIZER)
        if (fizorg and fizorg['user_id'] == user_id) or (deputy_fizorg and deputy_fizorg['user_id'] == user_id):
            return True
    
    return False

def can_delete_suggestions(user_id):
    """Checks if user can delete suggestions"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    return user_id == DEVELOPER_ID

def can_manage_users(user_id):
    """Checks if user can manage users"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    return user_id == DEVELOPER_ID

def can_create_events(user_id, group_name=None):
    """Checks if user can create events"""
    user = get_user(user_id)
    if not user: return False
    
    # Разработчик может всё
    if user_id == DEVELOPER_ID:
        return True
    
    # Проверяем права пользователя
    if user['can_create_events'] == 1:
        return True
    
    # Проверяем, является ли пользователь старостой или физоргом своей группы
    if group_name and user['group_name'] == group_name:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        deputy_starosta = get_group_role(group_name, ROLE_DEPUTY_STAROSTA)
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        deputy_fizorg = get_group_role(group_name, ROLE_DEPUTY_PHYSICAL_ORGANIZER)
        if (starosta and starosta['user_id'] == user_id) or (deputy_starosta and deputy_starosta['user_id'] == user_id) or (fizorg and fizorg['user_id'] == user_id) or (deputy_fizorg and deputy_fizorg['user_id'] == user_id):
            return True
    
    return False

def get_user_role_display(user_id):
    """Gets user role display name"""
    user = get_user(user_id)
    if not user: return "Студент"
    
    if user_id == DEVELOPER_ID:
        return "Разработчик"
    
    if user['custom_role_name']:
        return user['custom_role_name']
    
    # Проверяем роли в группах
    if user['group_name']:
        starosta = get_group_role(user['group_name'], ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            return "Староста"
        
        deputy = get_group_role(user['group_name'], ROLE_DEPUTY_STAROSTA)
        if deputy and deputy['user_id'] == user_id:
            return "Зам старосты"
        
        fizorg = get_group_role(user['group_name'], ROLE_PHYSICAL_ORGANIZER)
        if fizorg and fizorg['user_id'] == user_id:
            return "Физорг"
            
        deputy_fizorg = get_group_role(user['group_name'], ROLE_DEPUTY_PHYSICAL_ORGANIZER)
        if deputy_fizorg and deputy_fizorg['user_id'] == user_id:
            return "Зам физорга"
    
    role_map = {
        ROLE_STAROSTA: "Староста",
        ROLE_DEPUTY_STAROSTA: "Зам старосты",
        ROLE_PHYSICAL_ORGANIZER: "Физорг",
        ROLE_DEPUTY_PHYSICAL_ORGANIZER: "Зам физорга",
        ROLE_STUDENT: "Студент"
    }
    
    return role_map.get(user['role'], "Студент")

# -------------------- CONTACT FUNCTIONS --------------------

async def contact_developer(update: Update):
    """Contact the developer"""
    try:
        await update.message.reply_text(
            "👨‍💻 <b>Связь с разработчиком</b>\n\n"
            "📞 Telegram: @imya_polbzovatela\n"
            "💬 По всем вопросам работы бота обращайтесь к разработчику",
            parse_mode='HTML'
        )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_developer: {e}")

async def contact_starosta(update: Update, group_name: str):
    """Contact the starosta for specific group"""
    try:
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta:
            username = f"@{starosta['username']}" if starosta['username'] else starosta['first_name']
            await update.message.reply_text(
                f"👑 <b>Связь со старостой группы {group_name}</b>\n\n"
                f"👤 Имя: {starosta['first_name']}\n"
                f"📞 Telegram: {username}",
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                f"❌ Для группы {group_name} староста еще не назначен.\n"
                f"Обратитесь к разработчику для назначения старосты."
            )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_starosta: {e}")

async def contact_deputy_starosta(update: Update, group_name: str):
    """Contact the deputy starosta for specific group"""
    try:
        deputy = get_group_role(group_name, ROLE_DEPUTY_STAROSTA)
        if deputy:
            username = f"@{deputy['username']}" if deputy['username'] else deputy['first_name']
            await update.message.reply_text(
                f"👑 <b>Связь с замом старосты группы {group_name}</b>\n\n"
                f"👤 Имя: {deputy['first_name']}\n"
                f"📞 Telegram: {username}",
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                f"❌ Для группы {group_name} зам старосты еще не назначен.\n"
                f"Обратитесь к разработчику для назначения зама старосты."
            )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_deputy_starosta: {e}")

async def contact_physical_organizer(update: Update, group_name: str):
    """Contact the physical organizer for specific group"""
    try:
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        if fizorg:
            username = f"@{fizorg['username']}" if fizorg['username'] else fizorg['first_name']
            await update.message.reply_text(
                f"🏃 <b>Связь с физоргом группы {group_name}</b>\n\n"
                f"👤 Имя: {fizorg['first_name']}\n"
                f"📞 Telegram: {username}",
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                f"❌ Для группы {group_name} физорг еще не назначен.\n"
                f"Обратитесь к разработчику для назначения физорга."
            )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_physical_organizer: {e}")

async def contact_deputy_physical_organizer(update: Update, group_name: str):
    """Contact the deputy physical organizer for specific group"""
    try:
        deputy_fizorg = get_group_role(group_name, ROLE_DEPUTY_PHYSICAL_ORGANIZER)
        if deputy_fizorg:
            username = f"@{deputy_fizorg['username']}" if deputy_fizorg['username'] else deputy_fizorg['first_name']
            await update.message.reply_text(
                f"🏃 <b>Связь с замом физорга группы {group_name}</b>\n\n"
                f"👤 Имя: {deputy_fizorg['first_name']}\n"
                f"📞 Telegram: {username}",
                parse_mode='HTML'
            )
        else:
            await update.message.reply_text(
                f"❌ Для группы {group_name} зам физорга еще не назначен.\n"
                f"Обратитесь к разработчику для назначения зама физорга."
            )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в contact_deputy_physical_organizer: {e}")

# -------------------- UPDATED SCHEDULE FUNCTIONS --------------------

def fetch_schedule_data():
    """Fetches schedule data from the new API endpoint"""
    try:
        url = "https://ops.pmk-online.ru/schedule/request.php?token=Uf40-ZZkp-t5Nv-ZD5v"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        print("ЛОГ: Загрузка расписания с API...")
        resp = requests.get(url, headers=headers, timeout=15)
        resp.raise_for_status()
        data = resp.json()

        print(f"ЛОГ: Успешно загружено расписания. Занятий: {len(data)}")
        return data
    except requests.exceptions.RequestException as e:
        print(f"ОШИБКА: Ошибка сети при загрузке расписания: {e}")
        return None
    except Exception as e:
        print(f"ОШИБКА: Неизвестная ошибка при загрузке расписания: {e}")
        return None

def fetch_groups_list():
    """Fetches and updates the list of groups from schedule data"""
    global ALL_GROUPS, groups_cache, last_groups_check
    
    try:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return ALL_GROUPS
        
        # Extract unique groups from schedule data
        groups = set()
        for lesson in schedule_data:
            if 'group' in lesson:
                groups.add(lesson['group'])
        
        # Sort groups by course and number
        def group_sort_key(group_name):
            try:
                # Extract course number (first digit after dash)
                parts = group_name.split('-')
                if len(parts) > 1:
                    number_part = parts[1]
                    # Find first digit in number part
                    for char in number_part:
                        if char.isdigit():
                            course = int(char)
                            return (course, group_name)
            except:
                pass
            return (0, group_name)
        
        sorted_groups = sorted(groups, key=group_sort_key)
        ALL_GROUPS = sorted_groups
        groups_cache = sorted_groups
        last_groups_check = datetime.now(YEKATERINBURG_TZ)
        
        print(f"ЛОГ: Обновлен список групп. Всего групп: {len(ALL_GROUPS)}")
        return ALL_GROUPS
    except Exception as e:
        print(f"ОШИБКА: Ошибка при обновлении списка групп: {e}")
        return ALL_GROUPS

def parse_lesson_data(lesson):
    """Parses lesson data from the new API format"""
    try:
        if not isinstance(lesson, dict):
            return None
            
        lesson_data = {}
        
        # Basic lesson information
        lesson_data['group'] = lesson.get('group', 'Не указана')
        lesson_data['number'] = lesson.get('number', 0)
        lesson_data['type'] = lesson.get('type', 'Занятие')
        lesson_data['subject'] = lesson.get('subject', 'Не указано')
        lesson_data['campus'] = lesson.get('campus', 'Не указан')
        lesson_data['room'] = lesson.get('room', 'Не указана')
        lesson_data['teacher'] = lesson.get('teacher', 'Не указан')
        
        # Parse dates and convert to Yekaterinburg timezone
        start_time_str = lesson.get('startTime', '')
        end_time_str = lesson.get('endTime', '')
        
        if start_time_str:
            try:
                start_time_utc = datetime.fromisoformat(start_time_str.replace('Z', '+00:00'))
                start_time_yekat = start_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['date'] = start_time_yekat.strftime('%Y-%m-%d')
                lesson_data['start_time'] = start_time_yekat.strftime('%H:%M')
                lesson_data['datetime'] = start_time_yekat
            except:
                lesson_data['date'] = 'Не указана'
                lesson_data['start_time'] = 'Не указано'
        
        if end_time_str:
            try:
                end_time_utc = datetime.fromisoformat(end_time_str.replace('Z', '+00:00'))
                end_time_yekat = end_time_utc.astimezone(YEKATERINBURG_TZ)
                lesson_data['end_time'] = end_time_yekat.strftime('%H:%M')
            except:
                lesson_data['end_time'] = 'Не указано'
        
        return lesson_data
    except Exception as e:
        print(f"ОШИБКА: Не удалось распарсить данные занятия: {e}")
        return None

def filter_lessons_by_date(lessons, target_date):
    """Filters lessons for a specific date"""
    try:
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if lesson_date == target_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"ОШИБКА: Ошибка при фильтрации занятий: {e}")
        return []

def filter_lessons_by_week(lessons, start_date):
    """Filters lessons for a week starting from start_date"""
    try:
        end_date = start_date + timedelta(days=7)
        filtered = []
        
        for lesson in lessons:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if start_date <= lesson_date <= end_date:
                    filtered.append(parsed)
        
        return filtered
    except Exception as e:
        print(f"ОШИБКА: Ошибка при фильтрации занятий на неделю: {e}")
        return []

def get_type_emoji(lesson_type):
    """Returns emoji for lesson type"""
    emoji_map = {
        'Занятие': '📚',
        'Практика': '🔬', 
        'Лекция': '📖',
        'Экзамен': '📝',
        'Консультация': '💬',
        'Лабораторная работа': '⚗️',
        'Семинар': '💡',
        'Зачет': '✅'
    }
    return emoji_map.get(lesson_type, '📚')

def format_schedule(lessons, title):
    """Formats schedule for display with the new format"""
    try:
        if not lessons:
            return f"✅ Нет занятий для {title.split('(')[-1].split(')')[0]}"
        
        # Sort lessons by date and time
        lessons.sort(key=lambda x: (x.get('datetime', datetime.min), x.get('number', 0)))
        
        result = [f"<b>{title}</b>\n"]
        current_date = None
        
        for lesson in lessons:
            try:
                if 'datetime' in lesson:
                    date_str = lesson['datetime'].strftime('%d.%m.%Y')
                    day_names = ['Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье']
                    day_of_week = day_names[lesson['datetime'].weekday()]
                    
                    if date_str != current_date:
                        current_date = date_str
                        result.append(f"\n📅 <b>{date_str} ({day_of_week})</b>")
                    
                    type_emoji = get_type_emoji(lesson['type'])
                    start_time = lesson.get('start_time', '❓')
                    end_time = lesson.get('end_time', '❓')
                    
                    lesson_text = (
                        f"    {type_emoji} {lesson['type']}\n"
                        f"    ⏰ {start_time}-{end_time} | {lesson['number']} пара\n"
                        f"    📚 {lesson['subject']}\n"
                        f"    👨‍🏫 {lesson['teacher']}\n"
                        f"    🚪 {lesson['room']}({lesson['campus']})\n"
                    )
                    result.append(lesson_text)
            except Exception as e:
                print(f"ОШИБКА: Не удалось отформатировать пару: {e}")
                continue
        
        result.append(f"\n📊 <b>Всего занятий:</b> {len(lessons)}")
        return "\n".join(result)
    except Exception as e:
        print(f"ОШИБКА: Ошибка при форматировании расписания: {e}")
        return f"❌ Ошибка при формировании расписания: {str(e)}"

def get_schedule(period, group_name):
    """Gets and formats the schedule with the new API"""
    try:
        global schedule_cache, last_schedule_check
        
        # Check cache
        now = datetime.now(YEKATERINBURG_TZ)
        if last_schedule_check is None or (now - last_schedule_check).total_seconds() > 3600:
            print(f"ЛОГ: Обновляем кэш расписания для группы {group_name}")
            schedule_data = fetch_schedule_data()
            if schedule_data:
                schedule_cache = schedule_data
                last_schedule_check = now
                print("ЛОГ: Расписание обновлено из API")
            else:
                print("ЛОГ: Не удалось обновить расписание, используем кэш если есть")
        else:
            schedule_data = schedule_cache
            print("ЛОГ: Используем кэшированное расписание")
        
        if not schedule_data:
            return "❌ Не удалось загрузить расписание. Попробуйте позже."
        
        # Filter lessons for the specific group
        group_lessons = [lesson for lesson in schedule_data if lesson.get('group') == group_name]
        
        if not group_lessons:
            return f"❌ Нет расписания для группы {group_name}"
        
        # Filter lessons by period
        today_yekat = datetime.now(YEKATERINBURG_TZ).date()
        
        if period == '📅 Сегодня':
            filtered_lessons = filter_lessons_by_date(group_lessons, today_yekat)
            title = f"📅 Расписание на сегодня ({group_name})"
        elif period == '📅 Завтра':
            tomorrow_yekat = today_yekat + timedelta(days=1)
            filtered_lessons = filter_lessons_by_date(group_lessons, tomorrow_yekat)
            title = f"📅 Расписание на завтра ({group_name})"
        elif period == '📅 Неделя':
            filtered_lessons = filter_lessons_by_week(group_lessons, today_yekat)
            title = f"📅 Расписание на неделю ({group_name})"
        else:
            # For "Все расписание" parse all lessons
            filtered_lessons = []
            for lesson in group_lessons:
                parsed = parse_lesson_data(lesson)
                if parsed:
                    filtered_lessons.append(parsed)
            title = f"📅 Все расписание ({group_name})"
        
        return format_schedule(filtered_lessons, title)
        
    except Exception as e:
        print(f"ОШИБКА: Произошла ошибка при получения расписания: {str(e)}")
        return f"❌ Произошла ошибка при загрузке расписания: {str(e)}"

async def check_schedule_changes(context: ContextTypes.DEFAULT_TYPE):
    """Checks for schedule changes with the new API"""
    global schedule_cache, last_schedule_check
    
    print("ЛОГ: Проверка изменений в расписании...")
    new_schedule = fetch_schedule_data()
    
    if not new_schedule:
        print("ЛОГ: Не удалось проверить изменения расписания")
        return

    # Extract groups from new schedule
    new_groups = set()
    for lesson in new_schedule:
        if 'group' in lesson:
            new_groups.add(lesson['group'])
    
    # Compare with old groups
    old_groups = set()
    for lesson in schedule_cache:
        if 'group' in lesson:
            old_groups.add(lesson['group'])
    
    # Check for new or removed groups
    added_groups = new_groups - old_groups
    removed_groups = old_groups - new_groups
    
    if added_groups or removed_groups:
        print(f"ЛОГ: Обнаружены изменения в группах")
        
        for group_name in added_groups:
            change_message = f"🔄 <b>Добавлена новая группа: {group_name}</b>\n\nИспользуйте команду '🎓 Сменить группу' для выбора этой группы."
            
            # Notify special users about new group
            special_users = [u for u in get_all_users() if u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")
        
        for group_name in removed_groups:
            change_message = f"🔄 <b>Группа {group_name} удалена из расписания</b>\n\nУченики этой группы могут выбрать другую группу."
            
            # Notify special users about removed group
            special_users = [u for u in get_all_users() if u['user_id'] == DEVELOPER_ID]
            for user in special_users:
                try:
                    await context.bot.send_message(
                        user['user_id'],
                        change_message,
                        parse_mode='HTML'
                    )
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")

    schedule_cache = new_schedule
    last_schedule_check = datetime.now(YEKATERINBURG_TZ)

async def send_daily_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends daily schedule at 19:00 with the new API"""
    print("ЛОГ: Отправка ежедневного расписания...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        tomorrow_yekat = (datetime.now(YEKATERINBURG_TZ) + timedelta(days=1)).date()
        tomorrow_lessons = filter_lessons_by_date(lessons, tomorrow_yekat)
        
        if tomorrow_lessons:
            schedule_text = format_schedule(tomorrow_lessons, f"📅 Расписание на завтра ({group_name})")
            
            homeworks = get_homeworks(group_name)
            if homeworks:
                homework_text = "\n\n📝 <b>Домашние задания:</b>\n"
                for hw in homeworks[:3]:
                    homework_text += f"• {hw['subject']}: {hw['task']} (до {hw['deadline']})\n"
                schedule_text += homework_text
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    # Check user notification settings
                    settings = get_user_notification_settings(user['user_id'])
                    if settings and settings['tomorrow_schedule']:
                        await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить расписание пользователю {user['user_id']}: {e}")

async def send_morning_schedule(context: ContextTypes.DEFAULT_TYPE):
    """Sends morning schedule at 07:00 with the new API"""
    print("ЛОГ: Отправка утреннего расписания...")
    
    global schedule_cache
    
    if not schedule_cache:
        schedule_data = fetch_schedule_data()
        if not schedule_data:
            return
        schedule_cache = schedule_data
    
    # Group lessons by group name
    groups_lessons = {}
    for lesson in schedule_cache:
        group_name = lesson.get('group')
        if group_name:
            if group_name not in groups_lessons:
                groups_lessons[group_name] = []
            groups_lessons[group_name].append(lesson)
    
    for group_name, lessons in groups_lessons.items():
        today_lessons = filter_lessons_by_date(lessons, datetime.now(YEKATERINBURG_TZ).date())
        
        if today_lessons:
            schedule_text = format_schedule(today_lessons, f"📅 Расписание на сегодня ({group_name})")
            
            users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
            for user in users:
                try:
                    # Check user notification settings
                    settings = get_user_notification_settings(user['user_id'])
                    if settings and settings['today_schedule']:
                        await context.bot.send_message(user['user_id'], schedule_text, parse_mode='HTML')
                except Exception as e:
                    print(f"ОШИБКА: Не удалось отправить расписание пользователю {user['user_id']}: {e}")

# -------------------- UPDATED CALL SCHEDULE FUNCTIONS --------------------

async def show_call_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows the appropriate call schedule based on day of week"""
    try:
        now = datetime.now(YEKATERINBURG_TZ)
        day_of_week = now.weekday()  # 0=Monday, 6=Sunday
        
        if day_of_week == 5:  # Saturday
            schedule_text = format_call_schedule(SATURDAY_CALL_SCHEDULE, "Суббота")
        elif day_of_week == 6:  # Sunday
            schedule_text = "🔔 <b>Воскресенье - выходной день</b>"
        else:  # Monday-Friday
            schedule_text = format_call_schedule(REGULAR_CALL_SCHEDULE, "Понедельник-Пятница")
        
        await update.message.reply_text(schedule_text, parse_mode='HTML')
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_call_schedule: {e}")

def format_call_schedule(schedule, day_type):
    """Formats call schedule for display with time on the side"""
    result = [f"🔔 <b>Расписание звонков ({day_type})</b>\n"]
    
    if isinstance(schedule, list):
        # Новый формат с списком (понедельник-пятница)
        current_lesson = None
        lesson_parts = []
        
        for item in schedule:
            if item['type'] == 'lesson':
                if current_lesson != item['number']:
                    # Если началась новая пара, выводим предыдущую
                    if current_lesson is not None and lesson_parts:
                        result.append(format_lesson_display(current_lesson, lesson_parts))
                    current_lesson = item['number']
                    lesson_parts = []
                
                lesson_parts.append(item)
            elif item['type'] == 'break' and current_lesson is not None:
                # Добавляем перемену к текущей паре
                lesson_parts.append(item)
        
        # Добавляем последнюю пару
        if current_lesson is not None and lesson_parts:
            result.append(format_lesson_display(current_lesson, lesson_parts))
            
    else:
        # Старый формат (для субботы и коротких дней)
        for key, value in schedule.items():
            if isinstance(key, int):  # Lesson
                result.append(f"{key} пара: {value['start']}-{value['end']}")
            # Перемены в старом формате пропускаем для компактности
    
    return "\n".join(result)

def format_lesson_display(lesson_number, items):
    """Formats a single lesson display with time on the side"""
    lesson_times = []
    for item in items:
        if item['type'] == 'lesson':
            if item['part'] == 1:
                lesson_times.append(f"{item['start']}-{item['end']}")
    # Берем только время первой части для компактности, как в примере
    if lesson_times:
        return f"{lesson_number} пара: {lesson_times[0]}"
    return f"{lesson_number} пара"

# -------------------- LESSON NOTIFICATION FUNCTIONS --------------------

async def check_lesson_notifications(context: ContextTypes.DEFAULT_TYPE):
    """Checks if any lessons are starting in 5 minutes and sends notifications"""
    try:
        global schedule_cache
        
        if not schedule_cache:
            return
        
        now = datetime.now(YEKATERINBURG_TZ)
        today = now.date()
        
        # Group lessons by group name
        groups_lessons = {}
        for lesson in schedule_cache:
            parsed = parse_lesson_data(lesson)
            if parsed and 'datetime' in parsed:
                lesson_date = parsed['datetime'].date()
                if lesson_date == today:
                    group_name = parsed['group']
                    if group_name not in groups_lessons:
                        groups_lessons[group_name] = []
                    groups_lessons[group_name].append(parsed)
        
        for group_name, lessons in groups_lessons.items():
            for lesson in lessons:
                lesson_time = lesson['datetime']
                time_diff = (lesson_time - now).total_seconds()
                
                # Check if lesson starts in 5 minutes (300 seconds)
                if 240 <= time_diff <= 300:  # 4-5 minutes to avoid missing due to timing
                    await send_lesson_notification(context.bot, group_name, lesson)
    
    except Exception as e:
        print(f"ОШИБКА: Ошибка в check_lesson_notifications: {e}")

async def send_lesson_notification(bot, group_name, lesson):
    """Sends notification about upcoming lesson"""
    try:
        notification_text = (
            f"🕓 <b>Через 5 минут начинается пара</b>\n\n"
            f"📚 <b>Предмет:</b> {lesson['subject']}\n"
            f"👨‍🏫 <b>Преподаватель:</b> {lesson['teacher']}\n"
            f"🚪 <b>Кабинет:</b> {lesson['room']} ({lesson['campus']})\n"
            f"⏰ <b>Время:</b> {lesson['start_time']}-{lesson['end_time']}\n"
            f"📖 <b>Тип:</b> {lesson['type']}"
        )
        
        users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
        
        for user in users:
            try:
                # Check user notification settings
                settings = get_user_notification_settings(user['user_id'])
                if settings and settings['lesson_start']:
                    await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
            except Exception as e:
                print(f"ОШИБКА: Не удалось отправить уведомление о начале пары пользователю {user['user_id']}: {e}")
    
    except Exception as e:
        print(f"ОШИБКА: Ошибка в send_lesson_notification: {e}")

# -------------------- NOTIFICATION SETTINGS FUNCTIONS --------------------

async def show_notification_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows notification settings menu"""
    try:
        user_id = update.effective_user.id
        
        # Универсальный способ получения объекта сообщения
        if update.message:
            message = update.message
        elif update.callback_query and update.callback_query.message:
            message = update.callback_query.message
        else:
            # Если нет сообщения, создаем новое
            await context.bot.send_message(user_id, "❌ Не удалось загрузить настройки.")
            return ConversationHandler.END
        
        settings = get_user_notification_settings(user_id)
        
        if not settings:
            await message.reply_text("❌ Не удалось загрузить настройки.")
            return ConversationHandler.END
        
        # Безопасный доступ к настройкам с значениями по умолчанию
        keyboard = [
            [InlineKeyboardButton(f"🔔 Уведомления о начале пары: {'✅' if settings.get('lesson_start', 1) else '❌'}", callback_data='toggle_lesson_start')],
            [InlineKeyboardButton(f"📝 Уведомления о новом ДЗ: {'✅' if settings.get('new_homework', 1) else '❌'}", callback_data='toggle_new_homework')],
            [InlineKeyboardButton(f"📢 Важные уведомления: {'✅' if settings.get('important_notifications', 1) else '❌'}", callback_data='toggle_important_notifications')],
            [InlineKeyboardButton(f"🏃 Спортивные уведомления: {'✅' if settings.get('sport_notifications', 1) else '❌'}", callback_data='toggle_sport_notifications')],
            [InlineKeyboardButton(f"📅 Расписание на завтра вечером: {'✅' if settings.get('tomorrow_schedule', 1) else '❌'}", callback_data='toggle_tomorrow_schedule')],
            [InlineKeyboardButton(f"🌅 Расписание на сегодня утром: {'✅' if settings.get('today_schedule', 1) else '❌'}", callback_data='toggle_today_schedule')],
            [InlineKeyboardButton(f"🎂 Уведомления о днях рождения: {'✅' if settings.get('birthday_notifications', 1) else '❌'}", callback_data='toggle_birthday_notifications')],
            [InlineKeyboardButton(f"🎉 Уведомления о своем дне рождения: {'✅' if settings.get('own_birthday_notifications', 1) else '❌'}", callback_data='toggle_own_birthday_notifications')],
            [InlineKeyboardButton(f"📅 Уведомления о событиях: {'✅' if settings.get('event_notifications', 1) else '❌'}", callback_data='toggle_event_notifications')],
            [InlineKeyboardButton("✅ Готово", callback_data='done_notification_settings')]
        ]
        
        await message.reply_text(
            "🔧 <b>Настройки уведомлений</b>\n\n"
            "Выберите, какие уведомления вы хотите получать:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_NOTIFICATION_SETTINGS
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_notification_settings: {e}")
        # Альтернативный способ отправки сообщения при ошибке
        try:
            await context.bot.send_message(user_id, "❌ Произошла ошибка при загрузке настроек.")
        except:
            pass
        return ConversationHandler.END

async def handle_notification_settings_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles notification settings callbacks"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        if query.data == 'done_notification_settings':
            await query.edit_message_text("✅ Настройки уведомлений сохранены!")
            # Используем универсальный способ показа главного меню
            try:
                await show_main_menu(update, user_id)
            except Exception as e:
                print(f"ОШИБКА при показе главного меню: {e}")
            return ConversationHandler.END
        
        # Toggle settings
        setting_map = {
            'toggle_lesson_start': 'lesson_start',
            'toggle_new_homework': 'new_homework',
            'toggle_important_notifications': 'important_notifications',
            'toggle_sport_notifications': 'sport_notifications',
            'toggle_tomorrow_schedule': 'tomorrow_schedule',
            'toggle_today_schedule': 'today_schedule',
            'toggle_birthday_notifications': 'birthday_notifications',
            'toggle_own_birthday_notifications': 'own_birthday_notifications',
            'toggle_event_notifications': 'event_notifications'
        }
        
        if query.data in setting_map:
            current_settings = get_user_notification_settings(user_id)
            setting_name = setting_map[query.data]
            current_value = current_settings.get(setting_name, 1)  # Значение по умолчанию 1
            new_value = 1 - current_value
            
            if update_user_notification_settings(user_id, setting_name, new_value):
                # Обновляем сообщение с новыми настройками
                current_settings = get_user_notification_settings(user_id)
                keyboard = [
                    [InlineKeyboardButton(f"🔔 Уведомления о начале пары: {'✅' if current_settings.get('lesson_start', 1) else '❌'}", callback_data='toggle_lesson_start')],
                    [InlineKeyboardButton(f"📝 Уведомления о новом ДЗ: {'✅' if current_settings.get('new_homework', 1) else '❌'}", callback_data='toggle_new_homework')],
                    [InlineKeyboardButton(f"📢 Важные уведомления: {'✅' if current_settings.get('important_notifications', 1) else '❌'}", callback_data='toggle_important_notifications')],
                    [InlineKeyboardButton(f"🏃 Спортивные уведомления: {'✅' if current_settings.get('sport_notifications', 1) else '❌'}", callback_data='toggle_sport_notifications')],
                    [InlineKeyboardButton(f"📅 Расписание на завтра вечером: {'✅' if current_settings.get('tomorrow_schedule', 1) else '❌'}", callback_data='toggle_tomorrow_schedule')],
                    [InlineKeyboardButton(f"🌅 Расписание на сегодня утром: {'✅' if current_settings.get('today_schedule', 1) else '❌'}", callback_data='toggle_today_schedule')],
                    [InlineKeyboardButton(f"🎂 Уведомления о днях рождения: {'✅' if current_settings.get('birthday_notifications', 1) else '❌'}", callback_data='toggle_birthday_notifications')],
                    [InlineKeyboardButton(f"🎉 Уведомления о своем дне рождения: {'✅' if current_settings.get('own_birthday_notifications', 1) else '❌'}", callback_data='toggle_own_birthday_notifications')],
                    [InlineKeyboardButton(f"📅 Уведомления о событиях: {'✅' if current_settings.get('event_notifications', 1) else '❌'}", callback_data='toggle_event_notifications')],
                    [InlineKeyboardButton("✅ Готово", callback_data='done_notification_settings')]
                ]
                
                await query.edit_message_text(
                    "🔧 <b>Настройки уведомлений</b>\n\n"
                    "Выберите, какие уведомления вы хотите получать:",
                    parse_mode='HTML',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            else:
                await query.edit_message_text("❌ Ошибка при обновлении настроек.")
        
        return AWAITING_NOTIFICATION_SETTINGS
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_notification_settings_callback: {e}")
        return ConversationHandler.END

# -------------------- BIRTHDAY FUNCTIONS --------------------

async def ask_birthday_date(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks user to input birthday date"""
    user_id = update.effective_user.id
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    user_data = get_user(user_id)
    if not user_data or not user_data['group_name']:
        await update.message.reply_text("❌ Сначала выберите свою группу!")
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    await update.message.reply_text(
        "🎂 <b>Установка дня рождения</b>\n\n"
        "Введите дату своего рождения в формате <b>ДД.ММ</b>\n"
        "Например: 15.09 (для 15 сентября)\n\n"
        "Бот будет поздравлять вас в ваш день рождения и уведомлять вашу группу!",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
    )
    return AWAITING_BIRTHDAY

async def handle_birthday_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles birthday date input"""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    if text == '❌ Отмена':
        return await cancel_conversation(update, context)
    
    try:
        if not re.match(r'^\d{1,2}\.\d{1,2}$', text):
            raise ValueError("Неверный формат")
        
        day, month = text.split('.')
        day = int(day)
        month = int(month)
        
        if month < 1 or month > 12:
            raise ValueError("Месяц должен быть от 1 до 12")
        if day < 1 or day > 31:
            raise ValueError("День должен быть от 1 до 31")
        
        if month == 2 and day > 29:
            raise ValueError("В феврале не может быть больше 29 дней")
        elif month in [4, 6, 9, 11] and day > 30:
            raise ValueError("В этом месяце не может быть больше 30 дней")
            
        birthday_date = f"{day:02d}.{month:02d}"
        
        if set_user_birthday(user_id, birthday_date):
            await update.message.reply_text(
                f"✅ Дата рождения установлена: {birthday_date}\n"
                f"Теперь бот будет поздравлять вас каждый год!",
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await update.message.reply_text("❌ Ошибка при сохранении даты рождения")
            
    except ValueError as e:
        await update.message.reply_text(
            f"❌ {str(e)}. Введите дату в формате <b>ДД.ММ</b>\n"
            "Пример: 15.09 (для 15 сентября)",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    except Exception as e:
        await update.message.reply_text(
            "❌ Произошла ошибка. Попробуйте еще раз.",
            parse_mode='HTML'
        )
        return AWAITING_BIRTHDAY
    
    await show_main_menu(update, user_id)
    return ConversationHandler.END

async def check_birthdays(context: ContextTypes.DEFAULT_TYPE):
    """Checks for birthdays and sends notifications"""
    print("ЛОГ: Проверка дней рождений...")
    
    today_birthdays = get_today_birthdays()
    
    for birthday_user in today_birthdays:
        user_id = birthday_user['user_id']
        user_name = birthday_user['first_name']
        username = f"@{birthday_user['username']}" if birthday_user['username'] else user_name
        group_name = birthday_user['group_name']
        
        try:
            # Отправляем поздравление самому пользователю
            settings = get_user_notification_settings(user_id)
            if settings and settings['own_birthday_notifications']:
                await context.bot.send_message(
                    user_id,
                    f"🎂 <b>С ДНЕМ РОЖДЕНИЯ, {user_name}!</b>\n\n"
                    f"Желаем вам всего самого лучшего! 🎉",
                    parse_mode='HTML'
                )
                print(f"ЛОГ: Отправлено поздравление пользователю {user_id}")
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить поздравление пользователю {user_id}: {e}")
        
        # Отправляем уведомление группе
        users_in_group = get_db_connection().execute(
            'SELECT user_id FROM users WHERE group_name = ? AND user_id != ?', 
            (group_name, user_id)
        ).fetchall()
        
        for group_user in users_in_group:
            try:
                settings = get_user_notification_settings(group_user['user_id'])
                if settings and settings['birthday_notifications']:
                    await context.bot.send_message(
                        group_user['user_id'],
                        f"🎉 У {user_name} ({username}) сегодня день рождения!\n\n"
                        f"Не забудьте поздравить! 😊",
                        parse_mode='HTML'
                    )
            except Exception as e:
                print(f"ОШИБКА: Не удалось отправить уведомление пользователю {group_user['user_id']}: {e}")
    
    if today_birthdays:
        print(f"ЛОГ: Обработано {len(today_birthdays)} дней рождений")

# -------------------- GLOBAL NOTIFICATION FUNCTIONS --------------------

async def ask_global_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for global notification details (only for developer and authorized users)"""
    user_id = update.effective_user.id
    
    if not can_send_global_notifications(user_id):
        await update.message.reply_text("❌ У вас нет прав для этого действия.")
        return ConversationHandler.END
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return ConversationHandler.END
    
    clear_media_collection(user_id, 'global_notification')
    
    await update.message.reply_text(
        "🌍 <b>Отправка глобального уведомления всем группам</b>\n\n"
        "Напиши важное уведомление, которое нужно отправить ВСЕМ ученикам ВСЕХ групп.\n"
        "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст уведомления.",
        parse_mode='HTML',
        reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
    )
    return AWAITING_GLOBAL_NOTIFICATION

async def handle_global_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles global notification input"""
    user_id = update.effective_user.id
    
    if not can_send_global_notifications(user_id):
        await update.message.reply_text("❌ У вас нет прав для этого действия.")
        return await cancel_conversation(update, context)
    
    is_blocked, block_duration = check_spam(user_id)
    if is_blocked:
        await warn_user(update, block_duration)
        return AWAITING_GLOBAL_NOTIFICATION
    
    text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
    
    if text and text.strip() == '❌ Отмена':
        return await cancel_conversation(update, context)
    
    if text and text.strip() == '✅ Готово':
        media_collection = get_media_collection(user_id, 'global_notification')
        notification_text = context.user_data.get('global_notification_text', '')
        
        if not notification_text:
            await update.message.reply_text("❌ Пожалуйста, добавь текст глобального уведомления.")
            return AWAITING_GLOBAL_NOTIFICATION

        global_notification_id = add_global_notification(notification_text, user_id)
        
        if global_notification_id:
            for media_item in media_collection:
                add_global_notification_media(global_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            await update.message.reply_text("✅ Глобальное уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
            await send_global_notification_to_all(context.bot, global_notification_id, notification_text, user_id)
            
            clear_media_collection(user_id, 'global_notification')
            context.user_data.pop('global_notification_text', None)
        else:
            await update.message.reply_text("❌ Ошибка при добавлении глобального уведомления.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    
    if update.message.photo:
        photo = update.message.photo[-1]
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'photo',
            'id': photo.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.video:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'video',
            'id': update.message.video.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    elif update.message.document:
        add_to_media_collection(user_id, 'global_notification', {
            'type': 'document',
            'id': update.message.document.file_id,
            'caption': update.message.caption
        })
        await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    if text and text.strip():
        context.user_data['global_notification_text'] = text
        await update.message.reply_text("✅ Текст глобального уведомления сохранен. Отправьте медиа или нажмите '✅ Готово'.")
        return AWAITING_GLOBAL_NOTIFICATION
    
    await update.message.reply_text("❌ Пожалуйста, добавь текст глобального уведомления.")
    return AWAITING_GLOBAL_NOTIFICATION

async def send_global_notification_to_all(bot, global_notification_id, message, added_by):
    """Sends a global notification to all users"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    global_text = (
        f"🌍 <b>ГЛОБАЛЬНОЕ УВЕДОМЛЕНИЕ</b>\n\n"
        f"{message}\n\n"
        f"👤 <b>От:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM global_notification_media WHERE global_notification_id = ?', (global_notification_id,)).fetchall()
    conn.close()
    
    users = get_all_users()
    
    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['important_notifications']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=global_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=global_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=global_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=global_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=global_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=global_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], global_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить глобальное уведомление пользователю {user['user_id']}: {e}")

# -------------------- EVENT FUNCTIONS --------------------

async def ask_event_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for event details"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_create_events(user_id, user_data['group_name']):
            await update.message.reply_text("❌ У вас нет прав для создания событий.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'event')
        
        await update.message.reply_text(
            "📅 <b>Создание нового события</b>\n\n"
            "Напиши в формате:\n"
            "<b>Название события</b>\n"
            "<b>Дата события (ДД.ММ.ГГГГ)</b>\n"
            "<b>Описание события</b>\n\n"
            "Пример:\n"
            "Горный щит\n"
            "01.01.2025\n"
            "Поездка в горный щит на весь день, сбор в 8:00 у колледжа\n\n"
            "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст с описанием события.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово'], ['➕ Добавить кнопки']], resize_keyboard=True)
        )
        return AWAITING_EVENT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_event_details: {e}")
        return ConversationHandler.END

async def handle_event_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles event input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_EVENT
        
        if not can_create_events(user_id, user_data['group_name']):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '➕ Добавить кнопки':
            event_text = context.user_data.get('event_text', '')
            if not event_text:
                await update.message.reply_text("❌ Сначала добавьте описание события.")
                return AWAITING_EVENT
            
            # Сохраняем событие и переходим к добавлению кнопок
            lines = event_text.strip().split('\n')
            if len(lines) >= 3:
                event_name = lines[0].strip()
                event_date = lines[1].strip()
                event_description = lines[2].strip()
                
                # Проверяем дату
                try:
                    datetime.strptime(event_date, '%d.%m.%Y')
                except ValueError:
                    await update.message.reply_text("❌ Неверный формат даты. Используйте ДД.ММ.ГГГГ")
                    return AWAITING_EVENT
                
                context.user_data['event_name'] = event_name
                context.user_data['event_date'] = event_date
                context.user_data['event_description'] = event_description
                
                await update.message.reply_text(
                    "🔘 <b>Добавление кнопок для события</b>\n\n"
                    "Введите текст для кнопки (одна кнопка на сообщение):\n"
                    "Например: 'Я пойду!' или 'Участвую'\n\n"
                    "Когда добавите все кнопки, нажмите '✅ Готово'",
                    parse_mode='HTML',
                    reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
                )
                return AWAITING_EVENT_BUTTONS
            else:
                await update.message.reply_text("❌ Неправильный формат. Нужно 3 строки: название, дата, описание")
                return AWAITING_EVENT
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'event')
            event_text = context.user_data.get('event_text', '')
            
            if not event_text:
                await update.message.reply_text("❌ Пожалуйста, добавьте описание события.")
                return AWAITING_EVENT
                
            lines = event_text.strip().split('\n')
            if len(lines) >= 3:
                event_name = lines[0].strip()
                event_date = lines[1].strip()
                event_description = lines[2].strip()
                
                # Проверяем дату
                try:
                    datetime.strptime(event_date, '%d.%m.%Y')
                except ValueError:
                    await update.message.reply_text("❌ Неверный формат даты. Используйте ДД.ММ.ГГГГ")
                    return AWAITING_EVENT
                
                # Проверяем, есть ли кнопки
                has_buttons = 'event_buttons' in context.user_data and context.user_data['event_buttons']
                
                event_id = add_event(event_name, event_date, event_description, group_name, user_id, has_buttons)
                
                if event_id:
                    # Добавляем кнопки если есть
                    if has_buttons:
                        for button_text in context.user_data['event_buttons']:
                            add_event_button(event_id, button_text)
                    
                    await update.message.reply_text("✅ Событие добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                    await send_event_to_all(context.bot, event_id, event_name, event_date, event_description, group_name, user_id, has_buttons)
                    
                    clear_media_collection(user_id, 'event')
                    context.user_data.pop('event_text', None)
                    context.user_data.pop('event_buttons', None)
                    context.user_data.pop('event_name', None)
                    context.user_data.pop('event_date', None)
                    context.user_data.pop('event_description', None)
                else:
                    await update.message.reply_text("❌ Ошибка при добавлении события.")
                
                await show_main_menu(update, user_id)
                return ConversationHandler.END
            else:
                await update.message.reply_text("❌ Неправильный формат. Нужно 3 строки: название, дата, описание")
                return AWAITING_EVENT
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'event', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_EVENT
        elif update.message.video:
            add_to_media_collection(user_id, 'event', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_EVENT
        elif update.message.document:
            add_to_media_collection(user_id, 'event', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_EVENT
        
        if text and text.strip():
            context.user_data['event_text'] = text
            await update.message.reply_text("✅ Текст события сохранен. Отправьте медиа или нажмите '✅ Готово' или '➕ Добавить кнопки'.")
            return AWAITING_EVENT
        
        await update.message.reply_text("❌ Пожалуйста, добавьте описание события.")
        return AWAITING_EVENT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_event_input: {e}")
        return AWAITING_EVENT

async def handle_event_buttons_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles event buttons input"""
    try:
        user_id = update.effective_user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_EVENT_BUTTONS
        
        text = update.message.text.strip()
        
        if text == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text == '✅ Готово':
            # Создаем событие с кнопками
            event_name = context.user_data.get('event_name')
            event_date = context.user_data.get('event_date')
            event_description = context.user_data.get('event_description')
            group_name = get_user(user_id)['group_name']
            event_buttons = context.user_data.get('event_buttons', [])
            
            if not event_buttons:
                await update.message.reply_text("❌ Вы не добавили ни одной кнопки.")
                return AWAITING_EVENT_BUTTONS
            
            event_id = add_event(event_name, event_date, event_description, group_name, user_id, True)
            
            if event_id:
                # Добавляем кнопки
                for button_text in event_buttons:
                    add_event_button(event_id, button_text)
                
                await update.message.reply_text("✅ Событие с кнопками добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                await send_event_to_all(context.bot, event_id, event_name, event_date, event_description, group_name, user_id, True)
                
                context.user_data.pop('event_buttons', None)
                context.user_data.pop('event_name', None)
                context.user_data.pop('event_date', None)
                context.user_data.pop('event_description', None)
            else:
                await update.message.reply_text("❌ Ошибка при добавлении события.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        # Добавляем кнопку
        if 'event_buttons' not in context.user_data:
            context.user_data['event_buttons'] = []
        
        context.user_data['event_buttons'].append(text)
        button_count = len(context.user_data['event_buttons'])
        
        await update.message.reply_text(
            f"✅ Кнопка '{text}' добавлена. Всего кнопок: {button_count}\n\n"
            f"Добавьте еще кнопку или нажмите '✅ Готово'",
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_EVENT_BUTTONS
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_event_buttons_input: {e}")
        return AWAITING_EVENT_BUTTONS

async def send_event_to_all(bot, event_id, event_name, event_date, event_description, group_name, added_by, has_buttons=False):
    """Sends an event to all users in a group"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    event_text = (
        f"📅 <b>НОВОЕ СОБЫТИЕ</b>\n\n"
        f"🎯 <b>Название:</b> {event_name}\n"
        f"📅 <b>Дата:</b> {event_date}\n"
        f"📝 <b>Описание:</b> {event_description}\n"
        f"👥 <b>Группа:</b> {group_name}\n"
        f"👤 <b>От:</b> {role_display}"
    )
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['event_notifications']:
                if has_buttons:
                    # Получаем кнопки для события
                    buttons = get_event_buttons(event_id)
                    keyboard = []
                    for button in buttons:
                        keyboard.append([InlineKeyboardButton(button['button_text'], callback_data=f"event_{event_id}_{button['id']}")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await bot.send_message(user['user_id'], event_text, parse_mode='HTML', reply_markup=reply_markup)
                else:
                    await bot.send_message(user['user_id'], event_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить событие пользователю {user['user_id']}: {e}")

async def handle_event_button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles event button callbacks"""
    try:
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split('_')
        event_id = int(parts[1])
        button_id = int(parts[2])
        
        user_id = query.from_user.id
        user_data = get_user(user_id)
        
        # Получаем информацию о кнопке
        buttons = get_event_buttons(event_id)
        button_text = None
        for button in buttons:
            if button['id'] == button_id:
                button_text = button['button_text']
                break
        
        if not button_text:
            await query.edit_message_text("❌ Ошибка: кнопка не найдена.")
            return
        
        # Добавляем ответ
        add_event_response(event_id, user_id, button_id, button_text)
        
        # Отправляем уведомление создателю события
        event = get_db_connection().execute('SELECT * FROM events WHERE id = ?', (event_id,)).fetchone()
        if event:
            creator_id = event['added_by']
            try:
                await context.bot.send_message(
                    creator_id,
                    f"📅 <b>Новый ответ на событие</b>\n\n"
                    f"🎯 <b>Событие:</b> {event['event_name']}\n"
                    f"👤 <b>Пользователь:</b> {user_data['first_name']} (@{user_data['username']})\n"
                    f"🔘 <b>Выбрал:</b> {button_text}",
                    parse_mode='HTML'
                )
            except Exception as e:
                print(f"ОШИБКА: Не удалось отправить уведомление создателю события: {e}")
        
        await query.edit_message_text(
            f"✅ <b>Спасибо за ответ!</b>\n\n"
            f"Вы выбрали: <b>{button_text}</b>\n\n"
            f"Создатель события получил уведомление.",
            parse_mode='HTML'
        )
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_event_button_callback: {e}")

async def check_events(context: ContextTypes.DEFAULT_TYPE):
    """Checks for upcoming events and sends notifications"""
    print("ЛОГ: Проверка предстоящих событий...")
    
    events = get_all_events()
    today = datetime.now().date()
    
    for event in events:
        try:
            event_date = datetime.strptime(event['event_date'], '%d.%m.%Y').date()
            days_until = (event_date - today).days
            
            # Уведомление за день до события
            if days_until == 1:
                await send_event_reminder(context.bot, event, "завтра")
            # Уведомление в день события
            elif days_until == 0:
                await send_event_reminder(context.bot, event, "сегодня")
                
        except Exception as e:
            print(f"ОШИБКА: Не удалось обработать событие {event['id']}: {e}")

async def send_event_reminder(bot, event, when):
    """Sends event reminder"""
    try:
        event_text = (
            f"🔔 <b>НАПОМИНАНИЕ О СОБЫТИИ</b>\n\n"
            f"🎯 <b>Событие:</b> {event['event_name']}\n"
            f"📅 <b>Дата:</b> {event['event_date']} ({when})\n"
            f"📝 <b>Описание:</b> {event['event_description']}\n"
            f"👥 <b>Группа:</b> {event['group_name']}\n"
            f"👤 <b>Организатор:</b> {event['first_name']}"
        )
        
        users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (event['group_name'],)).fetchall()
        
        for user in users:
            try:
                # Check user notification settings
                settings = get_user_notification_settings(user['user_id'])
                if settings and settings['event_notifications']:
                    if event['has_buttons']:
                        # Получаем кнопки для события
                        buttons = get_event_buttons(event['id'])
                        keyboard = []
                        for button in buttons:
                            keyboard.append([InlineKeyboardButton(button['button_text'], callback_data=f"event_{event['id']}_{button['id']}")])
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await bot.send_message(user['user_id'], event_text, parse_mode='HTML', reply_markup=reply_markup)
                    else:
                        await bot.send_message(user['user_id'], event_text, parse_mode='HTML')
            except Exception as e:
                print(f"ОШИБКА: Не удалось отправить напоминание о событии пользователю {user['user_id']}: {e}")
    
    except Exception as e:
        print(f"ОШИБКА: Ошибка в send_event_reminder: {e}")

# -------------------- BACKUP FUNCTION --------------------

async def create_backup(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Creates a backup of the database and sends it to the developer"""
    try:
        user_id = update.effective_user.id
        
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return
        
        await update.message.reply_text("📦 Создание резервной копии...")
        
        # Создаем backup в памяти
        backup_data = io.StringIO()
        conn = get_db_connection()
        
        # Получаем все таблицы
        tables = conn.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()
        
        writer = csv.writer(backup_data)
        
        for table in tables:
            table_name = table['name']
            writer.writerow([f"=== {table_name} ==="])
            
            # Получаем данные таблицы
            data = conn.execute(f"SELECT * FROM {table_name}").fetchall()
            if data:
                # Заголовки столбцов
                headers = [description[0] for description in conn.execute(f"SELECT * FROM {table_name}").description]
                writer.writerow(headers)
                
                # Данные
                for row in data:
                    writer.writerow([str(cell) for cell in row])
            
            writer.writerow([])  # Пустая строка между таблицами
        
        conn.close()
        
        # Отправляем backup
        backup_data.seek(0)
        backup_text = backup_data.getvalue()
        
        # Если backup слишком большой, разбиваем на части
        if len(backup_text) > 4000:
            parts = [backup_text[i:i+4000] for i in range(0, len(backup_text), 4000)]
            for i, part in enumerate(parts):
                await update.message.reply_text(f"📦 Резервная копия (часть {i+1}/{len(parts)}):\n\n```\n{part}\n```", parse_mode='Markdown')
        else:
            await update.message.reply_text(f"📦 Резервная копия:\n\n```\n{backup_text}\n```", parse_mode='Markdown')
            
    except Exception as e:
        print(f"ОШИБКА: Ошибка при создании резервной копии: {e}")
        await update.message.reply_text("❌ Ошибка при создании резервной копии.")

# -------------------- CORE BOT FUNCTIONS --------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for the /start command with dynamic groups"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        add_user(user_id, user.username, user.first_name, user.last_name)
        user_data = get_user(user_id)
        
        # Update groups list
        fetch_groups_list()
        
        # ИСПРАВЛЕНИЕ: Проверяем, есть ли у пользователя группа в актуальном списке
        if not user_data or not user_data['group_name'] or user_data['group_name'] not in ALL_GROUPS:
            print(f"ЛОГ: Пользователь {user.first_name} (ID: {user_id}) не имеет группы, запрашиваем выбор группы.")
            return await ask_user_group(update, context)

        print(f"ЛОГ: Пользователь {user.first_name} (ID: {user.id}) вернулся в главное меню.")
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в start_command: {e}")
        try:
            await update.message.reply_text(
                "Произошла ошибка при запуске бота. Попробуйте еще раз.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def ask_user_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks the user to select their group with dynamic list"""
    try:
        # Update groups list from API
        groups = fetch_groups_list()
        if not groups:
            await update.message.reply_text(
                "❌ Не удалось загрузить список групп. Попробуйте позже.",
                reply_markup=ReplyKeyboardRemove()
            )
            return ConversationHandler.END
        
        # Create keyboard with groups
        keyboard = [groups[i:i+3] for i in range(0, len(groups), 3)]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
        
        message_source = update.callback_query.message if update.callback_query else update.message
        await message_source.reply_text(
            "👋 Выбери свою группу:",
            reply_markup=reply_markup
        )
        
        return AWAITING_GROUP
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_user_group: {e}")
        return ConversationHandler.END

async def handle_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the user's group selection with dynamic list"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_GROUP
        
        group_name = update.message.text
        
        # Update groups list to ensure we have the latest
        current_groups = fetch_groups_list()
        
        if group_name not in current_groups:
            await update.message.reply_text(
                "❌ Пожалуйста, выбери группу из списка:",
                reply_markup=ReplyKeyboardMarkup([current_groups[i:i+3] for i in range(0, len(current_groups), 3)], 
                                               resize_keyboard=True, one_time_keyboard=True)
            )
            return AWAITING_GROUP
        
        update_user_group(user_id, group_name)
        
        await update.message.reply_text(
            f"✅ Группа {group_name} сохранена!",
            reply_markup=ReplyKeyboardRemove()
        )
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_group_selection: {e}")
        return ConversationHandler.END

async def show_main_menu(update: Update, user_id: int):
    """Displays the main menu based on user rights with error handling"""
    try:
        user_data = get_user(user_id)
        if not user_data:
            # Если пользователя нет в базе, добавляем его
            user = update.effective_user
            add_user(user_id, user.username, user.first_name, user.last_name)
            user_data = get_user(user_id)
            
        if not user_data:
            await update.message.reply_text("Произошла ошибка, попробуйте /start еще раз.")
            return

        # Безопасно получаем данные пользователя
        role = user_data.get('role', ROLE_STUDENT)
        group_name = user_data.get('group_name')
        custom_role_name = user_data.get('custom_role_name')
        
        welcome_text = "👋 Добро пожаловать!"
        
        if user_id == DEVELOPER_ID:
            welcome_text = "👑 Добро пожаловать, Разработчик!"
        elif role == ROLE_STAROSTA:
            welcome_text = "👑 Добро пожаловать, Староста!"
        elif role == ROLE_DEPUTY_STAROSTA:
            welcome_text = "👑 Добро пожаловать, Зам Старосты!"
        elif role == ROLE_PHYSICAL_ORGANIZER:
            welcome_text = "🏃 Добро пожаловать, Физорг!"
        elif role == ROLE_DEPUTY_PHYSICAL_ORGANIZER:
            welcome_text = "🏃 Добро пожаловать, Зам Физорга!"
        elif custom_role_name:
            welcome_text = f"🔧 Добро пожаловать, {custom_role_name}!"

        # Создаем базовое меню
        keyboard = [
            ['📅 Расписание', '📝 ДЗ', 'ℹ️ Информация'],
            ['💡 Предложить идею', '💰 Дать денюжку', '🔔 Расписание звонков'],
            ['📞 Связь', '🎂 Установить день рождения', '🎓 Сменить группу'],
            ['🔧 Настройки']
        ]
        
        # Проверяем права только если есть группа
        has_any_send_right = False
        has_any_delete_right = False
        
        if group_name:
            # Проверяем права на отправку
            has_any_send_right = (
                can_send_homework(user_id, group_name) or
                can_send_notifications(user_id, group_name) or
                can_send_sport_notifications(user_id, group_name) or
                can_send_global_notifications(user_id) or
                can_create_events(user_id, group_name)
            )
            
            # Проверяем права на удаление
            has_any_delete_right = (
                can_delete_homework(user_id, group_name) or
                can_delete_notifications(user_id, group_name) or
                can_delete_sport_notifications(user_id, group_name) or
                can_delete_suggestions(user_id) or
                user_id == DEVELOPER_ID
            )
        
        # Добавляем кнопки отправки и удаления если есть права
        if has_any_send_right or has_any_delete_right:
            menu_row = []
            if has_any_send_right:
                menu_row.append('📤 Отправка')
            if has_any_delete_right:
                menu_row.append('🗑️ Удаление')
            
            if menu_row:  # Добавляем строку только если есть хотя бы одна кнопка
                keyboard.insert(2, menu_row)  # Вставляем после второй строки
        
        # Добавляем кнопки для разработчика
        if user_id == DEVELOPER_ID:
            keyboard.append(['📦 Резервная копия', '👑 Назначить роль', '🔧 Управление правами', '💡 Просмотр предложений'])

        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        
        # Универсальный способ получения объекта сообщения
        if update.message:
            await update.message.reply_text(welcome_text, reply_markup=reply_markup)
        elif update.callback_query and update.callback_query.message:
            await update.callback_query.message.reply_text(welcome_text, reply_markup=reply_markup)
        else:
            # Если нет сообщения, создаем новое
            await context.bot.send_message(user_id, welcome_text, reply_markup=reply_markup)
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_main_menu: {e}")
        try:
            # Альтернативный способ отправки сообщения
            await context.bot.send_message(
                user_id, 
                "Произошла ошибка при загрузке меню. Попробуйте команду /start",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

async def show_send_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows send menu based on user rights"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        group_name = user_data['group_name']
        
        keyboard = []
        
        if can_send_homework(user_id, group_name):
            keyboard.append(['📚 Отправить ДЗ'])
        if can_send_notifications(user_id, group_name):
            keyboard.append(['📢 Отправить уведомление'])
        if can_send_sport_notifications(user_id, group_name):
            keyboard.append(['🏃‍♂️ Отправить спортивное уведомление'])
        if can_send_global_notifications(user_id):
            keyboard.append(['🌍 Отправить всем группам'])
        if can_create_events(user_id, group_name):
            keyboard.append(['📅 Создать событие'])
            
        keyboard.append(['🔙 Назад'])
        
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text(
            "📤 <b>Отправка</b>\n\nВыберите, что хотите отправить:", 
            parse_mode='HTML', 
            reply_markup=reply_markup
        )
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_send_menu: {e}")
        await update.message.reply_text("❌ Произошла ошибка при загрузке меню отправки.")
async def show_delete_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows delete menu only if user has at least one delete right"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        group_name = user_data['group_name']
        
        # Проверяем есть ли хотя бы одно право на удаление
        has_any_delete_right = (
            can_delete_homework(user_id, group_name) or
            can_delete_notifications(user_id, group_name) or
            can_delete_sport_notifications(user_id, group_name) or
            can_delete_suggestions(user_id) or
            user_id == DEVELOPER_ID  # Разработчик всегда может удалять пользователей
        )
        
        if not has_any_delete_right:
            await update.message.reply_text("❌ У вас нет прав для удаления каких-либо данных.")
            return
        
        keyboard = []
        
        # Добавляем только те кнопки, на которые есть права
        if can_delete_homework(user_id, group_name):
            keyboard.append([InlineKeyboardButton("🗑️ Удалить ДЗ", callback_data="delete_homework_menu")])
        if can_delete_notifications(user_id, group_name):
            keyboard.append([InlineKeyboardButton("🗑️ Удалить уведомление", callback_data="delete_notification_menu")])
        if can_delete_sport_notifications(user_id, group_name):
            keyboard.append([InlineKeyboardButton("🗑️ Удалить спортивные уведомления", callback_data="delete_sport_menu")])
        if can_delete_suggestions(user_id):
            keyboard.append([InlineKeyboardButton("🗑️ Удалить предложения", callback_data="delete_suggestions_menu")])
        if user_id == DEVELOPER_ID:
            keyboard.append([InlineKeyboardButton("🗑️ Удалить пользователя", callback_data="delete_user_menu")])
            
        keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="delete_back")])
        
        await update.message.reply_text(
            "🗑️ <b>Удаление</b>\n\nВыберите, что хотите удалить:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_delete_menu: {e}")

async def show_settings_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows settings menu"""
    try:
        keyboard = [
            ['🔧 Настройки уведомлений'],
            ['🔙 Назад']
        ]
        
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text("🔧 <b>Настройки</b>\n\nВыберите настройки:", parse_mode='HTML', reply_markup=reply_markup)
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_settings_menu: {e}")

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels the current conversation"""
    try:
        user = update.effective_user
        user_id = user.id
        
        # Используем правильный способ получения сообщения
        if update.message:
            await update.message.reply_text("Действие отменено.", reply_markup=ReplyKeyboardRemove())
        elif update.callback_query:
            await update.callback_query.message.reply_text("Действие отменено.", reply_markup=ReplyKeyboardRemove())
        
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в cancel_conversation: {e}")
        return ConversationHandler.END

async def handle_unknown_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles unknown messages and forwards them to developer"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        # Пересылаем сообщение разработчику
        if user_id != DEVELOPER_ID:
            message_text = ""
            if update.message.text:
                message_text = update.message.text
            elif update.message.caption:
                message_text = update.message.caption
            
            if message_text:
                username = user_data['username'] if user_data and user_data['username'] else "Нет юзернейма"
                first_name = user_data['first_name'] if user_data else "Неизвестный"
                group_name = user_data['group_name'] if user_data and user_data['group_name'] else "Не указана"
                
                forward_text = (
                    f"📨 <b>Непонятное сообщение от пользователя</b>\n\n"
                    f"👤 <b>Имя:</b> {first_name}\n"
                    f"📱 <b>Юзернейм:</b> @{username}\n"
                    f"🆔 <b>ID:</b> <code>{user_id}</code>\n"
                    f"📚 <b>Группа:</b> {group_name}\n"
                    f"💬 <b>Сообщение:</b> {message_text}"
                )
                
                try:
                    await context.bot.send_message(DEVELOPER_ID, forward_text, parse_mode='HTML')
                    print(f"ЛОГ: Переслано непонятное сообщение от пользователя {user_id} разработчику")
                except Exception as e:
                    print(f"ОШИБКА: Не удалось переслать сообщение разработчику: {e}")
        
        await update.message.reply_text("❌ Я не понимаю эту команду. Используйте кнопки меню для навигации.")
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_unknown_message: {e}")

async def handle_simple_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for simple text messages with error handling"""
    try:
        user = update.effective_user
        user_id = user.id
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return
        
        text = update.message.text
        user_data = get_user(user_id)
        
        print(f"ЛОГ: Пользователь {user.first_name} (ID: {user_id}) отправил сообщение: '{text}'")
        
        # ИСПРАВЛЕНИЕ: Проверяем только наличие группы, не проверяем наличие в ALL_GROUPS
        if not user_data or not user_data['group_name']:
            add_user(user_id, user.username, user.first_name, user.last_name)
            return await ask_user_group(update, context)

        role = user_data['role']
        group_name = user_data['group_name']
        
        if text == '📅 Расписание':
            await show_schedule_periods(update, user_id)
        
        elif text == '📝 ДЗ':
            await show_homework(update, group_name)
        
        elif text == 'ℹ️ Информация':
            await show_information(update, group_name, role)

        elif text == '💡 Просмотр предложений' and user_id == DEVELOPER_ID:
            await show_suggestions(update)
        
        elif text == 'Список пользователей' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await show_users_list(update)

        elif text == '💰 Дать денюжку':
            donate_text = (
                "💰 <b>Поддержка разработчика</b>\n\n"
                "Если не жалко, можешь дать разрабу бота денюжку на дальнейшее развитие бота и на покушать😊\n\n"
                "💳 <b>Т-Банк:</b> +79090154110\n\n"
                "Я коплю на сервер для бота (нужно 6000р). Кто готов пожертвовать на развитие бота, буду благодарен, а также занесу в список спонсоров ☺️"
            )
            await update.message.reply_text(donate_text, parse_mode='HTML')

        elif text == '🔔 Расписание звонков':
            await show_call_schedule(update, context)
        
        elif text == '🔧 Настройки':
            await show_settings_menu(update, context)
        
        elif text == '🔧 Настройки уведомлений':
            return await show_notification_settings(update, context)
        
        elif text == '📞 Связь':
            await show_contact_menu(update, context)
        
        elif text == '📞 Связаться с разработчиком':
            await contact_developer(update)
        
        elif text == '📞 Связаться со старостой':
            await contact_starosta(update, group_name)

        elif text == '📞 Связаться с замом старосты':
            await contact_deputy_starosta(update, group_name)
        
        elif text == '📞 Связаться с физоргом':
            await contact_physical_organizer(update, group_name)
            
        elif text == '📞 Связаться с замом физорга':
            await contact_deputy_physical_organizer(update, group_name)
        
        elif text in ['📅 Сегодня', '📅 Завтра', '📅 Неделя', '📅 Все расписание']:
            await handle_schedule_period(update, context, group_name)
    
        elif text == '🔙 Назад':
            await show_main_menu(update, user_id)

        elif text == '🗑️ Удаление':
            await show_delete_menu(update, context)

        elif text == '📤 Отправка':
            await show_send_menu(update, context)
            
        elif text == '👑 Назначить роль' and user_id == DEVELOPER_ID:
            await start_role_assignment(update, context)
            
        elif text == '🔧 Управление правами' and (user_id == DEVELOPER_ID or can_manage_users(user_id)):
            await manage_user_rights_menu(update, context)
            
        elif text == '📦 Резервная копия' and user_id == DEVELOPER_ID:
            await create_backup(update, context)

        else:
            await handle_unknown_message(update, context)
    
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_simple_message: {e}")
        try:
            await update.message.reply_text(
                "Произошла ошибка при обработке сообщения. Попробуйте еще раз.",
                reply_markup=ReplyKeyboardRemove()
            )
        except:
            pass

# -------------------- SCHEDULE DISPLAY FUNCTIONS --------------------

async def show_schedule_periods(update: Update, user_id: int):
    """Shows the schedule period selection"""
    try:
        keyboard = [
            ['📅 Сегодня', '📅 Завтра'],
            ['📅 Неделя', '📅 Все расписание'],
            ['🔙 Назад']
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text("Выбери период для просмотра расписания:", reply_markup=reply_markup)
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_schedule_periods: {e}")

async def handle_schedule_period(update: Update, context: ContextTypes.DEFAULT_TYPE, group_name: str):
    """Handles the schedule period selection with error handling"""
    try:
        text = update.message.text
        await update.message.reply_text("⏳ Загружаю расписание...", reply_markup=ReplyKeyboardRemove())
        schedule = get_schedule(text, group_name)
        await update.message.reply_text(schedule, parse_mode='HTML')
        await show_main_menu(update, update.effective_user.id)
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_schedule_period: {e}")
        await update.message.reply_text(
            "❌ Произошла ошибка при загрузке расписания. Попробуйте позже.",
            parse_mode='HTML'
        )

# -------------------- MESSAGE SENDING FUNCTIONS --------------------

async def ask_homework_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for homework details to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_homework(user_id):
            await update.message.reply_text("❌ У вас нет прав для отправки ДЗ.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'homework')
        
        await update.message.reply_text(
            "📝 <b>Добавление нового ДЗ</b>\n\n"
            "Напиши в формате:\n"
            "<b>Предмет</b>\n"
            "<b>Задание</b>\n"
            "<b>Срок сдачи</b>\n\n"
            "Пример:\n"
            "Математика\n"
            "Решить задачи 1-10 на странице 45\n"
            "До 15.09\n\n"
            "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст с описанием ДЗ.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_homework_details: {e}")
        return ConversationHandler.END

async def ask_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for information to send to everyone"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для отправки уведомлений.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'notification')
        
        await update.message.reply_text(
            "📢 <b>Отправка уведомления всем</b>\n\n"
            "Напиши уведомление, которое нужно отправить всем ученикам.\n"
            "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст уведомления.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_INFO
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_notification_details: {e}")
        return ConversationHandler.END

async def ask_sport_notification_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a sport notification to send"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для отправки спортивных уведомлений.")
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'sport')
        
        await update.message.reply_text(
            "🏃 <b>Отправка спортивного уведомления</b>\n\n"
            "Напиши спортивное уведомление, которое нужно отправить всем ученикам.\n"
            "Можно прикрепить несколько фото/видео к сообщению. Отправь все медиафайлы, а затем текст уведомления.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_SPORT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_sport_notification_details: {e}")
        return ConversationHandler.END

async def ask_suggestion_details(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Asks for a suggestion to improve the bot"""
    try:
        user_id = update.effective_user.id
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return ConversationHandler.END
        
        clear_media_collection(user_id, 'suggestion')
        
        await update.message.reply_text(
            "💡 <b>Предложение по улучшению бота</b>\n\n"
            "Напиши свое предложение по улучшению бота:\n\n"
            "Что бы ты хотел добавить или изменить?\n"
            "Можно прикрепить фото/видео к сообщению. Отправь все медиафайлы, а затем текст предложения.",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена'], ['✅ Готово']], resize_keyboard=True)
        )
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"ОШИБКА: Ошибка в ask_suggestion_details: {e}")
        return ConversationHandler.END

# -------------------- MESSAGE HANDLING FUNCTIONS --------------------

async def handle_homework_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles homework input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_HOMEWORK
        
        if not can_send_homework(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'homework')
            homework_text = context.user_data.get('homework_text', '')
            
            if not homework_text and not media_collection:
                await update.message.reply_text("❌ Пожалуйста, добавь описание к ДЗ или медиафайлы.")
                return AWAITING_HOMEWORK
                
            if not homework_text:
                await update.message.reply_text("❌ Пожалуйста, добавь описание к ДЗ.")
                return AWAITING_HOMEWORK
                
            lines = homework_text.strip().split('\n')
            if len(lines) >= 3:
                subject = lines[0].strip()
                task = lines[1].strip()
                deadline = lines[2].strip()
                
                homework_id = add_homework(subject, task, deadline, group_name, user_id)
                
                if homework_id:
                    for media_item in media_collection:
                        add_homework_media(homework_id, media_item['type'], media_item['id'], media_item.get('caption'))
                    
                    await update.message.reply_text("✅ ДЗ добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                    await send_homework_to_all(context.bot, homework_id, subject, task, deadline, group_name, user_id)
                    
                    clear_media_collection(user_id, 'homework')
                    context.user_data.pop('homework_text', None)
                else:
                    await update.message.reply_text("❌ Ошибка при добавлении ДЗ.")
                
                await show_main_menu(update, user_id)
                return ConversationHandler.END
            else:
                await update.message.reply_text("❌ Неправильный формат. Нужно 3 строки: предмет, задание, срок")
                return AWAITING_HOMEWORK
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'homework', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        elif update.message.video:
            add_to_media_collection(user_id, 'homework', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        elif update.message.document:
            add_to_media_collection(user_id, 'homework', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        
        if text and text.strip():
            context.user_data['homework_text'] = text
            await update.message.reply_text("✅ Текст ДЗ сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_HOMEWORK
        
        await update.message.reply_text("❌ Пожалуйста, добавь описание к ДЗ.")
        return AWAITING_HOMEWORK
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_homework_input: {e}")
        return AWAITING_HOMEWORK

async def handle_notification_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_INFO
        
        if not can_send_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'notification')
            notification_text = context.user_data.get('notification_text', '')
            
            if not notification_text:
                await update.message.reply_text("❌ Пожалуйста, добавь текст уведомления.")
                return AWAITING_INFO

            notification_id = add_notification(notification_text, group_name, user_id)
            
            if notification_id:
                for media_item in media_collection:
                    add_notification_media(notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("✅ Уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                await send_notification_to_all(context.bot, notification_id, notification_text, group_name, user_id)
                
                clear_media_collection(user_id, 'notification')
                context.user_data.pop('notification_text', None)
            else:
                await update.message.reply_text("❌ Ошибка при добавлении уведомления.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'notification', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        elif update.message.video:
            add_to_media_collection(user_id, 'notification', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        elif update.message.document:
            add_to_media_collection(user_id, 'notification', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        
        if text and text.strip():
            context.user_data['notification_text'] = text
            await update.message.reply_text("✅ Текст уведомления сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_INFO
        
        await update.message.reply_text("❌ Пожалуйста, добавь текст уведомления.")
        return AWAITING_INFO
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_notification_input: {e}")
        return AWAITING_INFO

async def handle_sport_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles sport notification input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SPORT
        
        if not can_send_sport_notifications(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)

        group_name = user_data['group_name']

        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'sport')
            sport_text = context.user_data.get('sport_text', '')
            
            if not sport_text:
                await update.message.reply_text("❌ Пожалуйста, добавь текст спортивного уведомления.")
                return AWAITING_SPORT
        
            sport_notification_id = add_sport_notification(sport_text, group_name, user_id)
            
            if sport_notification_id:
                for media_item in media_collection:
                    add_sport_notification_media(sport_notification_id, media_item['type'], media_item['id'], media_item.get('caption'))
                
                await update.message.reply_text("✅ Спортивное уведомление добавлено и отправляется...", reply_markup=ReplyKeyboardRemove())
                await send_sport_notification_to_all(context.bot, sport_notification_id, sport_text, group_name, user_id)
                
                clear_media_collection(user_id, 'sport')
                context.user_data.pop('sport_text', None)
            else:
                await update.message.reply_text("❌ Ошибка при добавлении спортивного уведомления.")
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'sport', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        elif update.message.video:
            add_to_media_collection(user_id, 'sport', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        elif update.message.document:
            add_to_media_collection(user_id, 'sport', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        
        if text and text.strip():
            context.user_data['sport_text'] = text
            await update.message.reply_text("✅ Текст спортивного уведомления сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_SPORT
        
        await update.message.reply_text("❌ Пожалуйста, добавь текст спортивного уведомления.")
        return AWAITING_SPORT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_sport_input: {e}")
        return AWAITING_SPORT

async def handle_suggestion_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles suggestion input - теперь отправляется только разработчику"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION
        
        text = update.message.text if update.message.text else (update.message.caption if update.message.caption else "")
        
        if text and text.strip() == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if text and text.strip() == '✅ Готово':
            media_collection = get_media_collection(user_id, 'suggestion')
            suggestion_text = context.user_data.get('suggestion_text', '')
            
            if not suggestion_text:
                await update.message.reply_text("❌ Пожалуйста, напиши свое предложение.")
                return AWAITING_SUGGESTION

            suggestion_id = add_suggestion(user_id, suggestion_text)
            
            if suggestion_id:
                for media_item in media_collection:
                    add_suggestion_media(suggestion_id, media_item['type'], media_item['id'], media_item.get('caption'))
            
            # Отправляем предложение только разработчику
            try:
                username = user_data['username'] if user_data['username'] else "Нет юзернейма"
                group_name = user_data['group_name'] if user_data['group_name'] else "Не указана"
                
                suggestion_message = (
                    f"💡 <b>НОВОЕ ПРЕДЛОЖЕНИЕ</b>\n\n"
                    f"👤 <b>От:</b> {user_data['first_name']} (@{username})\n"
                    f"📚 <b>Группа:</b> {group_name}\n"
                    f"🆔 <b>ID:</b> <code>{user_id}</code>\n\n"
                    f"💬 <b>Предложение:</b>\n{suggestion_text}"
                )
                
                if media_collection:
                    for media_item in media_collection:
                        if media_item['type'] == 'photo':
                            await context.bot.send_photo(
                                chat_id=DEVELOPER_ID,
                                photo=media_item['id'],
                                caption=suggestion_message,
                                parse_mode='HTML',
                                reply_markup=InlineKeyboardMarkup([
                                    [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                                ])
                            )
                        elif media_item['type'] == 'video':
                            await context.bot.send_video(
                                chat_id=DEVELOPER_ID,
                                video=media_item['id'],
                                caption=suggestion_message,
                                parse_mode='HTML',
                                reply_markup=InlineKeyboardMarkup([
                                    [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                                ])
                            )
                        elif media_item['type'] == 'document':
                            await context.bot.send_document(
                                chat_id=DEVELOPER_ID,
                                document=media_item['id'],
                                caption=suggestion_message,
                                parse_mode='HTML',
                                reply_markup=InlineKeyboardMarkup([
                                    [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                                ])
                            )
                else:
                    await context.bot.send_message(
                        DEVELOPER_ID,
                        suggestion_message,
                        parse_mode='HTML',
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{suggestion_id}")]
                        ])
                    )
            except Exception as e:
                print(f"ОШИБКА: Не удалось отправить предложение разработчику: {e}")
            
            await update.message.reply_text("✅ Спасибо за предложение! Мы его рассмотрим.", reply_markup=ReplyKeyboardRemove())
            
            clear_media_collection(user_id, 'suggestion')
            context.user_data.pop('suggestion_text', None)
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if update.message.photo:
            photo = update.message.photo[-1]
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'photo',
                'id': photo.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Фото добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        elif update.message.video:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'video',
                'id': update.message.video.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Видео добавлено. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        elif update.message.document:
            add_to_media_collection(user_id, 'suggestion', {
                'type': 'document',
                'id': update.message.document.file_id,
                'caption': update.message.caption
            })
            await update.message.reply_text("✅ Документ добавлен. Отправьте еще медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        
        if text and text.strip():
            context.user_data['suggestion_text'] = text
            await update.message.reply_text("✅ Текст предложения сохранен. Отправьте медиа или нажмите '✅ Готово'.")
            return AWAITING_SUGGESTION
        
        await update.message.reply_text("❌ Пожалуйста, напиши свое предложение.")
        return AWAITING_SUGGESTION
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_suggestion_input: {e}")
        return AWAITING_SUGGESTION

# -------------------- NOTIFICATION SENDING FUNCTIONS --------------------

async def send_homework_to_all(bot, homework_id, subject, task, deadline, group_name, added_by):
    """Sends homework to all users in a group"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    homework_text = (
        f"📝 <b>НОВОЕ ДОМАШНЕЕ ЗАДАНИЕ</b>\n\n"
        f"📚 <b>Предмет:</b> {subject}\n"
        f"📋 <b>Задание:</b> {task}\n"
        f"⏰ <b>Срок сдачи:</b> {deadline}\n"
        f"👥 <b>Группа:</b> {group_name}\n"
        f"👤 <b>От:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM homework_media WHERE homework_id = ?', (homework_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['new_homework']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=homework_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=homework_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=homework_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=homework_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], homework_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить ДЗ пользователю {user['user_id']}: {e}")

async def send_notification_to_all(bot, notification_id, message, group_name, added_by):
    """Sends a notification to all users in a group"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    notification_text = (
        f"📢 <b>ВАЖНОЕ УВЕДОМЛЕНИЕ</b>\n\n"
        f"{message}\n\n"
        f"👥 <b>Группа:</b> {group_name}\n"
        f"👤 <b>От:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM notification_media WHERE notification_id = ?', (notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()
    
    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['important_notifications']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=notification_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=notification_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=notification_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=notification_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], notification_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить уведомление пользователю {user['user_id']}: {e}")

async def send_sport_notification_to_all(bot, sport_notification_id, message, group_name, added_by):
    """Sends a sport notification to all users in a group"""
    user_data = get_user(added_by)
    role_display = get_user_role_display(added_by)
    
    sport_text = (
        f"🏃 <b>СПОРТИВНОЕ УВЕДОМЛЕНИЕ</b>\n\n"
        f"{message}\n\n"
        f"👥 <b>Группа:</b> {group_name}\n"
        f"👤 <b>От:</b> {role_display}"
    )
    
    conn = get_db_connection()
    media = conn.execute('SELECT * FROM sport_notification_media WHERE sport_notification_id = ?', (sport_notification_id,)).fetchall()
    conn.close()
    
    users = get_db_connection().execute('SELECT user_id FROM users WHERE group_name = ?', (group_name,)).fetchall()

    for user in users:
        try:
            # Check user notification settings
            settings = get_user_notification_settings(user['user_id'])
            if settings and settings['sport_notifications']:
                if media:
                    if len(media) > 1:
                        media_group = []
                        for i, media_item in enumerate(media):
                            media_dict = dict(media_item)
                            if media_dict['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_dict['media_id'],
                                    caption=sport_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_dict['media_id'],
                                    caption=sport_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            elif media_dict['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_dict['media_id'],
                                    caption=sport_text if i == 0 else None,
                                    parse_mode='HTML'
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await bot.send_media_group(chat_id=user['user_id'], media=chunk)
                    else:
                        media_item = dict(media[0])
                        if media_item['media_type'] == 'photo':
                            await bot.send_photo(chat_id=user['user_id'], photo=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'video':
                            await bot.send_video(chat_id=user['user_id'], video=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                        elif media_item['media_type'] == 'document':
                            await bot.send_document(chat_id=user['user_id'], document=media_item['media_id'], caption=sport_text, parse_mode='HTML')
                else:
                    await bot.send_message(user['user_id'], sport_text, parse_mode='HTML')
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить спортивное уведомление пользователю {user['user_id']}: {e}")

# -------------------- INFO DISPLAY FUNCTIONS --------------------

async def show_homework(update: Update, group_name: str):
    """Shows all homework for a group"""
    try:
        homeworks = get_homeworks(group_name)
        if not homeworks:
            await update.message.reply_text("📭 Пока нет домашних заданий")
            return
        
        for hw in homeworks:
            hw_text = (
                f"📝 <b>Домашнее задание</b>\n"
                f"📚 <b>Предмет:</b> {hw['subject']}\n"
                f"📋 <b>Задание:</b> {hw['task']}\n"
                f"⏰ <b>Срок:</b> {hw['deadline']}\n"
                f"👤 <b>Добавил:</b> {hw['first_name']}\n"
                f"📅 <b>Дата:</b> {datetime.fromisoformat(hw['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if hw['media']:
                if len(hw['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(hw['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=hw_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = hw['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=hw_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=hw_text, parse_mode='HTML')
            else:
                await update.message.reply_text(hw_text, parse_mode='HTML')
        
        await update.message.reply_text(f"📊 <b>Показано:</b> {len(homeworks)} заданий", parse_mode='HTML')
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_homework: {e}")

async def show_information(update: Update, group_name: str, role: str):
    """Shows information for the user"""
    try:
        user_count = get_total_user_count()
        
        # Получаем контакты для текущей группы
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        deputy_starosta = get_group_role(group_name, ROLE_DEPUTY_STAROSTA)
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        deputy_fizorg = get_group_role(group_name, ROLE_DEPUTY_PHYSICAL_ORGANIZER)
        
        info_text = (
            f"📊 <b>Пользователей в боте:</b> {user_count}\n\n"
            f"👥 <b>Контакты группы {group_name}:</b>\n"
        )
        
        if starosta:
            username = f"@{starosta['username']}" if starosta['username'] else starosta['first_name']
            info_text += f"👑 <b>Староста:</b> {username}\n"
            
        if deputy_starosta:
            username = f"@{deputy_starosta['username']}" if deputy_starosta['username'] else deputy_starosta['first_name']
            info_text += f"👑 <b>Зам старосты:</b> {username}\n"
            
        if fizorg:
            username = f"@{fizorg['username']}" if fizorg['username'] else fizorg['first_name']
            info_text += f"🏃 <b>Физорг:</b> {username}\n"
            
        if deputy_fizorg:
            username = f"@{deputy_fizorg['username']}" if deputy_fizorg['username'] else deputy_fizorg['first_name']
            info_text += f"🏃 <b>Зам физорга:</b> {username}\n"
            
        info_text += "👨‍💻 <b>Разработчик:</b> @imya_polbzovatela\n\n"
        
        await update.message.reply_text(info_text, parse_mode='HTML')

        notifications = get_notifications(group_name)
        sport_notifications = get_sport_notifications(group_name)
        events = get_events(group_name)
        
        if not notifications and not sport_notifications and not events:
            await update.message.reply_text("📭 Пока нет уведомлений и событий")
            return
        
        if notifications:
            await update.message.reply_text("📢 <b>Важные уведомления:</b>", parse_mode='HTML')
            for notif in notifications[:2]:
                notif_text = f"{notif['message']}\n\n👤 <b>От:</b> {notif['first_name']} | 📅 {datetime.fromisoformat(notif['created_at']).strftime('%d.%m.%Y')}"
                
                if notif['media']:
                    if len(notif['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(notif['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=notif_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = notif['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=notif_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=notif_text)
                else:
                    await update.message.reply_text(notif_text)
        
        if sport_notifications:
            await update.message.reply_text("🏃 <b>Спортивные уведомления:</b>", parse_mode='HTML')
            for sport in sport_notifications[:2]:
                sport_text = f"{sport['message']}\n\n👤 <b>От:</b> {sport['first_name']} | 📅 {datetime.fromisoformat(sport['created_at']).strftime('%d.%m.%Y')}"
                
                if sport['media']:
                    if len(sport['media']) > 1:
                        media_group = []
                        for i, media_item in enumerate(sport['media']):
                            if media_item['media_type'] == 'photo':
                                media_obj = InputMediaPhoto(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'video':
                                media_obj = InputMediaVideo(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            elif media_item['media_type'] == 'document':
                                media_obj = InputMediaDocument(
                                    media=media_item['media_id'],
                                    caption=sport_text if i == 0 else None
                                )
                            media_group.append(media_obj)
                        
                        for i in range(0, len(media_group), 10):
                            chunk = media_group[i:i+10]
                            await update.message.reply_media_group(media=chunk)
                    else:
                        media_item = sport['media'][0]
                        if media_item['media_type'] == 'photo':
                            await update.message.reply_photo(photo=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'video':
                            await update.message.reply_video(video=media_item['media_id'], caption=sport_text)
                        elif media_item['media_type'] == 'document':
                            await update.message.reply_document(document=media_item['media_id'], caption=sport_text)
                else:
                    await update.message.reply_text(sport_text)
        
        if events:
            await update.message.reply_text("📅 <b>Предстоящие события:</b>", parse_mode='HTML')
            for event in events[:3]:
                event_text = (
                    f"🎯 <b>Событие:</b> {event['event_name']}\n"
                    f"📅 <b>Дата:</b> {event['event_date']}\n"
                    f"📝 <b>Описание:</b> {event['event_description']}\n"
                    f"👤 <b>Организатор:</b> {event['first_name']}"
                )
                await update.message.reply_text(event_text, parse_mode='HTML')
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_information: {e}")

async def show_suggestions(update: Update):
    """Shows suggestions from students - только для разработчика"""
    try:
        user_id = update.effective_user.id
        
        # Проверяем, является ли пользователь разработчиком
        user_data = get_user(user_id)
        if not user_data or user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для просмотра предложений.")
            return
            
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("📭 Пока нет предложений от учеников")
            return
        
        for s in suggestions[:5]:  # Показываем последние 5 предложений
            username = f"@{s['username']}" if s['username'] else s['first_name']
            suggestion_text = (
                f"💡 <b>Предложение от {username}</b>\n\n"
                f"{s['message']}\n\n"
                f"📅 {datetime.fromisoformat(s['created_at']).strftime('%d.%m.%Y %H:%M')}"
            )
            
            if s['responses']:
                suggestion_text += "\n\n<b>Ответы:</b>\n"
                for response in s['responses']:
                    responder_name = f"@{response['username']}" if response['username'] else response['first_name']
                    suggestion_text += f"👤 {responder_name}: {response['message']}\n"
            
            if s['media']:
                if len(s['media']) > 1:
                    media_group = []
                    for i, media_item in enumerate(s['media']):
                        if media_item['media_type'] == 'photo':
                            media_obj = InputMediaPhoto(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'video':
                            media_obj = InputMediaVideo(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        elif media_item['media_type'] == 'document':
                            media_obj = InputMediaDocument(
                                media=media_item['media_id'],
                                caption=suggestion_text if i == 0 else None,
                                parse_mode='HTML'
                            )
                        media_group.append(media_obj)
                    
                    for i in range(0, len(media_group), 10):
                        chunk = media_group[i:i+10]
                        await update.message.reply_media_group(media=chunk)
                else:
                    media_item = s['media'][0]
                    if media_item['media_type'] == 'photo':
                        await update.message.reply_photo(photo=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'video':
                        await update.message.reply_video(video=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
                    elif media_item['media_type'] == 'document':
                        await update.message.reply_document(document=media_item['media_id'], caption=suggestion_text, parse_mode='HTML')
            else:
                await update.message.reply_text(suggestion_text, parse_mode='HTML')
                
            if not s['responses']:
                await update.message.reply_text(
                    "💬 Ответить на предложение:",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("💬 Ответить", callback_data=f"respond_{s['id']}")]
                    ])
                )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_suggestions: {e}")

async def show_users_list(update: Update):
    """Shows a list of all users grouped by groups"""
    try:
        users = get_all_users()
        if not users:
            await update.message.reply_text("❌ В базе данных нет пользователей.")
            return
        
        # Группируем пользователей по группам
        groups_dict = {}
        for user in users:
            group_name = user['group_name'] if user['group_name'] else "Без группы"
            if group_name not in groups_dict:
                groups_dict[group_name] = []
            groups_dict[group_name].append(user)
        
        user_list_text = "👥 <b>Список всех пользователей по группам</b>\n\n"
        
        for group_name, group_users in sorted(groups_dict.items()):
            user_list_text += f"<b>📚 Группа: {group_name}</b> ({len(group_users)} чел.)\n"
            
            for user in group_users:
                username = user['username'] if user['username'] else "Нет юзернейма"
                role_display = get_user_role_display(user['user_id'])
                
                user_list_text += (
                    f"  👤 <b>Имя:</b> {user['first_name']}\n"
                    f"  🆔 <b>ID:</b> <code>{user['user_id']}</code>\n"
                    f"  👨‍💼 <b>Роль:</b> {role_display}\n"
                    f"  📱 <b>Юзер:</b> @{username}\n\n"
                )
            
            user_list_text += "\n"
        
        # Разбиваем сообщение на части если оно слишком длинное
        if len(user_list_text) > 4000:
            parts = []
            current_part = ""
            sections = user_list_text.split('\n\n')
            
            for section in sections:
                if len(current_part + section + '\n\n') > 4000:
                    parts.append(current_part)
                    current_part = section + '\n\n'
                else:
                    current_part += section + '\n\n'
            
            if current_part:
                parts.append(current_part)
            
            for i, part in enumerate(parts):
                await update.message.reply_text(
                    f"{part}\n<b>Часть {i+1}/{len(parts)}</b>", 
                    parse_mode='HTML'
                )
        else:
            await update.message.reply_text(user_list_text, parse_mode='HTML')
            
    except Exception as e:
        print(f"ОШИБКА: Ошибка в show_users_list: {e}")
        await update.message.reply_text("❌ Произошла ошибка при загрузке списка пользователей.")

async def handle_show_users_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the callback for showing users in a specific group"""
    try:
        query = update.callback_query
        await query.answer()
        
        group_name = query.data.replace('show_users_', '')
        
        # Получаем пользователей выбранной группы
        users = [user for user in get_all_users() if user['group_name'] == group_name]
        
        if not users:
            await query.edit_message_text(f"❌ В группе {group_name} нет пользователей.")
            return
        
        user_list_text = f"👥 <b>Пользователи группы {group_name}</b>\n\n"
        
        for user in users:
            username = user['username'] if user['username'] else "Нет юзернейма"
            role_display = get_user_role_display(user['user_id'])
            
            user_list_text += (
                f"👤 <b>Имя:</b> {user['first_name']}\n"
                f"🆔 <b>ID:</b> <code>{user['user_id']}</code>\n"
                f"👨‍💼 <b>Роль:</b> {role_display}\n"
                f"📱 <b>Юзер:</b> @{username}\n\n"
            )
        
        # Добавляем кнопку "Назад"
        keyboard = [[InlineKeyboardButton("🔙 Назад к группам", callback_data="back_to_groups")]]
        
        await query.edit_message_text(
            user_list_text,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_show_users_callback: {e}")

async def handle_back_to_groups(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the back to groups callback"""
    try:
        query = update.callback_query
        await query.answer()
        
        await show_users_list(update)
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_back_to_groups: {e}")

# -------------------- DELETION FUNCTIONS --------------------

async def delete_homework_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows homework deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_homework(user_id, user_data['group_name']):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        homeworks = get_homeworks(user_data['group_name'])
        if not homeworks:
            await update.message.reply_text("📝 Нет домашних заданий для удаления.")
            return ConversationHandler.END
        
        # УБИРАЕМ ОГРАНИЧЕНИЕ В 5 ЭЛЕМЕНТОВ - показываем все
        keyboard = [[InlineKeyboardButton(f"❌ {hw['subject']} | {hw['deadline']}", callback_data=f"del_hw_{hw['id']}")] for hw in homeworks]
        await update.message.reply_text("Выберите ДЗ для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_HOMEWORK_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_homework_menu: {e}")
        return ConversationHandler.END

async def delete_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_notifications(user_id, user_data['group_name']):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        user_data = get_user(user_id)
        notifications = get_notifications(user_data['group_name'])
        sport_notifications = get_sport_notifications(user_data['group_name'])
        
        if not notifications and not sport_notifications:
            await update.message.reply_text("📢 Нет уведомлений для удаления.")
            return ConversationHandler.END

        keyboard = []
        # УБИРАЕМ ОГРАНИЧЕНИЕ В 5 ЭЛЕМЕНТОВ - показываем все
        for n in notifications:
            button_text = f"📢 {n['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_notif_{n['id']}")])
        
        for s in sport_notifications:
            button_text = f"🏃 {s['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{s['id']}")])

        await update.message.reply_text("Выберите уведомление для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_INFO_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_notification_menu: {e}")
        return ConversationHandler.END

async def delete_sport_notification_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows sport notification deletion menu"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        if not can_delete_sport_notifications(user_id, user_data['group_name']):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        if user_id == DEVELOPER_ID:
            sport_notifications = get_all_sport_notifications()
        else:
            sport_notifications = get_sport_notifications(user_data['group_name'])

        if not sport_notifications:
            await update.message.reply_text("🏃 Нет спортивных уведомлений для удаления.")
            return ConversationHandler.END

        keyboard = []
        # УБИРАЕМ ОГРАНИЧЕНИЕ В 10 ЭЛЕМЕНТОВ - показываем все
        for sport in sport_notifications:
            button_text = f"🏃 {sport['message'][:20]}..."
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"del_sport_{sport['id']}")])

        await update.message.reply_text("Выберите спортивное уведомление для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SPORT_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_sport_notification_menu: {e}")
        return ConversationHandler.END

async def delete_user_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows user deletion menu"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        users = [u for u in get_all_users() if u['user_id'] != DEVELOPER_ID]
        if not users:
            await update.message.reply_text("👥 Нет пользователей для удаления.")
            return ConversationHandler.END
            
        # УБИРАЕМ ОГРАНИЧЕНИЕ - показываем всех пользователей
        keyboard = [[InlineKeyboardButton(f"❌ {u['first_name']} (@{u['username']}) - Группа: {u['group_name']} - ID: {u['user_id']}", callback_data=f"del_user_{u['user_id']}")] for u in users]
        await update.message.reply_text("Выберите пользователя для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_USER_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_user_menu: {e}")
        return ConversationHandler.END

async def delete_suggestions_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows suggestions deletion menu"""
    try:
        user_id = update.effective_user.id
        if not can_delete_suggestions(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
            
        suggestions = get_suggestions()
        if not suggestions:
            await update.message.reply_text("💡 Нет предложений для удаления.")
            return ConversationHandler.END
        
        # УБИРАЕМ ОГРАНИЧЕНИЕ В 5 ЭЛЕМЕНТОВ - показываем все
        keyboard = [[InlineKeyboardButton(f"❌ {s['message'][:20]}...", callback_data=f"del_sugg_{s['id']}")] for s in suggestions]
        await update.message.reply_text("Выберите предложение для удаления:", reply_markup=InlineKeyboardMarkup(keyboard))
        return AWAITING_SUGGESTION_DELETE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в delete_suggestions_menu: {e}")
        return ConversationHandler.END

async def handle_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles deletion callbacks"""
    try:
        query = update.callback_query
        await query.answer()

        parts = query.data.split('_')
        data_type = parts[1]
        item_id = int(parts[2])
        
        message = "❌ Произошла ошибка."
        try:
            if data_type == 'hw':
                delete_homework(item_id)
                message = "✅ Домашнее задание успешно удалено."
            elif data_type == 'notif':
                delete_notification(item_id)
                message = "✅ Уведомление успешно удалено."
            elif data_type == 'sport':
                delete_sport_notification(item_id)
                message = "✅ Спортивное уведомление успешно удалено."
            elif data_type == 'user':
                delete_user(item_id)
                message = "✅ Пользователь успешно удален."
            elif data_type == 'sugg':
                delete_suggestion(item_id)
                message = "✅ Предложение успешно удалено."
            
            await query.edit_message_text(text=message)
        except Exception as e:
            await query.edit_message_text(text=f"❌ Ошибка при удалении: {e}")
        
        await show_main_menu(update, query.from_user.id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_delete_callback: {e}")
        return ConversationHandler.END

# -------------------- SUGGESTION RESPONSE FUNCTION --------------------

async def handle_suggestion_response_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response callback"""
    try:
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split('_')
        suggestion_id = int(parts[1])
        
        context.user_data['responding_to_suggestion'] = suggestion_id
        
        await query.edit_message_text(
            "💬 <b>Ответ на предложение</b>\n\nНапиши свой ответ:",
            parse_mode='HTML',
            reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
        )
        
        return AWAITING_SUGGESTION_RESPONSE
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_suggestion_response_callback: {e}")
        return ConversationHandler.END

async def handle_suggestion_response_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the suggestion response input"""
    try:
        user_id = update.effective_user.id
        user_data = get_user(user_id)
        
        is_blocked, block_duration = check_spam(user_id)
        if is_blocked:
            await warn_user(update, block_duration)
            return AWAITING_SUGGESTION_RESPONSE
        
        text = update.message.text
        
        if text == '❌ Отмена':
            return await cancel_conversation(update, context)
        
        if not text:
            await update.message.reply_text("❌ Пожалуйста, напиши ответ.")
            return AWAITING_SUGGESTION_RESPONSE
        
        suggestion_id = context.user_data.get('responding_to_suggestion')
        
        if not suggestion_id:
            await update.message.reply_text("❌ Ошибка: предложение не найдено.")
            return await cancel_conversation(update, context)
        
        conn = get_db_connection()
        suggestion = conn.execute('SELECT * FROM suggestions WHERE id = ?', (suggestion_id,)).fetchone()
        conn.close()
        
        if not suggestion:
            await update.message.reply_text("❌ Ошибка: предложение не найдено.")
            return await cancel_conversation(update, context)
        
        add_suggestion_response(suggestion_id, user_id, text)
        
        try:
            responder_name = user_data['first_name']
            if user_data['username']:
                responder_name = f"@{user_data['username']}"
            
            response_text = (
                f"💬 <b>Ответ на ваше предложение</b>\n\n"
                f"👤 <b>От:</b> {responder_name}\n"
                f"💡 <b>Ваше предложение:</b> {suggestion['message'][:100]}...\n\n"
                f"📝 <b>Ответ:</b> {text}"
            )
            
            await context.bot.send_message(
                chat_id=suggestion['user_id'],
                text=response_text,
                parse_mode='HTML'
            )
        except Exception as e:
            print(f"ОШИБКА: Не удалось отправить ответ автору предложения: {e}")
        
        await update.message.reply_text("✅ Ответ отправлен!", reply_markup=ReplyKeyboardRemove())
        await show_main_menu(update, user_id)
        return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_suggestion_response_input: {e}")
        return AWAITING_SUGGESTION_RESPONSE

# -------------------- ROLE ASSIGNMENT SYSTEM --------------------

async def start_role_assignment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Starts the role assignment process - сначала человек, потом роль"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
        
        # Получаем всех пользователей сгруппированных по группам
        users = get_all_users()
        groups_dict = {}
        for user in users:
            if user['user_id'] == user_id:  # Пропускаем себя
                continue
                
            group_name = user['group_name'] if user['group_name'] else "Без группы"
            if group_name not in groups_dict:
                groups_dict[group_name] = []
            groups_dict[group_name].append(user)
        
        if not groups_dict:
            await update.message.reply_text("❌ Нет пользователей для назначения ролей.")
            return ConversationHandler.END
        
        # Создаем клавиатуру с группами
        keyboard = []
        for group_name in sorted(groups_dict.keys()):
            user_count = len(groups_dict[group_name])
            keyboard.append([InlineKeyboardButton(f"📚 {group_name} ({user_count} чел.)", callback_data=f"role_group_{group_name}")])
        
        keyboard.append([InlineKeyboardButton("✏️ Назначить собственную роль", callback_data="custom_role_global")])
        keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="role_cancel")])
        
        await update.message.reply_text(
            "👑 <b>Назначение ролей пользователям</b>\n\n"
            "Выберите группу для назначения роли:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_ROLE_ASSIGNMENT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в start_role_assignment: {e}")
        return ConversationHandler.END

async def handle_role_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles group selection for role assignment"""
    try:
        query = update.callback_query
        await query.answer()
        
        if query.data == "role_cancel":
            await query.edit_message_text("❌ Назначение роли отменено.")
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        if query.data == "custom_role_global":
            context.user_data['custom_role_global'] = True
            await query.edit_message_text(
                "✏️ <b>Назначение собственной роли</b>\n\n"
                "Введите ID пользователя для назначения собственной роли:",
                parse_mode='HTML',
                reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
            )
            return AWAITING_CUSTOM_ROLE
        
        group_name = query.data.replace('role_group_', '')
        context.user_data['role_assignment_group'] = group_name
        
        # Получаем пользователей в выбранной группе
        users_in_group = [user for user in get_all_users() if user['group_name'] == group_name and user['user_id'] != query.from_user.id]
        
        if not users_in_group:
            await query.edit_message_text(f"❌ В группе {group_name} нет других пользователей.")
            return
        
        # Создаем клавиатуру с пользователями
        keyboard = []
        for user in users_in_group:
            current_role = get_user_role_display(user['user_id'])
            button_text = f"{user['first_name']} (@{user['username']}) - {current_role}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"role_user_{user['user_id']}")])
        
        keyboard.append([InlineKeyboardButton("🔙 Назад к группам", callback_data="role_back_to_groups")])
        keyboard.append([InlineKeyboardButton("❌ Отмена", callback_data="role_cancel")])
        
        await query.edit_message_text(
            f"👑 <b>Назначение роли для группы {group_name}</b>\n\n"
            "Выберите пользователя для назначения роли:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_ROLE_ASSIGNMENT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_role_group_selection: {e}")
        return AWAITING_ROLE_ASSIGNMENT

async def handle_role_user_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user selection for role assignment"""
    try:
        query = update.callback_query
        await query.answer()
        
        if query.data == "role_cancel":
            await query.edit_message_text("❌ Назначение роли отменено.")
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        if query.data == "role_back_to_groups":
            return await start_role_assignment(update, context)
        
        user_id = int(query.data.replace('role_user_', ''))
        context.user_data['role_assignment_user'] = user_id
        
        user_data = get_user(user_id)
        if not user_data:
            await query.edit_message_text("❌ Пользователь не найден.")
            return ConversationHandler.END
        
        # Создаем клавиатуру с типами ролей
        keyboard = [
            [InlineKeyboardButton("👑 Староста", callback_data="role_type_starosta")],
            [InlineKeyboardButton("👑 Зам старосты", callback_data="role_type_deputy_starosta")],
            [InlineKeyboardButton("🏃 Физорг", callback_data="role_type_physical_organizer")],
            [InlineKeyboardButton("🏃 Зам физорга", callback_data="role_type_deputy_physical_organizer")],
            [InlineKeyboardButton("✏️ Собственная роль", callback_data="custom_role")],
            [InlineKeyboardButton("🔙 Назад к пользователям", callback_data=f"role_back_to_users_{context.user_data['role_assignment_group']}")],
            [InlineKeyboardButton("❌ Снять все роли", callback_data="role_remove_all")],
            [InlineKeyboardButton("❌ Отмена", callback_data="role_cancel")]
        ]
        
        current_roles = []
        group_name = context.user_data['role_assignment_group']
        
        starosta = get_group_role(group_name, ROLE_STAROSTA)
        if starosta and starosta['user_id'] == user_id:
            current_roles.append("Староста")
        
        deputy = get_group_role(group_name, ROLE_DEPUTY_STAROSTA)
        if deputy and deputy['user_id'] == user_id:
            current_roles.append("Зам старосты")
        
        fizorg = get_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
        if fizorg and fizorg['user_id'] == user_id:
            current_roles.append("Физорг")
            
        deputy_fizorg = get_group_role(group_name, ROLE_DEPUTY_PHYSICAL_ORGANIZER)
        if deputy_fizorg and deputy_fizorg['user_id'] == user_id:
            current_roles.append("Зам физорга")
        
        current_roles_text = ", ".join(current_roles) if current_roles else "нет ролей"
        
        await query.edit_message_text(
            f"👑 <b>Назначение роли пользователю</b>\n\n"
            f"👤 <b>Пользователь:</b> {user_data['first_name']} (@{user_data['username']})\n"
            f"📚 <b>Группа:</b> {group_name}\n"
            f"🎭 <b>Текущие роли:</b> {current_roles_text}\n\n"
            "Выберите тип роли для назначения:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_ROLE_ASSIGNMENT
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_role_user_selection: {e}")
        return AWAITING_ROLE_ASSIGNMENT

async def handle_role_type_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles role type selection"""
    try:
        query = update.callback_query
        await query.answer()
        
        if query.data == "role_cancel":
            await query.edit_message_text("❌ Назначение роли отменено.")
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        if query.data.startswith("role_back_to_users_"):
            group_name = query.data.replace('role_back_to_users_', '')
            context.user_data['role_assignment_group'] = group_name
            return await handle_role_group_selection(update, context)
        
        if query.data == "role_remove_all":
            user_id = context.user_data['role_assignment_user']
            group_name = context.user_data['role_assignment_group']
            
            # Снимаем все роли
            remove_group_role(group_name, ROLE_STAROSTA)
            remove_group_role(group_name, ROLE_DEPUTY_STAROSTA)
            remove_group_role(group_name, ROLE_PHYSICAL_ORGANIZER)
            remove_group_role(group_name, ROLE_DEPUTY_PHYSICAL_ORGANIZER)
            
            user_data = get_user(user_id)
            await query.edit_message_text(
                f"✅ Все роли сняты с пользователя {user_data['first_name']}!"
            )
            await show_main_menu(update, query.from_user.id)
            return ConversationHandler.END
        
        if query.data == "custom_role":
            await query.edit_message_text(
                "✏️ <b>Назначение собственной роли</b>\n\n"
                "Введите название роли для пользователя:",
                parse_mode='HTML',
                reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
            )
            return AWAITING_CUSTOM_ROLE
        
        role_type = query.data.replace('role_type_', '')
        user_id = context.user_data['role_assignment_user']
        group_name = context.user_data['role_assignment_group']
        
        user_data = get_user(user_id)
        
        if not user_data:
            await query.edit_message_text("❌ Пользователь не найден.")
            return ConversationHandler.END
        
        # Устанавливаем роль
        if set_group_role(group_name, role_type, user_id, user_data['username'], user_data['first_name']):
            role_names = {
                'starosta': 'Староста',
                'deputy_starosta': 'Зам старосты',
                'physical_organizer': 'Физорг',
                'deputy_physical_organizer': 'Зам физорга'
            }
            
            await query.edit_message_text(
                f"✅ {role_names[role_type]} для группы {group_name} назначен!\n\n"
                f"👤 Пользователь: {user_data['first_name']} (@{user_data['username']})"
            )
        else:
            await query.edit_message_text("❌ Ошибка при назначении роли.")
        
        await show_main_menu(update, query.from_user.id)
        return ConversationHandler.END
            
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_role_type_selection: {e}")
        return ConversationHandler.END

async def handle_custom_role_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles custom role name input"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID:
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return await cancel_conversation(update, context)
        
        custom_role_name = update.message.text.strip()
        
        if custom_role_name == '❌ Отмена':
            return await start_role_assignment(update, context)
        
        # Проверяем, это глобальная собственная роль или для конкретного пользователя
        if context.user_data.get('custom_role_global'):
            # Глобальная собственная роль - запрашиваем ID пользователя
            try:
                target_user_id = int(custom_role_name)
                context.user_data['custom_role_user_id'] = target_user_id
                context.user_data.pop('custom_role_global', None)
                
                await update.message.reply_text(
                    "✏️ <b>Назначение собственной роли</b>\n\n"
                    "Введите название роли для пользователя:",
                    parse_mode='HTML',
                    reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
                )
                return AWAITING_CUSTOM_ROLE
            except ValueError:
                await update.message.reply_text(
                    "❌ Неверный формат ID пользователя. Введите числовой ID:",
                    reply_markup=ReplyKeyboardMarkup([['❌ Отмена']], resize_keyboard=True)
                )
                return AWAITING_CUSTOM_ROLE
        else:
            # Собственная роль для конкретного пользователя
            if 'custom_role_user_id' in context.user_data:
                target_user_id = context.user_data['custom_role_user_id']
            else:
                target_user_id = context.user_data.get('role_assignment_user')
            
            if not target_user_id:
                await update.message.reply_text("❌ Ошибка: пользователь не выбран.")
                return await cancel_conversation(update, context)
            
            target_user = get_user(target_user_id)
            
            if not target_user:
                await update.message.reply_text("❌ Пользователь не найден.")
                return ConversationHandler.END
            
            # Обновляем пользователя с собственной ролью
            rights_data = {
                'role': ROLE_CUSTOM,
                'custom_role_name': custom_role_name,
                'can_send_homework': target_user['can_send_homework'],
                'can_send_notifications': target_user['can_send_notifications'],
                'can_send_sport_notifications': target_user['can_send_sport_notifications'],
                'can_send_global_notifications': target_user['can_send_global_notifications'],
                'can_delete_homework': target_user['can_delete_homework'],
                'can_delete_notifications': target_user['can_delete_notifications'],
                'can_delete_sport_notifications': target_user['can_delete_sport_notifications'],
                'can_delete_suggestions': target_user['can_delete_suggestions'],
                'can_manage_users': target_user['can_manage_users'],
                'can_create_events': target_user['can_create_events']
            }
            
            if update_user_rights(target_user_id, rights_data):
                await update.message.reply_text(
                    f"✅ Пользователю {target_user['first_name']} установлена роль: {custom_role_name}!",
                    reply_markup=ReplyKeyboardRemove()
                )
            else:
                await update.message.reply_text(
                    "❌ Ошибка при установке роли.",
                    reply_markup=ReplyKeyboardRemove()
                )
            
            await show_main_menu(update, user_id)
            return ConversationHandler.END
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_custom_role_input: {e}")
        return AWAITING_CUSTOM_ROLE

# -------------------- USER RIGHTS MANAGEMENT FUNCTIONS --------------------

async def manage_user_rights_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows menu for managing user rights"""
    try:
        user_id = update.effective_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await update.message.reply_text("❌ У вас нет прав для этого действия.")
            return ConversationHandler.END
        
        # Группируем пользователей по группам
        users = get_all_users()
        groups_dict = {}
        for user in users:
            if user['user_id'] == user_id:
                continue
                
            group_name = user['group_name'] if user['group_name'] else "Без группы"
            if group_name not in groups_dict:
                groups_dict[group_name] = []
            groups_dict[group_name].append(user)
        
        if not groups_dict:
            await update.message.reply_text("❌ В базе данных нет пользователей.")
            return ConversationHandler.END
        
        keyboard = []
        for group_name, group_users in sorted(groups_dict.items()):
            keyboard.append([InlineKeyboardButton(f"📚 {group_name} ({len(group_users)} чел.)", callback_data=f"rights_group_{group_name}")])
        
        await update.message.reply_text(
            "👥 <b>Управление правами пользователей</b>\n\n"
            "Выберите группу для управления правами:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"ОШИБКА: Ошибка в manage_user_rights_menu: {e}")
        return ConversationHandler.END

async def handle_user_rights_group_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles group selection for rights management"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await query.edit_message_text("❌ У вас нет прав для этого действия.")
            return
        
        if query.data == "rights_back_to_groups":
            return await manage_user_rights_menu(update, context)
        
        group_name = query.data.replace('rights_group_', '')
        context.user_data['rights_management_group'] = group_name
        
        # Get users in selected group
        users_in_group = [user for user in get_all_users() if user['group_name'] == group_name and user['user_id'] != user_id]
        
        if not users_in_group:
            await query.edit_message_text(f"❌ В группе {group_name} нет других пользователей.")
            return
        
        keyboard = []
        for user in users_in_group:
            role_display = get_user_role_display(user['user_id'])
            button_text = f"{user['first_name']} (@{user['username']}) - {role_display}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"manage_rights_{user['user_id']}")])
        
        keyboard.append([InlineKeyboardButton("🔙 Назад к группам", callback_data="rights_back_to_groups")])
        
        await query.edit_message_text(
            f"👥 <b>Управление правами группы {group_name}</b>\n\n"
            "Выберите пользователя для изменения прав:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_user_rights_group_selection: {e}")
        return AWAITING_USER_RIGHTS

async def handle_user_rights_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles user selection for rights management"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await query.edit_message_text("❌ У вас нет прав для этого действия.")
            return
        
        if query.data == "rights_back_to_groups":
            return await manage_user_rights_menu(update, context)
        
        parts = query.data.split('_')
        target_user_id = int(parts[2])
        
        if target_user_id == user_id:
            await query.edit_message_text("❌ Нельзя изменять свои собственные права!")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("❌ Пользователь не найден.")
            return
        
        context.user_data['managing_user_id'] = target_user_id
        
        # Create rights management keyboard
        keyboard = [
            [InlineKeyboardButton(f"{'✅' if target_user['can_send_homework'] else '❌'} Отправка ДЗ", callback_data=f"toggle_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_send_notifications'] else '❌'} Отправка уведомлений", callback_data=f"toggle_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_send_sport_notifications'] else '❌'} Спортивные уведомления", callback_data=f"toggle_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_send_global_notifications'] else '❌'} Глобальные уведомления", callback_data=f"toggle_global_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_homework'] else '❌'} Удаление ДЗ", callback_data=f"toggle_del_homework_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_notifications'] else '❌'} Удаление уведомлений", callback_data=f"toggle_del_notifications_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_sport_notifications'] else '❌'} Удаление спортивных", callback_data=f"toggle_del_sport_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_delete_suggestions'] else '❌'} Удаление предложений", callback_data=f"toggle_del_suggestions_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_manage_users'] else '❌'} Управление пользователями", callback_data=f"toggle_manage_users_{target_user_id}")],
            [InlineKeyboardButton(f"{'✅' if target_user['can_create_events'] else '❌'} Создание событий", callback_data=f"toggle_create_events_{target_user_id}")],
            [InlineKeyboardButton("🔙 Назад к списку", callback_data=f"rights_back_to_users_{context.user_data['rights_management_group']}")],
            [InlineKeyboardButton("❌ Сбросить все права", callback_data=f"reset_rights_{target_user_id}")],
            [InlineKeyboardButton("✅ Сохранить и выйти", callback_data="save_rights")]
        ]
        
        role_display = get_user_role_display(target_user_id)
        
        await query.edit_message_text(
            f"👤 <b>Управление правами пользователя</b>\n\n"
            f"<b>Имя:</b> {target_user['first_name']}\n"
            f"<b>Юзернейм:</b> @{target_user['username']}\n"
            f"<b>Группа:</b> {target_user['group_name']}\n"
            f"<b>Роль:</b> {role_display}\n"
            f"<b>ID:</b> <code>{target_user['user_id']}</code>\n\n"
            f"<b>Текущие права:</b>\n"
            f"Нажмите на право для его изменения:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return AWAITING_USER_RIGHTS
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_user_rights_selection: {e}")
        return AWAITING_USER_RIGHTS

async def handle_rights_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles rights toggling"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        if user_id != DEVELOPER_ID and not can_manage_users(user_id):
            await query.edit_message_text("❌ У вас нет прав для этого действия.")
            return
        
        if query.data == "save_rights":
            await query.edit_message_text("✅ Права сохранены!")
            await show_main_menu(update, user_id)
            return ConversationHandler.END
        
        if query.data.startswith("rights_back_to_users_"):
            group_name = query.data.replace('rights_back_to_users_', '')
            context.user_data['rights_management_group'] = group_name
            return await handle_user_rights_group_selection(update, context)
        
        parts = query.data.split('_')
        
        if len(parts) == 3:
            action = parts[1]
            target_user_id = int(parts[2])
        elif len(parts) == 4:
            action = parts[1]
            sub_action = parts[2]
            target_user_id = int(parts[3])
            
            if action == "del":
                action = f"del_{sub_action}"
            elif action == "manage" and sub_action == "users":
                action = "manage_users"
            elif action == "create" and sub_action == "events":
                action = "create_events"
        else:
            await query.edit_message_text("❌ Неверный формат данных.")
            return
        
        target_user = get_user(target_user_id)
        if not target_user:
            await query.edit_message_text("❌ Пользователь не найден.")
            return
        
        # Update rights
        rights_data = {
            'can_send_homework': target_user['can_send_homework'],
            'can_send_notifications': target_user['can_send_notifications'],
            'can_send_sport_notifications': target_user['can_send_sport_notifications'],
            'can_send_global_notifications': target_user['can_send_global_notifications'],
            'can_delete_homework': target_user['can_delete_homework'],
            'can_delete_notifications': target_user['can_delete_notifications'],
            'can_delete_sport_notifications': target_user['can_delete_sport_notifications'],
            'can_delete_suggestions': target_user['can_delete_suggestions'],
            'can_manage_users': target_user['can_manage_users'],
            'can_create_events': target_user['can_create_events'],
            'role': target_user['role'],
            'custom_role_name': target_user['custom_role_name']
        }
        
        if action == "reset":
            # Reset all rights
            for key in rights_data:
                if key.startswith('can_'):
                    rights_data[key] = 0
            rights_data['role'] = ROLE_STUDENT
            rights_data['custom_role_name'] = None
        else:
            # Toggle specific right
            if action == "homework":
                rights_data['can_send_homework'] = 1 - rights_data['can_send_homework']
            elif action == "notifications":
                rights_data['can_send_notifications'] = 1 - rights_data['can_send_notifications']
            elif action == "sport":
                rights_data['can_send_sport_notifications'] = 1 - rights_data['can_send_sport_notifications']
            elif action == "global":
                rights_data['can_send_global_notifications'] = 1 - rights_data['can_send_global_notifications']
            elif action == "del_homework":
                rights_data['can_delete_homework'] = 1 - rights_data['can_delete_homework']
            elif action == "del_notifications":
                rights_data['can_delete_notifications'] = 1 - rights_data['can_delete_notifications']
            elif action == "del_sport":
                rights_data['can_delete_sport_notifications'] = 1 - rights_data['can_delete_sport_notifications']
            elif action == "del_suggestions":
                rights_data['can_delete_suggestions'] = 1 - rights_data['can_delete_suggestions']
            elif action == "manage_users":
                rights_data['can_manage_users'] = 1 - rights_data['can_manage_users']
            elif action == "create_events":
                rights_data['can_create_events'] = 1 - rights_data['can_create_events']
        
        if update_user_rights(target_user_id, rights_data):
            # Update message with new rights
            updated_user = get_user(target_user_id)
            
            keyboard = [
                [InlineKeyboardButton(f"{'✅' if updated_user['can_send_homework'] else '❌'} Отправка ДЗ", callback_data=f"toggle_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_send_notifications'] else '❌'} Отправка уведомлений", callback_data=f"toggle_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_send_sport_notifications'] else '❌'} Спортивные уведомления", callback_data=f"toggle_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_send_global_notifications'] else '❌'} Глобальные уведомления", callback_data=f"toggle_global_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_homework'] else '❌'} Удаление ДЗ", callback_data=f"toggle_del_homework_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_notifications'] else '❌'} Удаление уведомлений", callback_data=f"toggle_del_notifications_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_sport_notifications'] else '❌'} Удаление спортивных", callback_data=f"toggle_del_sport_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_delete_suggestions'] else '❌'} Удаление предложений", callback_data=f"toggle_del_suggestions_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_manage_users'] else '❌'} Управление пользователями", callback_data=f"toggle_manage_users_{target_user_id}")],
                [InlineKeyboardButton(f"{'✅' if updated_user['can_create_events'] else '❌'} Создание событий", callback_data=f"toggle_create_events_{target_user_id}")],
                [InlineKeyboardButton("🔙 Назад к списку", callback_data=f"rights_back_to_users_{context.user_data['rights_management_group']}")],
                [InlineKeyboardButton("❌ Сбросить все права", callback_data=f"reset_rights_{target_user_id}")],
                [InlineKeyboardButton("✅ Сохранить и выйти", callback_data="save_rights")]
            ]
            
            role_display = get_user_role_display(target_user_id)
            
            await query.edit_message_text(
                f"👤 <b>Управление правами пользователя</b>\n\n"
                f"<b>Имя:</b> {updated_user['first_name']}\n"
                f"<b>Юзернейм:</b> @{updated_user['username']}\n"
                f"<b>Группа:</b> {updated_user['group_name']}\n"
                f"<b>Роль:</b> {role_display}\n"
                f"<b>ID:</b> <code>{updated_user['user_id']}</code>\n\n"
                f"<b>Текущие права:</b>\n"
                f"Нажмите на право для его изменения:",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await query.edit_message_text("❌ Ошибка при обновлении прав.")
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_rights_toggle: {e}")
        await query.edit_message_text("❌ Произошла ошибка при обновлении прав.")

# -------------------- SEND AND DELETE CALLBACK HANDLERS --------------------

async def handle_send_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles send menu callbacks"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        user_data = get_user(user_id)
        
        if query.data == "send_back":
            await query.edit_message_text("🔙 Возврат в главное меню")
            await show_main_menu(update, user_id)
            return
        
        elif query.data == "send_homework":
            if can_send_homework(user_id, user_data['group_name']):
                await query.edit_message_text("📚 <b>Отправка ДЗ</b>")
                await ask_homework_details(update, context)
            else:
                await query.edit_message_text("❌ У вас нет прав для отправки ДЗ")
                
        elif query.data == "send_notification":
            if can_send_notifications(user_id, user_data['group_name']):
                await query.edit_message_text("📢 <b>Отправка уведомления</b>")
                await ask_notification_details(update, context)
            else:
                await query.edit_message_text("❌ У вас нет прав для отправки уведомлений")
                
        elif query.data == "send_sport":
            if can_send_sport_notifications(user_id, user_data['group_name']):
                await query.edit_message_text("🏃‍♂️ <b>Отправка спортивного уведомления</b>")
                await ask_sport_notification_details(update, context)
            else:
                await query.edit_message_text("❌ У вас нет прав для отправки спортивных уведомлений")
                
        elif query.data == "send_global":
            if can_send_global_notifications(user_id):
                await query.edit_message_text("🌍 <b>Отправка глобального уведомления</b>")
                await ask_global_notification_details(update, context)
            else:
                await query.edit_message_text("❌ У вас нет прав для глобальных уведомлений")
                
        elif query.data == "send_event":
            if can_create_events(user_id, user_data['group_name']):
                await query.edit_message_text("📅 <b>Создание события</b>")
                await ask_event_details(update, context)
            else:
                await query.edit_message_text("❌ У вас нет прав для создания событий")
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_send_callback: {e}")

async def handle_delete_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles delete menu callbacks"""
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        if query.data == "delete_back":
            await query.edit_message_text("🔙 Возврат в главное меню")
            await show_main_menu(update, user_id)
            return
        
        elif query.data == "delete_homework_menu":
            await query.edit_message_text("🗑️ <b>Удаление ДЗ</b>")
            await delete_homework_menu(update, context)
            
        elif query.data == "delete_notification_menu":
            await query.edit_message_text("🗑️ <b>Удаление уведомлений</b>")
            await delete_notification_menu(update, context)
            
        elif query.data == "delete_sport_menu":
            await query.edit_message_text("🗑️ <b>Удаление спортивных уведомлений</b>")
            await delete_sport_notification_menu(update, context)
            
        elif query.data == "delete_suggestions_menu":
            await query.edit_message_text("🗑️ <b>Удаление предложений</b>")
            await delete_suggestions_menu(update, context)
            
        elif query.data == "delete_user_menu":
            await query.edit_message_text("🗑️ <b>Удаление пользователей</b>")
            await delete_user_menu(update, context)
        
    except Exception as e:
        print(f"ОШИБКА: Ошибка в handle_delete_menu_callback: {e}")

# -------------------- JOB QUEUE FUNCTIONS --------------------

async def init_schedule_cache(application):
    """Initializes the schedule cache and groups list"""
    try:
        global schedule_cache, last_schedule_check
        schedule_data = fetch_schedule_data()
        if schedule_data:
            schedule_cache = schedule_data
            last_schedule_check = datetime.now(YEKATERINBURG_TZ)
            print("ЛОГ: Кэш расписания инициализирован")
        
        # Initialize groups list
        fetch_groups_list()
        print("ЛОГ: Список групп инициализирован")
    except Exception as e:
        print(f"ОШИБКА: Ошибка при инициализации кэша расписания: {e}")

# -------------------- MAIN FUNCTION --------------------

def main():
    """Main function to run the bot"""
    try:
        init_db()
        
        app = Application.builder().token(BOT_TOKEN).post_init(init_schedule_cache).build()
        
        job_queue = app.job_queue
        job_queue.run_repeating(check_schedule_changes, interval=3600, first=10)
        job_queue.run_repeating(check_lesson_notifications, interval=60, first=10)
        job_queue.run_repeating(check_events, interval=3600, first=10)  # Check events every hour
        job_queue.run_daily(send_daily_schedule, time=time(hour=19, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(send_morning_schedule, time=time(hour=7, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        job_queue.run_daily(check_birthdays, time=time(hour=0, minute=0, tzinfo=YEKATERINBURG_TZ), days=(0, 1, 2, 3, 4, 5, 6))
        
        conv_handler = ConversationHandler(
            entry_points=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^📚 Отправить ДЗ$'), ask_homework_details),
                MessageHandler(filters.Regex('^📢 Отправить уведомление$'), ask_notification_details),
                MessageHandler(filters.Regex('^🏃‍♂️ Отправить спортивное уведомление$'), ask_sport_notification_details),
                MessageHandler(filters.Regex('^📅 Создать событие$'), ask_event_details),
                MessageHandler(filters.Regex('^💡 Предложить идею$'), ask_suggestion_details),
                MessageHandler(filters.Regex('^🗑️ Удалить ДЗ$'), delete_homework_menu),
                MessageHandler(filters.Regex('^🗑️ Удалить уведомление$'), delete_notification_menu),
                MessageHandler(filters.Regex('^🗑️ Удалить спортивные уведомления$'), delete_sport_notification_menu),
                MessageHandler(filters.Regex('^🗑️ Удалить предложения$'), delete_suggestions_menu),
                MessageHandler(filters.Regex('^🗑️ Удалить пользователя$'), delete_user_menu),
                MessageHandler(filters.Regex('^🎓 Сменить группу$'), ask_user_group),
                MessageHandler(filters.Regex('^🎂 Установить день рождения$'), ask_birthday_date),
                MessageHandler(filters.Regex('^🌍 Отправить всем группам$'), ask_global_notification_details),
                MessageHandler(filters.Regex('^👑 Назначить роль$'), start_role_assignment),
                MessageHandler(filters.Regex('^🔧 Управление правами$'), manage_user_rights_menu),
                MessageHandler(filters.Regex('^🔧 Настройки уведомлений$'), show_notification_settings),
            ],
            states={
                AWAITING_GROUP: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_group_selection),
                ],
                AWAITING_HOMEWORK: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_homework_input)],
                AWAITING_INFO: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_notification_input)],
                AWAITING_SPORT: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_sport_input)],
                AWAITING_SUGGESTION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_suggestion_input)],
                AWAITING_SUGGESTION_RESPONSE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_suggestion_response_input)],
                AWAITING_BIRTHDAY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_birthday_input)],
                AWAITING_GLOBAL_NOTIFICATION: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_global_notification_input)],
                AWAITING_EVENT: [MessageHandler(filters.TEXT | filters.PHOTO | filters.VIDEO | filters.Document.ALL, handle_event_input)],
                AWAITING_EVENT_BUTTONS: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_event_buttons_input)],
                AWAITING_ROLE_ASSIGNMENT: [
                    CallbackQueryHandler(handle_role_group_selection, pattern='^role_group_'),
                    CallbackQueryHandler(handle_role_user_selection, pattern='^role_user_'),
                    CallbackQueryHandler(handle_role_type_selection, pattern='^role_type_'),
                    CallbackQueryHandler(handle_role_type_selection, pattern='^role_back_to_users_'),
                    CallbackQueryHandler(handle_role_group_selection, pattern='^role_back_to_groups'),
                    CallbackQueryHandler(handle_role_type_selection, pattern='^role_remove_'),
                    CallbackQueryHandler(start_role_assignment, pattern='^role_cancel$'),
                ],
                AWAITING_CUSTOM_ROLE: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_custom_role_input)
                ],
                AWAITING_USER_RIGHTS: [
                    CallbackQueryHandler(handle_user_rights_group_selection, pattern='^rights_group_'),
                    CallbackQueryHandler(handle_user_rights_selection, pattern='^manage_rights_'),
                    CallbackQueryHandler(handle_rights_toggle, pattern='^(toggle_|reset_|rights_back_|save_)'),
                    CallbackQueryHandler(handle_user_rights_group_selection, pattern='^rights_back_to_users_'),
                ],
                AWAITING_NOTIFICATION_SETTINGS: [
                    CallbackQueryHandler(handle_notification_settings_callback, pattern='^(toggle_|done_)')
                ],
                AWAITING_HOMEWORK_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_hw_')],
                AWAITING_INFO_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_notif_')],
                AWAITING_SPORT_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sport_')],
                AWAITING_USER_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_user_')],
                AWAITING_SUGGESTION_DELETE: [CallbackQueryHandler(handle_delete_callback, pattern='^del_sugg_')]
            },
            fallbacks=[
                CommandHandler('start', start_command),
                MessageHandler(filters.Regex('^❌ Отмена$'), cancel_conversation),
                CallbackQueryHandler(cancel_conversation, pattern='^role_cancel$')
            ],
            allow_reentry=True
        )
        
        app.add_handler(conv_handler)
        app.add_handler(CallbackQueryHandler(handle_suggestion_response_callback, pattern='^respond_'))
        app.add_handler(CallbackQueryHandler(handle_event_button_callback, pattern='^event_'))
        app.add_handler(CallbackQueryHandler(handle_show_users_callback, pattern='^show_users_'))
        app.add_handler(CallbackQueryHandler(handle_back_to_groups, pattern='^back_to_groups$'))
        app.add_handler(CallbackQueryHandler(handle_send_callback, pattern='^send_'))
        app.add_handler(CallbackQueryHandler(handle_delete_menu_callback, pattern='^delete_'))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_simple_message))
        
        # Добавляем обработчик для неизвестных сообщений
        app.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_unknown_message))
        
        print("ЛОГ: Бот запущен!")
        app.run_polling()
        
    except Exception as e:
        print(f"КРИТИЧЕСКАЯ ОШИБКА: {e}")

if __name__ == "__main__":
    main()
